From 974b9a30c9be8d519bf82d7e24e5d6345901a80e Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 29 May 2017 21:16:28 +0900
Subject: drm: rcar-du: PLL in LVDS support

In R-Car D3, dotclock is used with PLL in LVDS.

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c    |  17 +++
 drivers/gpu/drm/rcar-du/rcar_du_drv.c     |   3 +-
 drivers/gpu/drm/rcar-du/rcar_du_drv.h     |   1 +
 drivers/gpu/drm/rcar-du/rcar_du_group.c   |  10 +-
 drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c | 231 +++++++++++++++++++++++++++++-
 drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h |   6 +
 drivers/gpu/drm/rcar-du/rcar_du_regs.h    |   1 +
 drivers/gpu/drm/rcar-du/rcar_lvds_regs.h  |  45 +++++-
 8 files changed, 307 insertions(+), 7 deletions(-)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index 2442eb2..99df289 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -27,6 +27,7 @@
 #include "rcar_du_crtc.h"
 #include "rcar_du_drv.h"
 #include "rcar_du_kms.h"
+#include "rcar_du_lvdsenc.h"
 #include "rcar_du_plane.h"
 #include "rcar_du_regs.h"
 #include "rcar_du_vsp.h"
@@ -265,6 +266,9 @@ static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 
 	kfree(dpll);
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL))
+		escr = 0;
+
 	rcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? ESCR2 : ESCR,
 			    escr);
 	rcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? OTAR2 : OTAR, 0);
@@ -274,6 +278,7 @@ static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 	      | ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? DSMR_HSL : 0)
 	      | ((mode->flags & DRM_MODE_FLAG_INTERLACE) ? DSMR_ODEV : 0)
 	      | DSMR_DIPM_DISP | DSMR_CSPM;
+
 	rcar_du_crtc_write(rcrtc, DSMR, value);
 
 	/* Display timings */
@@ -477,11 +482,16 @@ static void rcar_du_crtc_wait_page_flip(struct rcar_du_crtc *rcrtc)
 static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 {
 	struct drm_crtc *crtc = &rcrtc->crtc;
+	struct rcar_du_device *rcdu = rcrtc->group->dev;
 	bool interlaced;
 
 	if (rcrtc->started)
 		return;
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL))
+		 rcar_du_lvdsenc_pll_pre_start(rcdu->lvds[rcrtc->index],
+					       rcrtc);
+
 	/* Set display off and background to black */
 	rcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));
 	rcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));
@@ -502,6 +512,9 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 			     (interlaced ? DSYSR_SCM_INT_VIDEO : 0) |
 			     DSYSR_TVM_MASTER);
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL))
+		rcar_du_lvdsenc_enable(rcdu->lvds[rcrtc->index], crtc, true);
+
 	rcar_du_group_start_stop(rcrtc->group, true, rcrtc);
 
 	/* Enable the VSP compositor. */
@@ -517,6 +530,7 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 static void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)
 {
 	struct drm_crtc *crtc = &rcrtc->crtc;
+	struct rcar_du_device *rcdu = rcrtc->group->dev;
 
 	if (!rcrtc->started)
 		return;
@@ -552,6 +566,9 @@ static void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)
 
 	rcar_du_group_start_stop(rcrtc->group, false, rcrtc);
 
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL))
+		rcar_du_lvdsenc_stop_suspend(rcdu->lvds[rcrtc->index]);
+
 	rcrtc->started = false;
 }
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index ba7dba2..eb3f1c5 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -281,7 +281,8 @@
 	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
 		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
 		  | RCAR_DU_FEATURE_VSP1_SOURCE
-		  | RCAR_DU_FEATURE_GEN3_REGS,
+		  | RCAR_DU_FEATURE_GEN3_REGS
+		  | RCAR_DU_FEATURE_LVDS_PLL,
 	.num_crtcs = 2,
 	.routes = {
 		/* R8A77995 has two LVDS output and one RGB output.
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index 45d6e7e..701aabd 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -40,6 +40,7 @@
 #define RCAR_DU_FEATURE_GEN3_REGS	(1 << 3)	/* Use Gen3 registers */
 #define RCAR_DU_FEATURE_DIDSR2_REG	(1 << 4)	/* Has DIDSR2 register */
 #define RCAR_DU_FEATURE_VSPDL_SOURCE	(1 << 5)	/* Has VSPDL from VSP2 */
+#define RCAR_DU_FEATURE_LVDS_PLL	(1 << 6)	/* Use PLL in LVDS */
 
 #define RCAR_DU_QUIRK_ALIGN_128B	(1 << 0)	/* Align pitches to 128 bytes */
 #define RCAR_DU_QUIRK_LVDS_LANES	(1 << 1)	/* LVDS lanes 1 and 3 inverted */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_group.c b/drivers/gpu/drm/rcar-du/rcar_du_group.c
index ccf5159..ed496a8 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_group.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_group.c
@@ -120,7 +120,15 @@ static void rcar_du_group_setup(struct rcar_du_group *rgrp)
 				    DIDSR_PDCS_CLK(1, 0) |
 				    DIDSR_PDCS_CLK(0, 0));
 		} else {
-			if (rgrp->index == 0) {
+			if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL)) {
+				rcar_du_group_write(rgrp,
+				    DIDSR, DIDSR_CODE |
+				    DIDSR_LCDS1_LVDSIF |
+				    DIDSR_LCDS0_LVDSIF |
+				    DIDSR_PDCS_CLK(1, 0) |
+				    DIDSR_PDCS_CLK(0, 0));
+			} else
+			 if (rgrp->index == 0) {
 				rcar_du_group_write(rgrp,
 				    DIDSR, DIDSR_CODE |
 				    DIDSR_LCDS0_DCLKIN |
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
index bff3cf6..10f5d9b 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
@@ -23,6 +23,15 @@
 #include "rcar_du_lvdsenc.h"
 #include "rcar_lvds_regs.h"
 
+struct pll_info {
+	unsigned int pllclk;
+	unsigned int diff;
+	unsigned int clk_n;
+	unsigned int clk_m;
+	unsigned int clk_e;
+	unsigned int div;
+};
+
 struct rcar_du_lvdsenc {
 	struct rcar_du_device *dev;
 
@@ -186,6 +195,209 @@ int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,
 	return 0;
 }
 
+static void rcar_du_lvdsenc_pll_calc(struct rcar_du_crtc *rcrtc,
+				     struct pll_info *pll, unsigned int in_fre,
+				     unsigned int mode_freq, bool edivider)
+{
+	unsigned long fout, fpfd, fvco, diff, n, m, e, div;
+	bool match_flag = false;
+	bool clk_diff_set = true;
+
+	if ((in_fre < 12000000) || (in_fre > 192000000))
+		return;
+
+	for (n = 0; n < 127; n++) {
+		if (((n + 1) < 60) || ((n + 1) > 120))
+			continue;
+
+		for (m = 0; m < 7; m++) {
+			for (e = 0; e < 1; e++) {
+				if (edivider)
+					fout = (((in_fre / 1000) * (n + 1)) /
+						((m + 1) * (e + 1) * 2)) *
+						1000;
+				else
+					fout = (((in_fre / 1000) * (n + 1)) /
+						(m + 1)) * 1000;
+
+				if (fout > 1039500000)
+					continue;
+
+				fpfd  = (in_fre / (m + 1));
+				if ((fpfd < 12000000) || (fpfd > 24000000))
+					continue;
+
+				fvco  = (((in_fre / 1000) * (n + 1)) / (m + 1))
+					 * 1000;
+				if ((fvco < 900000000) || (fvco > 1800000000))
+					continue;
+
+				fout = fout / 7; /* 7 divider */
+
+				for (div = 0; div < 64; div++) {
+
+					diff = abs((long)(fout / (div + 1)) -
+					       (long)mode_freq);
+
+					if (clk_diff_set || ((diff == 0) ||
+					    (pll->diff > diff))) {
+						pll->diff = diff;
+						pll->clk_n = n;
+						pll->clk_m = m;
+						pll->clk_e = e;
+						pll->pllclk = fout;
+						pll->div = div;
+
+						if (clk_diff_set)
+							clk_diff_set = false;
+
+						if (diff == 0) {
+							match_flag = true;
+							break;
+						}
+					}
+				}
+				if (match_flag)
+					break;
+			}
+			if (match_flag)
+				break;
+		}
+		if (match_flag)
+			break;
+	}
+}
+
+void rcar_du_lvdsenc_pll_pre_start(struct rcar_du_lvdsenc *lvds,
+				   struct rcar_du_crtc *rcrtc)
+{
+	const struct drm_display_mode *mode =
+				&rcrtc->crtc.state->adjusted_mode;
+	unsigned int mode_freq = mode->clock * 1000;
+	unsigned int extal_freq = 48000000; /* EXTAL 48MHz */
+	struct pll_info *lvds_pll[2];
+	int i, ret;
+	void __iomem *srstclr7_reg;
+	u32 srstclr7_lvds = 0;
+	u32 clksel;
+
+	if (lvds->enabled)
+		return;
+
+	for (i = 0; i < RCAR_DU_MAX_LVDS; i++) {
+		lvds_pll[i] = kzalloc(sizeof(*lvds_pll), GFP_KERNEL);
+		if (lvds_pll[i] == NULL)
+			return;
+	}
+
+	/* software reset release */
+	if (lvds->index == 0)
+		srstclr7_lvds |= SRCR7_LVDS;
+	srstclr7_reg = ioremap_nocache(SRSTCLR7, 0x04);
+	writel_relaxed(srstclr7_lvds, srstclr7_reg);
+	iounmap(srstclr7_reg);
+
+	if (gpio_is_valid(lvds->gpio_pd))
+		gpio_set_value(lvds->gpio_pd, 1);
+
+	ret = clk_prepare_enable(lvds->clock);
+	if (ret < 0)
+		goto end;
+
+	for (i = 0; i < 2; i++) {
+		bool edivider;
+
+		if (i == 0)
+			edivider = true;
+		else
+			edivider = false;
+
+		rcar_du_lvdsenc_pll_calc(rcrtc, lvds_pll[i], extal_freq,
+					 mode_freq, edivider);
+	}
+
+	dev_dbg(rcrtc->group->dev->dev, "mode_frequency %d Hz\n", mode_freq);
+
+	if (lvds_pll[1]->diff >= lvds_pll[0]->diff) {
+		/* use E-edivider */
+		i = 0;
+		clksel = LVDPLLCR_OUTCLKSEL_AFTER |
+			 LVDPLLCR_STP_CLKOUTE1_EN;
+	} else {
+		/* not use E-divider */
+		i = 1;
+		clksel = LVDPLLCR_OUTCLKSEL_BEFORE |
+			 LVDPLLCR_STP_CLKOUTE1_DIS;
+	}
+	dev_dbg(rcrtc->group->dev->dev,
+		"E-divider %s\n", (i == 0 ? "is used" : "is not used"));
+
+	dev_dbg(rcrtc->group->dev->dev,
+		"pllclk:%u, n:%u, m:%u, e:%u, diff:%u, div:%u\n",
+		 lvds_pll[i]->pllclk, lvds_pll[i]->clk_n, lvds_pll[i]->clk_m,
+		 lvds_pll[i]->clk_e, lvds_pll[i]->diff, lvds_pll[i]->div);
+
+	rcar_lvds_write(lvds, LVDPLLCR, LVDPLLCR_PLLON |
+			LVDPLLCR_OCKSEL_7 | clksel | LVDPLLCR_CLKOUT_ENABLE |
+			LVDPLLCR_CKSEL_EXTAL | (lvds_pll[i]->clk_e << 10) |
+			(lvds_pll[i]->clk_n << 3) | lvds_pll[i]->clk_m);
+
+	if (lvds_pll[i]->div > 0)
+		rcar_lvds_write(lvds, LVDDIV, LVDDIV_DIVSEL |
+				LVDDIV_DIVRESET | lvds_pll[i]->div);
+	else
+		rcar_lvds_write(lvds, LVDDIV, 0);
+
+	dev_dbg(rcrtc->group->dev->dev, "LVDPLLCR: 0x%x\n",
+		ioread32(lvds->mmio + LVDPLLCR));
+	dev_dbg(rcrtc->group->dev->dev, "LVDDIV: 0x%x\n",
+		ioread32(lvds->mmio + LVDDIV));
+
+end:
+	for (i = 0; i < RCAR_DU_MAX_LVDS; i++)
+		kfree(lvds_pll[i]);
+
+	return;
+}
+
+static int rcar_du_lvdsenc_pll_start(struct rcar_du_lvdsenc *lvds,
+				    struct rcar_du_crtc *rcrtc)
+{
+	u32 lvdhcr, lvdcr0;
+
+	rcar_lvds_write(lvds, LVDCTRCR, LVDCTRCR_CTR3SEL_ZERO |
+			LVDCTRCR_CTR2SEL_DISP | LVDCTRCR_CTR1SEL_VSYNC |
+			LVDCTRCR_CTR0SEL_HSYNC);
+
+	lvdhcr = LVDCHCR_CHSEL_CH(0, 0) | LVDCHCR_CHSEL_CH(1, 1) |
+		 LVDCHCR_CHSEL_CH(2, 2) | LVDCHCR_CHSEL_CH(3, 3);
+	rcar_lvds_write(lvds, LVDCHCR, lvdhcr);
+
+	rcar_lvds_write(lvds, LVDSTRIPE, 0);
+	/* Turn all the channels on. */
+	rcar_lvds_write(lvds, LVDCR1,
+			LVDCR1_CHSTBY_GEN3(3) | LVDCR1_CHSTBY_GEN3(2) |
+			LVDCR1_CHSTBY_GEN3(1) | LVDCR1_CHSTBY_GEN3(0) |
+			LVDCR1_CLKSTBY_GEN3);
+	/*
+	 * Turn the PLL on, set it to LVDS normal mode, wait for the startup
+	 * delay and turn the output on.
+	 */
+	lvdcr0 = (lvds->mode << LVDCR0_LVMD_SHIFT) | LVDCR0_PWD;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+
+	lvdcr0 |= LVDCR0_LVEN;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+
+	lvdcr0 |= LVDCR0_LVRES;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+
+	rcrtc->lvds_ch = lvds->index;
+	lvds->enabled = true;
+
+	return 0;
+}
+
 int rcar_du_lvdsenc_stop_suspend(struct rcar_du_lvdsenc *lvds)
 {
 	void __iomem *srcr7_reg;
@@ -196,6 +408,7 @@ int rcar_du_lvdsenc_stop_suspend(struct rcar_du_lvdsenc *lvds)
 
 	rcar_lvds_write(lvds, LVDCR0, 0);
 	rcar_lvds_write(lvds, LVDCR1, 0);
+	rcar_lvds_write(lvds, LVDPLLCR, 0);
 
 	clk_disable_unprepare(lvds->clock);
 
@@ -215,15 +428,18 @@ int rcar_du_lvdsenc_stop_suspend(struct rcar_du_lvdsenc *lvds)
 
 static void rcar_du_lvdsenc_stop(struct rcar_du_lvdsenc *lvds)
 {
+	struct rcar_du_device *rcdu = lvds->dev;
 	int ret;
 	unsigned int i;
 
 	if (!lvds->enabled)
 		return;
 
-	ret = rcar_du_lvdsenc_stop_suspend(lvds);
-	if (ret < 0)
-		return;
+	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL)) {
+		ret = rcar_du_lvdsenc_stop_suspend(lvds);
+		if (ret < 0)
+			return;
+	}
 
 	for (i = 0; i < lvds->dev->num_crtcs; ++i)
 		if (lvds->index == lvds->dev->crtcs[i].lvds_ch)
@@ -235,14 +451,21 @@ static void rcar_du_lvdsenc_stop(struct rcar_du_lvdsenc *lvds)
 int rcar_du_lvdsenc_enable(struct rcar_du_lvdsenc *lvds, struct drm_crtc *crtc,
 			   bool enable)
 {
+	struct rcar_du_device *rcdu = lvds->dev;
+
 	if (!enable) {
 		rcar_du_lvdsenc_stop(lvds);
 		return 0;
 	} else if (crtc) {
 		struct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);
-		return rcar_du_lvdsenc_start(lvds, rcrtc);
+		if (rcar_du_has(rcdu, RCAR_DU_FEATURE_LVDS_PLL))
+			return rcar_du_lvdsenc_pll_start(lvds, rcrtc);
+		else
+			return rcar_du_lvdsenc_start(lvds, rcrtc);
 	} else
 		return -EINVAL;
+
+	return 0;
 }
 
 void rcar_du_lvdsenc_atomic_check(struct rcar_du_lvdsenc *lvds,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
index e18e632..e1f714b 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
@@ -44,6 +44,8 @@ void rcar_du_lvdsenc_atomic_check(struct rcar_du_lvdsenc *lvds,
 int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,
 				 struct rcar_du_crtc *rcrtc);
 int rcar_du_lvdsenc_stop_suspend(struct rcar_du_lvdsenc *lvds);
+void rcar_du_lvdsenc_pll_pre_start(struct rcar_du_lvdsenc *lvds,
+				   struct rcar_du_crtc *rcrtc);
 #else
 static inline int rcar_du_lvdsenc_init(struct rcar_du_device *rcdu)
 {
@@ -71,6 +73,10 @@ static inline int rcar_du_lvdsenc_stop_suspend(struct rcar_du_lvdsenc *lvds)
 {
 	return 0;
 }
+static inline void rcar_du_lvdsenc_pll_pre_start(struct rcar_du_lvdsenc *lvds,
+					       struct rcar_du_crtc *rcrtc)
+{
+}
 #endif
 
 #endif /* __RCAR_DU_LVDSENC_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_regs.h b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
index 4d43d93..6baadaf 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
@@ -255,6 +255,7 @@
 
 #define DIDSR			0x20028
 #define DIDSR_CODE		(0x7790 << 16)
+#define DIDSR_LCDS1_LVDSIF	(1 << 11)
 #define DIDSR_LCDS0_DCLKIN	(0 << 9)
 #define DIDSR_LCDS0_LVDSIF	(1 << 9)
 #define DIDSR_LCDS_DCLKIN(n)	(0 << (8 + (n) * 2))
diff --git a/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h b/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
index 2ce9277..d5c11f4 100644
--- a/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
@@ -21,7 +21,7 @@
 #define LVDCR0_PLLON			(1 << 4)
 #define LVDCR0_PWD			(1 << 2)		/* Gen3 only */
 #define LVDCR0_BEN			(1 << 2)		/* Gen2 only */
-#define LVDCR0_LVEN			(1 << 1)		/* Gen2 only */
+#define LVDCR0_LVEN			(1 << 1)
 #define LVDCR0_LVRES			(1 << 0)
 
 #define LVDCR1				0x0004
@@ -47,6 +47,23 @@
 #define LVDPLLCR_PLLDIVCNT_128M		(0x006c3 << 0)
 #define LVDPLLCR_PLLDIVCNT_148M		(0x046c1 << 0)
 #define LVDPLLCR_PLLDIVCNT_MASK		(0x7ffff << 0)
+/* R-Car D3 */
+#define LVDPLLCR_PLLON			(1 << 22)
+#define LVDPLLCR_PLLSEL_PLL0		(0 << 22)
+#define LVDPLLCR_PLLSEL_LVX		(1 << 22)
+#define LVDPLLCR_PLLSEL_PLL1		(2 << 22)
+#define LVDPLLCR_CKSEL_LVX		(1 << 17)
+#define LVDPLLCR_CKSEL_EXTAL		(3 << 17)
+#define LVDPLLCR_CKSEL_DU_DOTCLKIN0	(5 << 17)
+#define LVDPLLCR_CKSEL_DU_DOTCLKIN1	(7 << 17)
+#define LVDPLLCR_OCKSEL_7		(0 << 16)
+#define LVDPLLCR_OCKSEL_NOT_DIVIDED	(1 << 16)
+#define LVDPLLCR_STP_CLKOUTE1_DIS	(0 << 14)
+#define LVDPLLCR_STP_CLKOUTE1_EN	(1 << 14)
+#define LVDPLLCR_OUTCLKSEL_BEFORE	(0 << 12)
+#define LVDPLLCR_OUTCLKSEL_AFTER	(1 << 12)
+#define LVDPLLCR_CLKOUT_DISABLE		(0 << 11)
+#define LVDPLLCR_CLKOUT_ENABLE		(1 << 11)
 
 #define LVDCTRCR			0x000c
 #define LVDCTRCR_CTR3SEL_ZERO		(0 << 12)
@@ -76,6 +93,32 @@
 #define LVDCHCR_CHSEL_CH(n, c)		((((c) - (n)) & 3) << ((n) * 4))
 #define LVDCHCR_CHSEL_MASK(n)		(3 << ((n) * 4))
 
+#define LVDSTRIPE			0x0014
+#define LVDSTRIPE_ST_TRGSEL_DISP	(0 << 2)
+#define LVDSTRIPE_ST_TRGSEL_HSYNC_R	(1 << 2)
+#define LVDSTRIPE_ST_TRGSEL_HSYNC_F	(2 << 2)
+
+#define LVDSTRIPE_ST_SWAP_NORMAL	(0 << 1)
+#define LVDSTRIPE_ST_SWAP_SWAP		(1 << 1)
+#define LVDSTRIPE_ST_ON			(1 << 0)
+
+#define LVDSCR				0x0018
+#define LVDSCR_DEPTH_DP1		(0 << 29)
+#define LVDSCR_DEPTH_DP2		(1 << 29)
+#define LVDSCR_DEPTH_DP3		(2 << 29)
+#define LVDSCR_BANDSET_10KHZ_LESS_THAN	(1 << 28)
+#define LVDSCR_SDIV_SR1			(0 << 22)
+#define LVDSCR_SDIV_SR2			(1 << 22)
+#define LVDSCR_SDIV_SR4			(2 << 22)
+#define LVDSCR_SDIV_SR8			(3 << 22)
+#define LVDSCR_MODE_DOWN		(1 << 21)
+#define LVDSCR_RSTN_ENABLE		(1 << 20)
+
+#define LVDDIV				0x001c
+#define LVDDIV_DIVSEL			(1 << 8)
+#define LVDDIV_DIVRESET			(1 << 7)
+#define LVDDIV_DIVSTP			(1 << 6)
+
 #define SRCR7		0xE61501CC
 #define SRSTCLR7	0xE615095C
 #define SRCR7_LVDS	(1 << 27)
-- 
1.9.1

