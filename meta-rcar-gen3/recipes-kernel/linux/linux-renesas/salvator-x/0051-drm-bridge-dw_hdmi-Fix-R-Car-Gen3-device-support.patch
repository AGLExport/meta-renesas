From e1d52ef99d0b1de544538e3acc746877d2af812a Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 27 Jul 2015 10:48:02 +0900
Subject: [PATCH 51/85] drm: bridge/dw_hdmi: Fix R-Car Gen3 device support

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
---
 drivers/gpu/drm/bridge/dw_hdmi.c |  106 ++++++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/rcar-du/Kconfig  |    1 +
 include/drm/bridge/dw_hdmi.h     |    4 ++
 3 files changed, 111 insertions(+)

diff --git a/drivers/gpu/drm/bridge/dw_hdmi.c b/drivers/gpu/drm/bridge/dw_hdmi.c
index ea2e394..67924f7 100644
--- a/drivers/gpu/drm/bridge/dw_hdmi.c
+++ b/drivers/gpu/drm/bridge/dw_hdmi.c
@@ -1,6 +1,7 @@
 /*
  * DesignWare High-Definition Multimedia Interface (HDMI) driver
  *
+ * Copyright (C) 2015 Renesas Electronics Corporation
  * Copyright (C) 2013-2015 Mentor Graphics Inc.
  * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
  * Copyright (C) 2010, Guennadi Liakhovetski <g.liakhovetski at gmx.de>
@@ -20,6 +21,9 @@
 #include <linux/mutex.h>
 #include <linux/of_device.h>
 
+#ifdef CONFIG_DRM_RCAR_HDMI
+#include <drm/drm_atomic_helper.h>
+#endif
 #include <drm/drm_of.h>
 #include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
@@ -142,7 +146,9 @@ struct dw_hdmi {
 	enum dw_hdmi_devtype dev_type;
 	struct device *dev;
 	struct clk *isfr_clk;
+#ifndef CONFIG_DRM_RCAR_HDMI
 	struct clk *iahb_clk;
+#endif
 	struct dw_hdmi_i2c *i2c;
 
 	struct hdmi_data_info hdmi_data;
@@ -783,12 +789,14 @@ static void hdmi_video_csc(struct dw_hdmi *hdmi)
 
 	if (hdmi->hdmi_data.enc_color_depth == 8)
 		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;
+#ifndef CONFIG_DRM_RCAR_HDMI
 	else if (hdmi->hdmi_data.enc_color_depth == 10)
 		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;
 	else if (hdmi->hdmi_data.enc_color_depth == 12)
 		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;
 	else if (hdmi->hdmi_data.enc_color_depth == 16)
 		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;
+#endif
 	else
 		return;
 
@@ -808,7 +816,9 @@ static void hdmi_video_csc(struct dw_hdmi *hdmi)
 static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 {
 	unsigned int color_depth = 0;
+#ifndef CONFIG_DRM_RCAR_HDMI
 	unsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;
+#endif
 	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
 	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
 	u8 val, vp_conf;
@@ -829,6 +839,7 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 		} else {
 			return;
 		}
+#ifndef CONFIG_DRM_RCAR_HDMI
 	} else if (hdmi_data->enc_out_format == YCBCR422_8BITS) {
 		if (!hdmi_data->enc_color_depth ||
 		    hdmi_data->enc_color_depth == 8)
@@ -840,6 +851,7 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 		else
 			return;
 		output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;
+#endif
 	} else {
 		return;
 	}
@@ -871,7 +883,9 @@ static void hdmi_video_packetize(struct dw_hdmi *hdmi)
 	hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
 		  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
 
+#ifndef CONFIG_DRM_RCAR_HDMI
 	hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
+#endif
 
 	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
 		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
@@ -1028,6 +1042,9 @@ static int hdmi_phy_configure(struct dw_hdmi *hdmi, unsigned char prep,
 	const struct dw_hdmi_mpll_config *mpll_config = plat_data->mpll_cfg;
 	const struct dw_hdmi_curr_ctrl *curr_ctrl = plat_data->cur_ctr;
 	const struct dw_hdmi_phy_config *phy_config = plat_data->phy_config;
+#if CONFIG_DRM_RCAR_HDMI
+	unsigned r_cpce, r_mpll;
+#endif
 
 	if (prep)
 		return -EINVAL;
@@ -1078,7 +1095,51 @@ static int hdmi_phy_configure(struct dw_hdmi *hdmi, unsigned char prep,
 		    mpll_config[i].mpixelclock)
 			break;
 
+#if CONFIG_DRM_RCAR_HDMI
+	if ((hdmi->previous_mode.clock > 0) &&
+		(hdmi->previous_mode.clock <= 44900))
+		r_cpce = 0x03;
+	else if (hdmi->previous_mode.clock <= 90000)
+		r_cpce = 0x02;
+	else if (hdmi->previous_mode.clock <= 182750)
+		r_cpce = 0x01;
+	else if (hdmi->previous_mode.clock <= 297000)
+		r_cpce = 0x00;
+	else
+		return -EINVAL;
+
+	if ((hdmi->previous_mode.clock > 0) &&
+		 (hdmi->previous_mode.clock <= 44900))
+		r_mpll = 0x48;
+	else if (hdmi->previous_mode.clock <= 90000)
+		r_mpll = 0x14;
+	else if (hdmi->previous_mode.clock <= 180000)
+		r_mpll = 0x0A;
+	else if (hdmi->previous_mode.clock <= 297000)
+		r_mpll = 0x05;
+	else
+		return -EINVAL;
+
+	if ((hdmi->previous_mode.clock > 0) &&
+		(hdmi->previous_mode.clock <= 72500))
+		r_mpll |= 0x03 << 8;
+	else if (hdmi->previous_mode.clock <= 90000)
+		r_mpll |= 0x01 << 8;
+	else if (hdmi->previous_mode.clock <= 140250)
+		r_mpll |= 0x03 << 8;
+	else if (hdmi->previous_mode.clock <= 182750)
+		r_mpll |= 0x01 << 8;
+	else if (hdmi->previous_mode.clock <= 281250)
+		r_mpll |= 0x03 << 8;
+	else if (hdmi->previous_mode.clock <= 297000)
+		r_mpll |= 0x01 << 8;
+	else
+		return -EINVAL;
+
+	hdmi_phy_i2c_write(hdmi, r_cpce, 0x06);
+#else
 	hdmi_phy_i2c_write(hdmi, mpll_config[i].res[res_idx].cpce, 0x06);
+#endif
 	hdmi_phy_i2c_write(hdmi, mpll_config[i].res[res_idx].gmp, 0x15);
 
 	for (i = 0; curr_ctrl[i].mpixelclock != (~0UL); i++)
@@ -1095,6 +1156,9 @@ static int hdmi_phy_configure(struct dw_hdmi *hdmi, unsigned char prep,
 	/* CURRCTRL */
 	hdmi_phy_i2c_write(hdmi, curr_ctrl[i].curr[res_idx], 0x10);
 
+#if CONFIG_DRM_RCAR_HDMI
+	hdmi_phy_i2c_write(hdmi, r_mpll, 0x11);
+#endif
 	hdmi_phy_i2c_write(hdmi, 0x0000, 0x13);  /* PLLPHBYCTRL */
 	hdmi_phy_i2c_write(hdmi, 0x0006, 0x17);
 
@@ -1593,7 +1657,9 @@ static void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)
 	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);
 	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);
 	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);
+#ifndef CONFIG_DRM_RCAR_HDMI
 	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+#endif
 
 	/* Enable top level interrupt bits in HDMI block */
 	ih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
@@ -1718,6 +1784,11 @@ static struct drm_connector_funcs dw_hdmi_connector_funcs = {
 	.fill_modes = drm_helper_probe_single_connector_modes,
 	.detect = dw_hdmi_connector_detect,
 	.destroy = dw_hdmi_connector_destroy,
+#ifdef CONFIG_DRM_RCAR_HDMI
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+#endif
 };
 
 static struct drm_connector_helper_funcs dw_hdmi_connector_helper_funcs = {
@@ -1836,13 +1907,23 @@ static int dw_hdmi_register(struct drm_device *drm, struct dw_hdmi *hdmi)
 	encoder->bridge = bridge;
 	hdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;
 
+#ifdef CONFIG_DRM_RCAR_HDMI
+	hdmi->connector.interlace_allowed = true;
+#endif
 	drm_connector_helper_add(&hdmi->connector,
 				 &dw_hdmi_connector_helper_funcs);
 	drm_connector_init(drm, &hdmi->connector, &dw_hdmi_connector_funcs,
 			   DRM_MODE_CONNECTOR_HDMIA);
 
+#ifndef CONFIG_DRM_RCAR_HDMI
 	hdmi->connector.encoder = encoder;
+#endif
 
+#ifdef CONFIG_DRM_RCAR_HDMI
+	ret = drm_connector_register(&hdmi->connector);
+	if (ret < 0)
+		return ret;
+#endif
 	drm_mode_connector_attach_encoder(&hdmi->connector, encoder);
 
 	return 0;
@@ -1859,6 +1940,10 @@ int dw_hdmi_bind(struct device *dev, struct device *master,
 	struct dw_hdmi *hdmi;
 	int ret;
 	u32 val = 1;
+#ifdef CONFIG_DRM_RCAR_HDMI
+	char name[7];
+	void __iomem *cpg_reg;
+#endif
 
 	hdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);
 	if (!hdmi)
@@ -1906,19 +1991,35 @@ int dw_hdmi_bind(struct device *dev, struct device *master,
 	if (IS_ERR(hdmi->regs))
 		return PTR_ERR(hdmi->regs);
 
+#ifdef CONFIG_DRM_RCAR_HDMI
+	sprintf(name, "hdmi.%u", hdmi->plat_data->index);
+	hdmi->isfr_clk = devm_clk_get(hdmi->dev, name);
+#else
 	hdmi->isfr_clk = devm_clk_get(hdmi->dev, "isfr");
+#endif
 	if (IS_ERR(hdmi->isfr_clk)) {
 		ret = PTR_ERR(hdmi->isfr_clk);
+#ifdef CONFIG_DRM_RCAR_HDMI
+		dev_err(hdmi->dev, "Unable to get HDMI%d clk: %d\n",
+					hdmi->plat_data->index, ret);
+#else
 		dev_err(hdmi->dev, "Unable to get HDMI isfr clk: %d\n", ret);
+#endif
 		return ret;
 	}
 
+#ifdef CONFIG_DRM_RCAR_HDMI
+	/* Set HDMICKCR */
+	cpg_reg = ioremap_nocache(0xe6150250, 0x04);
+	writel(readl(cpg_reg) & 0xFFFFFEFF, cpg_reg);
+#endif
 	ret = clk_prepare_enable(hdmi->isfr_clk);
 	if (ret) {
 		dev_err(hdmi->dev, "Cannot enable HDMI isfr clock: %d\n", ret);
 		return ret;
 	}
 
+#ifndef CONFIG_DRM_RCAR_HDMI
 	hdmi->iahb_clk = devm_clk_get(hdmi->dev, "iahb");
 	if (IS_ERR(hdmi->iahb_clk)) {
 		ret = PTR_ERR(hdmi->iahb_clk);
@@ -1931,6 +2032,7 @@ int dw_hdmi_bind(struct device *dev, struct device *master,
 		dev_err(hdmi->dev, "Cannot enable HDMI iahb clock: %d\n", ret);
 		goto err_isfr;
 	}
+#endif
 
 	/* Product and revision IDs */
 	dev_info(dev,
@@ -1993,8 +2095,10 @@ err_iahb:
 	if (hdmi->i2c)
 		i2c_del_adapter(&hdmi->i2c->adap);
 
+#ifndef CONFIG_DRM_RCAR_HDMI
 	clk_disable_unprepare(hdmi->iahb_clk);
 err_isfr:
+#endif
 	clk_disable_unprepare(hdmi->isfr_clk);
 
 	return ret;
@@ -2011,7 +2115,9 @@ void dw_hdmi_unbind(struct device *dev, struct device *master, void *data)
 	hdmi->connector.funcs->destroy(&hdmi->connector);
 	hdmi->encoder->funcs->destroy(hdmi->encoder);
 
+#ifndef CONFIG_DRM_RCAR_HDMI
 	clk_disable_unprepare(hdmi->iahb_clk);
+#endif
 	clk_disable_unprepare(hdmi->isfr_clk);
 
 	if (hdmi->i2c)
diff --git a/drivers/gpu/drm/rcar-du/Kconfig b/drivers/gpu/drm/rcar-du/Kconfig
index 62650ab..04e5335a 100644
--- a/drivers/gpu/drm/rcar-du/Kconfig
+++ b/drivers/gpu/drm/rcar-du/Kconfig
@@ -15,6 +15,7 @@ config DRM_RCAR_HDMI
 	bool "R-Car DU HDMI Encoder Support"
 	depends on DRM_RCAR_DU
 	depends on OF
+	select DRM_DW_HDMI if ARCH_RCAR_GEN3
 	help
 	  Enable support for external HDMI encoders.
 
diff --git a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
index de13bfc..87a2c71 100644
--- a/include/drm/bridge/dw_hdmi.h
+++ b/include/drm/bridge/dw_hdmi.h
@@ -1,4 +1,5 @@
 /*
+ * Copyright (C) 2015 Renesas Electronics Corporation
  * Copyright (C) 2011 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -52,6 +53,9 @@ struct dw_hdmi_plat_data {
 	const struct dw_hdmi_phy_config *phy_config;
 	enum drm_mode_status (*mode_valid)(struct drm_connector *connector,
 					   struct drm_display_mode *mode);
+#ifdef CONFIG_DRM_RCAR_HDMI
+	enum dw_hdmi_devtype index;
+#endif
 };
 
 void dw_hdmi_unbind(struct device *dev, struct device *master, void *data);
-- 
1.7.9.5

