From 0c86796f3fbaa8498922b5de8f6d0101fdd6b99f Mon Sep 17 00:00:00 2001
From: Hiromasa Kitaki <hiromasa.kitaki.fz@bp.renesas.com>
Date: Fri, 20 May 2016 11:04:52 +0900
Subject: [PATCH 1/3] add bl2 bl31 R-Car support

---
 Makefile                                        |   19 +-
 bl2/bl2.ld.S                                    |   12 +
 bl31/aarch64/bl31_entrypoint.S                  |   11 +
 bl31/bl31.ld.S                                  |    5 +
 common/tf_printf.c                              |    8 +
 plat/renesas/rcar/aarch64/bl2_reset.S           |  426 +++++++
 plat/renesas/rcar/aarch64/rcar_common.c         |  263 ++++
 plat/renesas/rcar/aarch64/rcar_helpers.S        |  443 +++++++
 plat/renesas/rcar/bl2_cpg_init.c                |  142 +++
 plat/renesas/rcar/bl2_rcar_setup.c              |  630 +++++++++
 plat/renesas/rcar/bl2_secure_setting.c          |  468 +++++++
 plat/renesas/rcar/bl31_rcar_setup.c             |  257 ++++
 plat/renesas/rcar/drivers/auth/rcarboot.c       |  245 ++++
 plat/renesas/rcar/drivers/auth/rcarboot.h       |   41 +
 plat/renesas/rcar/drivers/avs/avs_driver.c      |  654 ++++++++++
 plat/renesas/rcar/drivers/dma/dma_driver.c      |  194 +++
 plat/renesas/rcar/drivers/error/bl2_int_error.c |  102 ++
 plat/renesas/rcar/drivers/io/io_memdrv.c        |  236 ++++
 plat/renesas/rcar/drivers/io/io_rcar.c          |  620 +++++++++
 plat/renesas/rcar/drivers/memdrv/rcar_console.S |   98 ++
 plat/renesas/rcar/drivers/memdrv/rcar_printf.c  |  169 +++
 plat/renesas/rcar/drivers/memdrv/rcar_printf.h  |   43 +
 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c      |  291 +++++
 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h      |   80 ++
 plat/renesas/rcar/drivers/rpc/rpc_driver.c      |   84 ++
 plat/renesas/rcar/drivers/scif/scif.S           |  313 +++++
 plat/renesas/rcar/drivers/timer/bl2_swdt.c      |  171 +++
 plat/renesas/rcar/include/avs_driver.h          |   44 +
 plat/renesas/rcar/include/bl2_axi_register.h    |  272 ++++
 plat/renesas/rcar/include/bl2_cpg_init.h        |   38 +
 plat/renesas/rcar/include/bl2_cpg_register.h    |  135 ++
 plat/renesas/rcar/include/bl2_dma_register.h    |   67 +
 plat/renesas/rcar/include/bl2_int_error.h       |   41 +
 plat/renesas/rcar/include/bl2_lifec_register.h  |  305 +++++
 plat/renesas/rcar/include/bl2_rpc_register.h    |   68 +
 plat/renesas/rcar/include/bl2_secure_setting.h  |   37 +
 plat/renesas/rcar/include/bl2_swdt.h            |   43 +
 plat/renesas/rcar/include/dma_driver.h          |   49 +
 plat/renesas/rcar/include/io_common.h           |   41 +
 plat/renesas/rcar/include/io_memdrv.h           |   39 +
 plat/renesas/rcar/include/io_rcar.h             |   39 +
 plat/renesas/rcar/include/pfc_init.h            |   37 +
 plat/renesas/rcar/include/plat_macros.S         |  105 ++
 plat/renesas/rcar/include/platform.h            |  199 +++
 plat/renesas/rcar/include/platform_def.h        |  220 ++++
 plat/renesas/rcar/include/rpc_driver.h          |   46 +
 plat/renesas/rcar/include/scif.h                |   47 +
 plat/renesas/rcar/pfc/H3/pfc_init_h3.c          | 1352 ++++++++++++++++++++
 plat/renesas/rcar/pfc/H3/pfc_init_h3.h          |   37 +
 plat/renesas/rcar/pfc/M3/pfc_init_m3.c          | 1562 +++++++++++++++++++++++
 plat/renesas/rcar/pfc/M3/pfc_init_m3.h          |   37 +
 plat/renesas/rcar/pfc/pfc.mk                    |   39 +
 plat/renesas/rcar/pfc/pfc_init.c                |   49 +
 plat/renesas/rcar/platform.mk                   |  170 +++
 plat/renesas/rcar/rcar_def.h                    |  267 ++++
 plat/renesas/rcar/rcar_io_storage.c             |  442 +++++++
 plat/renesas/rcar/rcar_pm.c                     |  427 +++++++
 plat/renesas/rcar/rcar_private.h                |  172 +++
 plat/renesas/rcar/rcar_topology.c               |  223 ++++
 plat/renesas/rcar/rcar_version.h                |   41 +
 services/spd/opteed/opteed_main.c               |    3 +-
 tools/dummy_create/makefile                     |  103 ++
 tools/dummy_create/sa0.c                        |   39 +
 tools/dummy_create/sa0.ld.S                     |   42 +
 tools/dummy_create/sa6.c                        |   51 +
 tools/dummy_create/sa6.ld.S                     |   52 +
 66 files changed, 13003 insertions(+), 2 deletions(-)
 create mode 100644 plat/renesas/rcar/aarch64/bl2_reset.S
 create mode 100644 plat/renesas/rcar/aarch64/rcar_common.c
 create mode 100644 plat/renesas/rcar/aarch64/rcar_helpers.S
 create mode 100644 plat/renesas/rcar/bl2_cpg_init.c
 create mode 100755 plat/renesas/rcar/bl2_rcar_setup.c
 create mode 100644 plat/renesas/rcar/bl2_secure_setting.c
 create mode 100644 plat/renesas/rcar/bl31_rcar_setup.c
 create mode 100644 plat/renesas/rcar/drivers/auth/rcarboot.c
 create mode 100644 plat/renesas/rcar/drivers/auth/rcarboot.h
 create mode 100644 plat/renesas/rcar/drivers/avs/avs_driver.c
 create mode 100644 plat/renesas/rcar/drivers/dma/dma_driver.c
 create mode 100644 plat/renesas/rcar/drivers/error/bl2_int_error.c
 create mode 100644 plat/renesas/rcar/drivers/io/io_memdrv.c
 create mode 100644 plat/renesas/rcar/drivers/io/io_rcar.c
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_console.S
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_printf.c
 create mode 100644 plat/renesas/rcar/drivers/memdrv/rcar_printf.h
 create mode 100644 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
 create mode 100644 plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
 create mode 100644 plat/renesas/rcar/drivers/rpc/rpc_driver.c
 create mode 100644 plat/renesas/rcar/drivers/scif/scif.S
 create mode 100644 plat/renesas/rcar/drivers/timer/bl2_swdt.c
 create mode 100644 plat/renesas/rcar/include/avs_driver.h
 create mode 100644 plat/renesas/rcar/include/bl2_axi_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_cpg_init.h
 create mode 100644 plat/renesas/rcar/include/bl2_cpg_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_dma_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_int_error.h
 create mode 100644 plat/renesas/rcar/include/bl2_lifec_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_rpc_register.h
 create mode 100644 plat/renesas/rcar/include/bl2_secure_setting.h
 create mode 100644 plat/renesas/rcar/include/bl2_swdt.h
 create mode 100644 plat/renesas/rcar/include/dma_driver.h
 create mode 100644 plat/renesas/rcar/include/io_common.h
 create mode 100644 plat/renesas/rcar/include/io_memdrv.h
 create mode 100644 plat/renesas/rcar/include/io_rcar.h
 create mode 100644 plat/renesas/rcar/include/pfc_init.h
 create mode 100644 plat/renesas/rcar/include/plat_macros.S
 create mode 100644 plat/renesas/rcar/include/platform.h
 create mode 100644 plat/renesas/rcar/include/platform_def.h
 create mode 100644 plat/renesas/rcar/include/rpc_driver.h
 create mode 100644 plat/renesas/rcar/include/scif.h
 create mode 100644 plat/renesas/rcar/pfc/H3/pfc_init_h3.c
 create mode 100644 plat/renesas/rcar/pfc/H3/pfc_init_h3.h
 create mode 100644 plat/renesas/rcar/pfc/M3/pfc_init_m3.c
 create mode 100644 plat/renesas/rcar/pfc/M3/pfc_init_m3.h
 create mode 100644 plat/renesas/rcar/pfc/pfc.mk
 create mode 100644 plat/renesas/rcar/pfc/pfc_init.c
 create mode 100644 plat/renesas/rcar/platform.mk
 create mode 100644 plat/renesas/rcar/rcar_def.h
 create mode 100644 plat/renesas/rcar/rcar_io_storage.c
 create mode 100644 plat/renesas/rcar/rcar_pm.c
 create mode 100644 plat/renesas/rcar/rcar_private.h
 create mode 100644 plat/renesas/rcar/rcar_topology.c
 create mode 100644 plat/renesas/rcar/rcar_version.h
 create mode 100644 tools/dummy_create/makefile
 create mode 100644 tools/dummy_create/sa0.c
 create mode 100644 tools/dummy_create/sa0.ld.S
 create mode 100644 tools/dummy_create/sa6.c
 create mode 100644 tools/dummy_create/sa6.ld.S

diff --git a/Makefile b/Makefile
index 050a76e..dcfcc54 100644
--- a/Makefile
+++ b/Makefile
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 2013-2015, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
@@ -343,6 +344,11 @@ CRTTOOLPATH		?=	tools/cert_create
 CRTTOOL			?=	${CRTTOOLPATH}/cert_create
 certtool:		${CRTTOOL}
 
+# Dummy Image Create
+DUMMYTOOLPATH		?=	tools/dummy_create
+DUMMYTOOL		?=	${DUMMYTOOLPATH}/dummy_create
+dummytool:		${DUMMYTOOL}
+
 # CoT generation tool default parameters
 TRUSTED_KEY_CERT	:=	${BUILD_PLAT}/trusted_key.crt
 
@@ -386,6 +392,7 @@ clean:
 			${Q}rm -rf ${BUILD_PLAT}
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
 			${Q}${MAKE} PLAT=${PLAT} --no-print-directory -C ${CRTTOOLPATH} clean
+			${Q}${MAKE} -C ${DUMMYTOOLPATH} clean
 
 realclean distclean:
 			@echo "  REALCLEAN"
@@ -393,6 +400,7 @@ realclean distclean:
 			${Q}rm -f ${CURDIR}/cscope.*
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH} clean
 			${Q}${MAKE} PLAT=${PLAT} --no-print-directory -C ${CRTTOOLPATH} clean
+			${Q}${MAKE} -C ${DUMMYTOOLPATH} clean
 
 checkcodebase:		locate-checkpatch
 			@echo "  CHECKING STYLE"
@@ -417,6 +425,10 @@ ${CRTTOOL}:
 ${FIPTOOL}:
 			${Q}${MAKE} --no-print-directory -C ${FIPTOOLPATH}
 
+.PHONY: ${DUMMYTOOL}
+${DUMMYTOOL}:
+			${Q}${MAKE} -C ${DUMMYTOOLPATH}
+
 define match_goals
 $(strip $(foreach goal,$(1),$(filter $(goal),$(MAKECMDGOALS))))
 endef
@@ -554,6 +566,7 @@ define MAKE_BL
 	$(eval ELF        := $(BUILD_DIR)/bl$(1).elf)
 	$(eval DUMP       := $(BUILD_DIR)/bl$(1).dump)
 	$(eval BIN        := $(BUILD_PLAT)/bl$(1).bin)
+	$(eval SREC       := $(BUILD_PLAT)/bl$(1).srec)
 
 	$(eval $(call MAKE_OBJS,$(BUILD_DIR),$(SOURCES),$(1)))
 	$(eval $(call MAKE_LD,$(LINKERFILE),$(BL$(1)_LINKERFILE)))
@@ -580,8 +593,12 @@ $(BIN) : $(ELF)
 	@echo "Built $$@ successfully"
 	@echo
 
+$(SREC) : $(ELF)
+	@echo "  SREC    $$@"
+	$$(Q)$$(OC) -O srec $$< $$@
+
 .PHONY : bl$(1)
-bl$(1) : $(BUILD_DIR) $(BIN) $(DUMP)
+bl$(1) : $(BUILD_DIR) $(SREC) $(BIN) $(DUMP)
 
 all : bl$(1)
 
diff --git a/bl2/bl2.ld.S b/bl2/bl2.ld.S
index a660bda..ed99a3d 100644
--- a/bl2/bl2.ld.S
+++ b/bl2/bl2.ld.S
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -32,7 +33,11 @@
 
 OUTPUT_FORMAT(PLATFORM_LINKER_FORMAT)
 OUTPUT_ARCH(PLATFORM_LINKER_ARCH)
+#if PLAT_rcar
+ENTRY(bl2_reset)
+#else
 ENTRY(bl2_entrypoint)
+#endif
 
 MEMORY {
     RAM (rwx): ORIGIN = BL2_BASE, LENGTH = BL2_LIMIT - BL2_BASE
@@ -47,7 +52,14 @@ SECTIONS
 
     ro . : {
         __RO_START__ = .;
+#if PLAT_rcar
+        *bl2_reset.o(.text*)
+#endif
         *bl2_entrypoint.o(.text*)
+#if PLAT_rcar
+        . = NEXT(ALIGN_VERSION);
+	*rcar_common.o(.version*)
+#endif
         *(.text*)
         *(.rodata*)
 
diff --git a/bl31/aarch64/bl31_entrypoint.S b/bl31/aarch64/bl31_entrypoint.S
index 636b1d2..eee0cad 100644
--- a/bl31/aarch64/bl31_entrypoint.S
+++ b/bl31/aarch64/bl31_entrypoint.S
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -61,6 +62,15 @@ func bl31_entrypoint
 	 * endianness and has initialised the memory.
 	 * ---------------------------------------------------------------------
 	 */
+#if PLAT_rcar
+	el3_entrypoint_common					\
+		_set_endian=0					\
+		_warm_boot_mailbox=1				\
+		_secondary_cold_boot=1				\
+		_init_memory=1					\
+		_init_c_runtime=1				\
+		_exception_vectors=runtime_exceptions
+#else
 	el3_entrypoint_common					\
 		_set_endian=0					\
 		_warm_boot_mailbox=0				\
@@ -68,6 +78,7 @@ func bl31_entrypoint
 		_init_memory=0					\
 		_init_c_runtime=1				\
 		_exception_vectors=runtime_exceptions
+#endif
 
 	/* ---------------------------------------------------------------------
 	 * Relay the previous bootloader's arguments to the platform layer
diff --git a/bl31/bl31.ld.S b/bl31/bl31.ld.S
index e572f9b..47084fc 100644
--- a/bl31/bl31.ld.S
+++ b/bl31/bl31.ld.S
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -49,6 +50,10 @@ SECTIONS
     ro . : {
         __RO_START__ = .;
         *bl31_entrypoint.o(.text*)
+#if PLAT_rcar
+        . = NEXT(ALIGN_VERSION);
+        *rcar_common.o(.version*)
+#endif
         *(.text*)
         *(.rodata*)
 
diff --git a/common/tf_printf.c b/common/tf_printf.c
index c68b990..45b756f 100644
--- a/common/tf_printf.c
+++ b/common/tf_printf.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -31,6 +32,9 @@
 #include <stdarg.h>
 #include <stdint.h>
 
+#if (IMAGE_BL31 && PLAT_rcar)
+extern void	rcar_set_log_time(void);
+#endif
 /***********************************************************
  * The tf_printf implementation for all BL stages
  ***********************************************************/
@@ -79,6 +83,10 @@ void tf_printf(const char *fmt, ...)
 	uint64_t unum;
 	char *str;
 
+#if (IMAGE_BL31 && PLAT_rcar)
+	rcar_set_log_time();
+#endif
+
 	va_start(args, fmt);
 	while (*fmt) {
 		bit64 = 0;
diff --git a/plat/renesas/rcar/aarch64/bl2_reset.S b/plat/renesas/rcar/aarch64/bl2_reset.S
new file mode 100644
index 0000000..001ca94
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/bl2_reset.S
@@ -0,0 +1,426 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <bl_common.h>
+#include <runtime_svc.h>
+#include "platform_def.h"
+
+
+#define	RST_BASE		(0xE6160000)
+#define	RST_CA53BAR2		(0x0034)
+#define	RST_CA57BAR2		(0x0024)
+#define	RST_CA53CPU0BARH	(0x0080)
+#define	RST_CA53CPU0BARL	(0x0084)
+#define	RST_CA53CPU1BARH	(0x0090)
+#define	RST_CA53CPU1BARL	(0x0094)
+#define	RST_CA53CPU2BARH	(0x00A0)
+#define	RST_CA53CPU2BARL	(0x00A4)
+#define	RST_CA53CPU3BARH	(0x00B0)
+#define	RST_CA53CPU3BARL	(0x00B4)
+#define	RST_CA57CPU0BARH	(0x00C0)
+#define	RST_CA57CPU0BARL	(0x00C4)
+#define	RST_CA57CPU1BARH	(0x00D0)
+#define	RST_CA57CPU1BARL	(0x00D4)
+#define	RST_CA57CPU2BARH	(0x00E0)
+#define	RST_CA57CPU2BARL	(0x00E4)
+#define	RST_CA57CPU3BARH	(0x00F0)
+#define	RST_CA57CPU3BARL	(0x00F4)
+
+#define	RST_BAR2_MASK		(0xFFFFFC00)
+#define	RST_BAR2_BAREN		(0x00000010)
+#define	RST_BAR2_VLD		(0x00000001)
+#define	RST_BAR2_SHIFT		(18-10)
+#define RST_CPUnBARH_SHIFT	(32)
+#define	RST_CPUnBARH_MASK	(0x000000FF)
+#define	RST_CPUnBARL_MASK	(0xFFFFFFFC)
+
+
+	.global	bl2_reset
+	.global	bl2_secondly_reset
+	.global	bl2_init_secondly_reset
+
+func bl2_reset
+    mov x0,  #0
+    mov x1,  #0
+    mov x2,  #0
+    mov x3,  #0
+    mov x4,  #0
+    mov x5,  #0
+    mov x6,  #0
+    mov x7,  #0
+    mov x8,  #0
+    mov x9,  #0
+    mov x10, #0
+    mov x11, #0
+    mov x12, #0
+    mov x13, #0
+    mov x14, #0
+    mov x15, #0
+    mov x16, #0
+    mov x17, #0
+    mov x18, #0
+    mov x19, #0
+    mov x20, #0
+    mov x21, #0
+    mov x22, #0
+    mov x23, #0
+    mov x24, #0
+    mov x25, #0
+    mov x26, #0
+    mov x27, #0
+    mov x28, #0
+    mov x29, #0
+    mov x30, #0
+
+	/* ---------------------------------------------
+	 * Set the CPU endianness before doing anything
+	 * that might involve memory reads or writes.
+	 * ---------------------------------------------
+	 */
+	mrs	x0, sctlr_el3
+	bic	x0, x0, #SCTLR_EE_BIT
+	msr	sctlr_el3, x0
+	isb
+
+	/* ---------------------------------------------
+	 * Set the exception vector to something sane.
+	 * ---------------------------------------------
+	 */
+	adr	x0, bl2_exceptions
+	msr	vbar_el3, x0
+	isb
+
+	/* ---------------------------------------------------------------------
+	 * The initial state of the Architectural feature trap register
+	 * (CPTR_EL3) is unknown and it must be set to a known state. All
+	 * feature traps are disabled. Some bits in this register are marked as
+	 * Reserved and should not be modified.
+	 *
+	 * CPTR_EL3.TCPAC: This causes a direct access to the CPACR_EL1 from EL1
+	 *  or the CPTR_EL2 from EL2 to trap to EL3 unless it is trapped at EL2.
+	 * CPTR_EL3.TTA: This causes access to the Trace functionality to trap
+	 *  to EL3 when executed from EL0, EL1, EL2, or EL3. If system register
+	 *  access to trace functionality is not supported, this bit is RES0.
+	 * CPTR_EL3.TFP: This causes instructions that access the registers
+	 *  associated with Floating Point and Advanced SIMD execution to trap
+	 *  to EL3 when executed from any exception level, unless trapped to EL1
+	 *  or EL2.
+	 * ---------------------------------------------------------------------
+	 */
+	mrs	x0, cptr_el3
+	bic	w0, w0, #TCPAC_BIT
+	bic	w0, w0, #TTA_BIT
+	bic	w0, w0, #TFP_BIT
+	msr	cptr_el3, x0
+
+	/* --------------------------------------------
+	 * Allocate a stack whose memory will be marked
+	 * as Normal-IS-WBWA when the MMU is enabled.
+	 * There is no risk of reading stale stack
+	 * memory after enabling the MMU as only the
+	 * primary cpu is running at the moment.
+	 * --------------------------------------------
+	 */
+	mrs	x0, mpidr_el1
+	bl	platform_set_stack
+
+	mov	x0, #(SCR_RES1_BITS | SCR_RW_BIT)
+	msr	scr_el3, x0
+
+	bl	bl2_init_secondly_reset
+
+	ldr	x0, =bl2_entrypoint
+	msr	elr_el3, x0
+	mov	x1, #(DISABLE_ALL_EXCEPTIONS << SPSR_DAIF_SHIFT) | (MODE_RW_64 << MODE_RW_SHIFT) | (MODE_EL1 << MODE_EL_SHIFT) | (MODE_SP_ELX << MODE_SP_SHIFT)
+	msr	spsr_el3, x1
+
+	adr	x1, BL2_MEM_INFO
+	mov	x0, #RUN_IMAGE
+
+	eret
+endfunc bl2_reset
+
+
+	.align	3
+BL2_MEM_INFO:					/* meminfo_t */
+	.quad	BL31_BASE			/* total_base */
+	.quad	(BL31_LIMIT - BL31_BASE)	/* total_size */
+	.quad	BL31_BASE			/* free_base */
+	.quad	(BL31_LIMIT - BL31_BASE)	/* free_size */
+
+
+	/* ---------------------------------------------
+	 * initialize secondly boot
+	 * ---------------------------------------------
+	 */
+func bl2_init_secondly_reset
+	adr	x0, bl2_secondly_reset
+	ldr	x1, =RCAR_SECRAM_BASE
+	mov	x2, #0				/* Number of copied bytes */
+	mov	x4, #(BL2_SECONDLY_RESET - bl2_secondly_reset)
+1:
+	ldr	w3, [x0, x2]
+	str	w3, [x1, x2]			/* copy secondly boot code */
+	add	x2, x2, #4
+	cmp	x4, x2
+	b.gt	1b
+
+	/* initialize Boot Address Registers */
+	ldr	x0, =RST_BASE
+
+	ldr	w1, =(RCAR_SECRAM_BASE & RST_CPUnBARL_MASK)
+	str	w1, [x0, #RST_CA53CPU0BARL]
+	str	wzr, [x0, #RST_CA53CPU0BARH]
+	str	w1, [x0, #RST_CA53CPU1BARL]
+	str	wzr, [x0, #RST_CA53CPU1BARH]
+	str	w1, [x0, #RST_CA53CPU2BARL]
+	str	wzr, [x0, #RST_CA53CPU2BARH]
+	str	w1, [x0, #RST_CA53CPU3BARL]
+	str	wzr, [x0, #RST_CA53CPU3BARH]
+	str	w1, [x0, #RST_CA57CPU0BARL]
+	str	wzr, [x0, #RST_CA57CPU0BARH]
+	str	w1, [x0, #RST_CA57CPU1BARL]
+	str	wzr, [x0, #RST_CA57CPU1BARH]
+	str	w1, [x0, #RST_CA57CPU2BARL]
+	str	wzr, [x0, #RST_CA57CPU2BARH]
+	str	w1, [x0, #RST_CA57CPU3BARL]
+	str	wzr, [x0, #RST_CA57CPU3BARH]
+
+	ret
+endfunc bl2_init_secondly_reset
+
+
+	/* ---------------------------------------------
+	 * secondly boot
+	 * ---------------------------------------------
+	 */
+func bl2_secondly_reset
+	mrs	x0, sctlr_el3
+	bic	x0, x0, #SCTLR_EE_BIT
+	msr	sctlr_el3, x0
+	isb
+
+	mrs	x0, cptr_el3
+	bic	w0, w0, #TCPAC_BIT
+	bic	w0, w0, #TTA_BIT
+	bic	w0, w0, #TFP_BIT
+	msr	cptr_el3, x0
+
+	mov_imm	x0, PARAMS_BASE			/* pointer to bl31_ep_info */
+	mov_imm	x2, BL31_BASE
+	mov x1, #0x00000001			/* warm boot */
+	br	x2				/* jump to BL31 */
+	nop
+	nop
+	nop
+BL2_SECONDLY_RESET:
+endfunc bl2_secondly_reset
+
+
+
+	.section	.vectors, "ax"; .align 11
+
+	/* -----------------------------------------------------
+	 * Very simple stackless exception handlers used by BL1.
+	 * -----------------------------------------------------
+	 */
+	.align	7
+bl2_exceptions:
+	/* -----------------------------------------------------
+	 * Current EL with SP0 : 0x0 - 0x200
+	 * -----------------------------------------------------
+	 */
+SynchronousExceptionSP0:
+	mov	x0, #SYNC_EXCEPTION_SP_EL0
+	bl	plat_report_exception
+	b	SynchronousExceptionSP0
+	check_vector_size SynchronousExceptionSP0
+
+	.align	7
+IrqSP0:
+	mov	x0, #IRQ_SP_EL0
+	bl	plat_report_exception
+	b	IrqSP0
+	check_vector_size IrqSP0
+
+	.align	7
+FiqSP0:
+	mov	x0, #FIQ_SP_EL0
+	bl	plat_report_exception
+	b	FiqSP0
+	check_vector_size FiqSP0
+
+	.align	7
+SErrorSP0:
+	mov	x0, #SERROR_SP_EL0
+	bl	plat_report_exception
+	b	SErrorSP0
+	check_vector_size SErrorSP0
+
+	/* -----------------------------------------------------
+	 * Current EL with SPx: 0x200 - 0x400
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionSPx:
+	mov	x0, #SYNC_EXCEPTION_SP_ELX
+	bl	plat_report_exception
+	b	SynchronousExceptionSPx
+	check_vector_size SynchronousExceptionSPx
+
+	.align	7
+IrqSPx:
+	mov	x0, #IRQ_SP_ELX
+	bl	plat_report_exception
+	b	IrqSPx
+	check_vector_size IrqSPx
+
+	.align	7
+FiqSPx:
+	mov	x0, #FIQ_SP_ELX
+	bl	plat_report_exception
+	b	FiqSPx
+	check_vector_size FiqSPx
+
+	.align	7
+SErrorSPx:
+	mov	x0, #SERROR_SP_ELX
+	bl	plat_report_exception
+	b	SErrorSPx
+	check_vector_size SErrorSPx
+
+	/* -----------------------------------------------------
+	 * Lower EL using AArch64 : 0x400 - 0x600
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionA64:
+	/* Enable the SError interrupt */
+	msr	daifclr, #DAIF_ABT_BIT
+
+	/* ------------------------------------------------
+	 * Only a single SMC exception from BL2 to ask
+	 * BL1 to pass EL3 control to BL31 is expected
+	 * here.
+	 * It expects X0 with RUN_IMAGE SMC function id
+	 * X1 with address of a entry_point_info_t structure
+	 * describing the BL3-1 entrypoint
+	 * ------------------------------------------------
+	 */
+	mov	x19, x0
+	mov	x20, x1
+
+	mrs	x0, esr_el3
+	ubfx	x1, x0, #ESR_EC_SHIFT, #ESR_EC_LENGTH
+	cmp	x1, #EC_AARCH64_SMC
+	b.ne	panic
+
+	mov	x0, #RUN_IMAGE
+	cmp	x19, x0
+	b.ne	panic
+
+	mov	x0, x20
+	ldp	x0, x1, [x20, #ENTRY_POINT_INFO_PC_OFFSET]
+	msr	elr_el3, x0
+	msr	spsr_el3, x1
+	ubfx	x0, x1, #MODE_EL_SHIFT, #2
+	cmp	x0, #MODE_EL3
+	b.ne	panic
+
+	ldp	x6, x7, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x30)]
+	ldp	x4, x5, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x20)]
+	ldp	x2, x3, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x10)]
+	ldp	x0, x1, [x20, #(ENTRY_POINT_INFO_ARGS_OFFSET + 0x0)]
+	eret
+
+panic:
+	mov	x0, #SYNC_EXCEPTION_AARCH64
+	bl	plat_report_exception
+
+	wfi
+	b	panic
+	check_vector_size SynchronousExceptionA64
+
+
+	.align	7
+IrqA64:
+	mov	x0, #IRQ_AARCH64
+	bl	plat_report_exception
+	b	IrqA64
+	check_vector_size IrqA64
+
+	.align	7
+FiqA64:
+	mov	x0, #FIQ_AARCH64
+	bl	plat_report_exception
+	b	FiqA64
+	check_vector_size FiqA64
+
+	.align	7
+SErrorA64:
+	mov	x0, #SERROR_AARCH64
+	bl	plat_report_exception
+	b   	SErrorA64
+	check_vector_size SErrorA64
+
+	/* -----------------------------------------------------
+	 * Lower EL using AArch32 : 0x600 - 0x800
+	 * -----------------------------------------------------
+	 */
+	.align	7
+SynchronousExceptionA32:
+	mov	x0, #SYNC_EXCEPTION_AARCH32
+	bl	plat_report_exception
+	b	SynchronousExceptionA32
+	check_vector_size SynchronousExceptionA32
+
+	.align	7
+IrqA32:
+	mov	x0, #IRQ_AARCH32
+	bl	plat_report_exception
+	b	IrqA32
+	check_vector_size IrqA32
+
+	.align	7
+FiqA32:
+	mov	x0, #FIQ_AARCH32
+	bl	plat_report_exception
+	b	FiqA32
+	check_vector_size FiqA32
+
+	.align	7
+SErrorA32:
+	mov	x0, #SERROR_AARCH32
+	bl	plat_report_exception
+	b	SErrorA32
+	check_vector_size SErrorA32
diff --git a/plat/renesas/rcar/aarch64/rcar_common.c b/plat/renesas/rcar/aarch64/rcar_common.c
new file mode 100644
index 0000000..3d86090
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/rcar_common.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <bl_common.h>
+#include <cci.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <xlat_tables.h>
+#include "../rcar_def.h"
+#include "../rcar_private.h"
+#include "../rcar_version.h"
+
+const uint8_t version_of_renesas[] __attribute__((__section__(".version"))) = VERSION_OF_RENESAS;
+
+#define MAP_SHARED_RAM	MAP_REGION_FLAT(RCAR_SHARED_MEM_BASE,		\
+					RCAR_SHARED_MEM_SIZE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+#define MAP_FLASH0	MAP_REGION_FLAT(FLASH0_BASE,			\
+					FLASH0_SIZE,			\
+					MT_MEMORY | MT_RO | MT_SECURE)
+
+#define MAP_DRAM1_NS	MAP_REGION_FLAT(DRAM1_NS_BASE,			\
+					DRAM1_NS_SIZE,			\
+					MT_MEMORY | MT_RW | MT_NS)
+
+#define MAP_BL32_MEM	MAP_REGION_FLAT(BL32_BASE,			\
+					BL32_LIMIT - BL32_BASE,		\
+					MT_MEMORY | MT_RW | MT_SECURE)
+
+#define MAP_DEVICE_RCAR	MAP_REGION_FLAT(DEVICE_RCAR_BASE,		\
+					DEVICE_RCAR_SIZE,		\
+					MT_DEVICE | MT_RW | MT_SECURE)
+
+#define MAP_ATFW_LOG	MAP_REGION_FLAT(RCAR_BL31_LOG_BASE,		\
+					RCAR_BL31_LOG_SIZE,		\
+					MT_DEVICE | MT_RW | MT_SECURE)
+
+/*
+ * Table of regions for various BL stages to map using the MMU.
+ * This doesn't include TZRAM as the 'mem_layout' argument passed to
+ * configure_mmu_elx() will give the available subset of that,
+ */
+#if IMAGE_BL1
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_FLASH0,
+	MAP_DEVICE0,
+	MAP_DEVICE1,
+	{	0}
+};
+#endif
+#if IMAGE_BL2
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_FLASH0,
+	MAP_DRAM1_NS,
+	MAP_BL32_MEM,
+	MAP_DEVICE_RCAR,
+	{	0}
+};
+#endif
+#if IMAGE_BL31
+const mmap_region_t rcar_mmap[] = {
+	MAP_SHARED_RAM,
+	MAP_ATFW_LOG,
+	MAP_DEVICE_RCAR,
+	{	0}
+};
+#endif
+#if IMAGE_BL32
+const mmap_region_t rcar_mmap[] = {
+	MAP_DEVICE0,
+	MAP_DEVICE1,
+	{	0}
+};
+#endif
+
+CASSERT(ARRAY_SIZE(rcar_mmap) + RCAR_BL_REGIONS \
+		<= MAX_MMAP_REGIONS, assert_max_mmap_regions);
+
+/*******************************************************************************
+ * Macro generating the code for the function setting up the pagetables as per
+ * the platform memory map & initialize the mmu, for the given exception level
+ ******************************************************************************/
+#if USE_COHERENT_MEM
+#define DEFINE_CONFIGURE_MMU_EL(_el)				\
+	void rcar_configure_mmu_el##_el(unsigned long total_base,	\
+				   unsigned long total_size,		\
+				   unsigned long ro_start,		\
+				   unsigned long ro_limit,		\
+				   unsigned long coh_start,		\
+				   unsigned long coh_limit)		\
+	{								\
+		mmap_add_region(total_base, total_base,			\
+				total_size,				\
+				MT_MEMORY | MT_RW | MT_SECURE);		\
+		mmap_add_region(ro_start, ro_start,			\
+				ro_limit - ro_start,			\
+				MT_MEMORY | MT_RO | MT_SECURE);		\
+		mmap_add_region(coh_start, coh_start,			\
+				coh_limit - coh_start,			\
+				MT_DEVICE | MT_RW | MT_SECURE);		\
+		mmap_add(rcar_mmap);					\
+		init_xlat_tables();					\
+									\
+		enable_mmu_el##_el(0);					\
+	}
+#else
+#define DEFINE_CONFIGURE_MMU_EL(_el)				\
+	void rcar_configure_mmu_el##_el(unsigned long total_base,	\
+				   unsigned long total_size,		\
+				   unsigned long ro_start,		\
+				   unsigned long ro_limit)		\
+	{								\
+		mmap_add_region(total_base, total_base,			\
+				total_size,				\
+				MT_MEMORY | MT_RW | MT_SECURE);		\
+		mmap_add_region(ro_start, ro_start,			\
+				ro_limit - ro_start,			\
+				MT_MEMORY | MT_RO | MT_SECURE);		\
+		mmap_add(rcar_mmap);					\
+		init_xlat_tables();					\
+									\
+		enable_mmu_el##_el(0);					\
+	}
+#endif
+
+/* Define EL1 and EL3 variants of the function initialising the MMU */
+DEFINE_CONFIGURE_MMU_EL(1)
+DEFINE_CONFIGURE_MMU_EL(3)
+
+#if (IMAGE_BL2)
+extern int32_t file_to_cert(const int32_t filename, uint32_t *cert_addr);
+extern void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr);
+#endif
+
+unsigned long plat_get_ns_image_entrypoint(void)
+{
+#if (IMAGE_BL2)
+	int32_t ret;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	ret = file_to_cert(BL33_CERT_ID, &cert_addr);
+	if (0 == ret) {
+		get_info_from_cert((uint64_t) cert_addr, &l_image_size, &dest_addr);
+	} else {
+		ERROR("%s : cert file load error", __func__);
+		dest_addr = NS_IMAGE_OFFSET;
+	}
+	return dest_addr;
+#else
+	return NS_IMAGE_OFFSET;
+#endif
+}
+
+uint64_t plat_get_syscnt_freq(void)
+{
+	uint64_t counter_base_frequency;
+
+	/* Read the frequency from Frequency modes table */
+	counter_base_frequency = mmio_read_32(ARM_SYS_CNTCTL_BASE + (uint32_t)CNTFID_OFF);
+
+	/* The first entry of the frequency modes table must not be 0 */
+	if (counter_base_frequency == 0U) {
+		panic();
+	}
+
+	return counter_base_frequency;
+}
+
+/* Map of CCI masters with the slave interfaces they are connected */
+static int cci_map[] = {
+	CCI500_CLUSTER0_SL_IFACE_IX,
+	CCI500_CLUSTER1_SL_IFACE_IX
+};
+
+void rcar_cci_init(void)
+{
+	/*
+	 * Initialize CCI-500 driver
+	 */
+	uint32_t product = mmio_read_32((uintptr_t)RCAR_PRR)
+			& RCAR_PRODUCT_MASK;
+	if (RCAR_PRODUCT_M3 == product) {
+		cci_map[0U] = CCI500_CLUSTER0_SL_IFACE_IX_FOR_M3;
+		cci_map[1U] = CCI500_CLUSTER1_SL_IFACE_IX_FOR_M3;
+	}
+	cci_init(RCAR_CCI_BASE, cci_map, ARRAY_SIZE(cci_map));
+}
+
+void rcar_cci_enable(void)
+{
+	cci_enable_snoop_dvm_reqs((unsigned int)MPIDR_AFFLVL1_VAL(read_mpidr()));
+}
+
+void rcar_cci_disable(void)
+{
+	cci_disable_snoop_dvm_reqs((unsigned int)MPIDR_AFFLVL1_VAL(read_mpidr()));
+}
+
+/*******************************************************************************
+ * Gets SPSR for BL32 entry
+ ******************************************************************************/
+uint32_t rcar_get_spsr_for_bl32_entry(void)
+{
+	/*
+	 * The Secure Payload Dispatcher service is responsible for
+	 * setting the SPSR prior to entry into the BL32 image.
+	 */
+	return 0U;
+}
+
+/*******************************************************************************
+ * Gets SPSR for BL33 entry
+ ******************************************************************************/
+#define	BL33_EL1	0
+#define	BL33_EL2	1
+
+uint32_t rcar_get_spsr_for_bl33_entry(void)
+{
+#if (RCAR_BL33_EXECUTION_EL == BL33_EL1)
+	return (uint32_t)SPSR_64(MODE_EL1, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+#elif (RCAR_BL33_EXECUTION_EL == BL33_EL2)
+	return (uint32_t)SPSR_64(MODE_EL2, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+#else
+#error
+#endif
+}
diff --git a/plat/renesas/rcar/aarch64/rcar_helpers.S b/plat/renesas/rcar/aarch64/rcar_helpers.S
new file mode 100644
index 0000000..998c229
--- /dev/null
+++ b/plat/renesas/rcar/aarch64/rcar_helpers.S
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <bl_common.h>
+#include <cortex_a57.h>
+#include <platform_def.h>
+#include <runtime_svc.h>
+#include "../rcar_def.h"
+
+
+	.globl	platform_get_entrypoint
+	.globl	plat_secondary_cold_boot_setup
+	.globl	platform_mem_init
+	.globl	plat_report_exception
+	.globl	platform_is_primary_cpu
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_putc
+	.globl	plat_reset_handler
+	.globl	iciallu
+
+	.extern	platform_set_stack
+	.extern	rcar_log_init
+	.extern	tf_printf
+#if IMAGE_BL2
+	.extern bl2_swdt_exec
+	.extern arm_gic_acknowledge_interrupt
+	.extern bl2_interrupt_error_type
+	.extern bl2_interrupt_error_id
+
+#define	INT_ID_MASK	(0x3ff)
+#endif
+
+	.extern	rcar_boot_kind_flag[data]
+
+.section	.rodata.errorlog,	"aS"
+error_log_data:
+	.asciz	"[Error log is in plat_secondary_cold_setup]",""
+
+	/* -----------------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * This function performs log output from the address of
+	 * error_log_data and go to cb_panic.
+	 * -----------------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+	/*
+	 * If timer is enabled, do not clear the freq register
+	 */
+	mrs	x0, CNTP_CTL_EL0
+	mov	x1, #1
+	and	x2, x0, x1
+	cbnz	x2, log_output		/* timer is enabled			*/
+	/*
+	 * Timer is disabled, then clear the freq register
+	 */
+	mov	x0, #0
+	msr	CNTFRQ_EL0, x0
+log_output:
+	bl	platform_set_stack	/* set stack pointer			*/
+	bl	rcar_log_init		/* log area initialize			*/
+	ldr	x0, =error_log_data	/* argument of tf_printf function	*/
+	bl	tf_printf		/* log output				*/
+cb_panic:
+	b	cb_panic
+endfunc plat_secondary_cold_boot_setup
+
+
+	/* -----------------------------------------------------
+	 * void platform_get_entrypoint (unsigned int mpid);
+	 *
+	 * Main job of this routine is to distinguish between
+	 * a cold and warm boot.
+	 * On a cold boot the secondaries first wait for the
+	 * platform to be initialized after which they are
+	 * hotplugged in. The primary proceeds to perform the
+	 * platform initialization.
+	 * On a warm boot, each cpu jumps to the address in its
+	 * mailbox.
+	 *
+	 * TODO: Not a good idea to save lr in a temp reg
+	 * -----------------------------------------------------
+	 */
+func platform_get_entrypoint
+	mov	x9, x30 /* lr */
+
+	/*
+	 * format of x21
+	 *	4	3	2	1	0
+	 *	---------------------------------
+	 *	|	|	|	|	|
+	 *	|   reset info	|   boot kind	|
+	 *	|	|	|	|	|
+	 *	---------------------------------
+	 *	00 : Usual	| 00 : Cold boot
+	 *	01 : Unusual	| 01 : Warm boot
+	 *	10 : Reserved	| 10 : Reserved
+	 *	11 : Reserved	| 11 : Reserved
+	 *
+	 */
+
+	/*
+	 * Check the reset info
+	 */
+	and	x1, x21, #0x000c	/* Get the reset info				*/
+	cmp	x1, #0x0008		/* Is reset info "10:Reserved" ?		*/
+	beq	el3_panic
+	cmp	x1, #0x000c		/* Is reset info "11:Reserved" ?		*/
+	beq	el3_panic
+	/*										*/
+	/* Check the boot kind								*/
+	/*										*/
+	and	x1, x21, #0x0003	/* Get the boot kind				*/
+	cmp	x1, #0x0002		/* Is boot kind "10:Reserved" ?			*/
+	beq	el3_panic
+	cmp	x1, #0x0003		/* Is boot kind "11:Reserved" ?			*/
+	beq	el3_panic
+	/*										*/
+	/* warm boot or cold boot							*/
+	/*										*/
+	and	x1, x21, #1		/* warm boot ?					*/
+	cmp	x1, #0			/* If x1 is 0 then cold boot			*/
+	bne	warm_reset		/* bit0 of x1 is 1 then warm boot		*/
+	/*										*/
+	/* Cold boot									*/
+	/*										*/
+	mov	x0, #0
+	b	exit
+
+warm_reset:
+	/* ---------------------------------------------
+	 * A per-cpu mailbox is maintained in the tru-
+	 * sted SDRAM. Its flushed out of the caches
+	 * after every update using normal memory so
+	 * its safe to read it here with SO attributes
+	 * ---------------------------------------------
+	 */
+	ldr	x10, =MBOX_BASE		/* top of mailbox address -> x10		*/
+	bl	platform_get_core_pos	/* restore cpu no to x0 as CA53=0-3, CA57=4-7	*/
+	lsl	x0, x0, #CACHE_WRITEBACK_SHIFT	/* 6bit left shift			*/
+					/* because mailbox size is 0x40 byte per cpu	*/
+	ldr	x0, [x10, x0]		/* top address of mailbox is entrypoint		*/
+	cbz	x0, _panic		/* If warm boot and entrypoint is 0 then panic	*/
+exit:
+	ret	x9
+_panic:	b	_panic
+endfunc platform_get_entrypoint
+
+
+	/* -----------------------------------------------------
+	 * void platform_mem_init (void);
+	 *
+	 * Zero out the mailbox registers in the shared memory
+	 * and set the rcar_boot_kind_flag.
+	 * The mmu is turned off right now and only the primary can
+	 * ever execute this code. Secondaries will read the
+	 * mailboxes using SO accesses.
+	 * -----------------------------------------------------
+	 */
+func platform_mem_init
+	ldr	x0, =MBOX_BASE
+	mov	w1, #PLATFORM_CORE_COUNT
+loop:
+	str	xzr, [x0], #CACHE_WRITEBACK_GRANULE
+	subs	w1, w1, #1
+	b.gt	loop
+	/* for R-Car Gen3		*/
+	ldr	x0, =rcar_boot_kind_flag
+	str	w21, [x0]
+	ret
+endfunc platform_mem_init
+
+	/* ---------------------------------------------
+	 * void plat_report_exception(unsigned int type)
+	 * Function to report an unhandled exception
+	 * with platform-specific means.
+	 * ---------------------------------------------
+	 */
+func plat_report_exception
+	mrs	x1, CurrentEl
+
+	str	w0, [x1]
+#if IMAGE_BL2
+	mov	w1, #FIQ_SP_ELX
+	cmp	w0, w1
+	beq	rep_exec_fiq_elx
+/*
+ * Please imprement checking the other type of interrupt
+*/
+	b	rep_exec_panic_type
+rep_exec_fiq_elx:
+	bl	arm_gic_acknowledge_interrupt
+	mov	x2, #INT_ID_MASK
+	and	x0, x0, x2
+	mov	x1, #ARM_IRQ_SEC_WDT_A
+	cmp	x0, x1
+	bne	rep_exec_panic_id
+	mrs	x0, ELR_EL1
+	b	bl2_swdt_exec
+rep_exec_panic_type:	/* interrupt type error	*/
+	/* x0 is interrupt TYPE */
+	b	bl2_interrupt_error_type
+rep_exec_panic_id:	/* interrupt id error	*/
+	/* x0 is interrupt ID */
+	b	bl2_interrupt_error_id
+rep_exec_end:
+#endif
+	ret
+endfunc plat_report_exception
+
+	/*
+	 *	Starting CPU is ...
+	 *		MD7=1 and MD6=1 of MODEMR	: CortexR7
+	 *		MD7=1 and MD6=0 of MODEMR	: Reserved
+	 *		MD7=0 and MD6=1 of MODEMR	: CortexA53
+	 *		MD7=0 and MD6=0 of MODEMR	: CortexA57
+	 *
+	 *	Information of MPIDR_EL1
+	 *		affinity level 1(bit15-8) = 1	: CortexA53
+	 *		affinity level 1(bit15-8) = 0	: CortexA57
+	 *
+	 */
+
+func platform_is_primary_cpu
+	/*
+	 * Get MD6 and MD7 of MODEMR, then move MD6 to bit0 and move MD7 to bit1 of x1
+	 */
+	ldr	x1, =RCAR_MODEMR_A		/* x1 <- address of MODEMR register	*/
+	ldr	x2, [x1]			/* Get the data of MODEMR -> x2		*/
+	mov	x1, #0x00c0			/* move MD6(0x0040) and MD7(0x0080)	*/
+	and	x1, x2, x1			/* Get MD6 and MD7 information -> x1	*/
+	lsr	x1, x1, #6			/* MD6->bit0, MD7->bit1			*/
+	/*
+	 * Get data of affinity level 1 of MPIDR_EL1, then move data to bit7-0 of x2
+	 */
+	mov	x2, #MPIDR_CLUSTER_MASK		/* MPIDR_CLUSTER_MASK=0xFF00 -> x2	*/
+	and	x2, x0, x2			/* Get the affinity level 1 -> x2	*/
+	lsr	x2, x2, #MPIDR_AFFINITY_BITS	/* affinity level 1 -> bit7-0 of x2	*/
+	/*
+	 * Check the starting CPU by MD7
+	 */
+	mov	x3, #0x0002			/* for test the MD7			*/
+	and	x3, x1, x3			/* MD7 information -> x3(0 or not)	*/
+	cbnz	x3, primary_check		/* Starting CPU is CortexR7		*/
+	/*
+	 * CA53 check
+	 */
+	mov	x3, #0x0003			/* MD6 and MD7				*/
+	and	x3, x1, x3
+	cmp	x3, #0x0001			/* If starting CPU is CortexA53		*/
+	bne	checkCA57			/*  is not then branch to check CA57	*/
+	cmp	x2, #0x0001			/* If affinity level 1 is CortexA53	*/
+	beq	primary_check			/*  CPU is CortexA53			*/
+	b	platform_is_secondary		/* It is secondary			*/
+	/*
+	 * CA57 check
+	 */
+checkCA57:
+	cmp	x3, #0x0000			/* If starting CPU is CortexA57		*/
+	bne	platform_is_secondary
+	cmp	x2, #0x0000			/* If affinity level 1 is CortexA57	*/
+	beq	primary_check			/*  CPU is CortexA57			*/
+	/*
+	 * This CPU is secondary
+	 */
+platform_is_secondary:
+	mov	x0, #0				/* This cpu is secondary		*/
+	b	primary_check_exit		/* return				*/
+primary_check:
+	and	x0, x0, # MPIDR_CPU_MASK	/* Get the bit7-0 of MPIDR_EL1 -> x0	*/
+	cmp	x0, #RCAR_PRIMARY_CPU		/* x0 = 0 (primary CPU)?		*/
+	cset	x0, eq				/* If x0 is 0 carry bit set		*/
+primary_check_exit:
+	ret
+endfunc platform_is_primary_cpu
+
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 * Function to initialize log area
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+#if IMAGE_BL2
+	mov	x0, #0
+#else
+	mov	x1, sp
+	mov_imm	x2, RCAR_CRASH_STACK
+	mov	sp, x2
+	str	x1, [sp, #-16]!
+	str	x30, [sp, #-16]!
+	bl	console_core_init
+	ldr	x30, [sp], #16
+	ldr	x1, [sp], #16
+	mov	sp, x1
+#endif
+	ret
+endfunc plat_crash_console_init
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_putc(int c)
+	 * Function to store a character to log area
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_putc
+	mov	x1, sp
+	mov_imm	x2, RCAR_CRASH_STACK
+	mov	sp, x2
+	str	x1, [sp, #-16]!
+	str	x30, [sp, #-16]!
+	str	x3, [sp, #-16]!
+	str	x4, [sp, #-16]!
+	str	x5, [sp, #-16]!
+	bl	console_core_putc
+	ldr	x5, [sp], #16
+	ldr	x4, [sp], #16
+	ldr	x3, [sp], #16
+	ldr	x30, [sp], #16
+	ldr	x1, [sp], #16
+	mov	sp, x1
+	ret
+endfunc plat_crash_console_putc
+
+
+	/* --------------------------------------------------------------------
+	 * void plat_reset_handler(void);
+	 *
+	 * Before adding code in this function, refer to the guidelines in
+	 * docs/firmware-design.md to determine whether the code should reside
+	 * within the FIRST_RESET_HANDLER_CALL block or not.
+	 *
+	 * For R-Car H3:
+	 * - Set the L2 Tag RAM latency to 2 (i.e. 3 cycles) for Cortex-A57
+	 * - Set the L2 Data setup latency to 1 (i.e. 1 cycles) for Cortex-A57
+	 * - Set the L2 Data RAM latency to 3 (i.e. 4 cycles) for Cortex-A57
+	 * For R-Car M3:
+	 * - Set the L2 Tag RAM latency to 2 (i.e. 3 cycles) for Cortex-A57
+	 * - Set the L2 Data setup latency to 0 (i.e. 0 cycles) for Cortex-A57
+	 * - Set the L2 Data RAM latency to 3 (i.e. 4 cycles) for Cortex-A57
+	 *
+	 * --------------------------------------------------------------------
+	 */
+func plat_reset_handler
+	/* --------------------------------------------------------------------
+	 * Determine whether this code is running on R-Car H3 or R-Car M3.
+	 * Keep this information in x2.
+	 * --------------------------------------------------------------------
+	 */
+	/*
+	 * On R-Car H3:  x2 := 0
+	 * On R-Car M3:  x2 := 1
+	 */
+	ldr	x0, =0xFFF00044	/* read PRR */
+	ldr	w0, [x0]
+	ubfx	w0, w0, 8, 8
+	cmp	w0, #0x4F	/* H3? */
+	b.eq	H3
+	mov	x2, #1		/* set R-Car M3 */
+	b	CHK_A5x
+H3:
+	mov	x2, #0		/* set R-Car H3 */
+	/* --------------------------------------------------------------------
+	 * Determine whether this code is executed on a Cortex-A53 or on a
+	 * Cortex-A57 core.
+	 * --------------------------------------------------------------------
+	 */
+CHK_A5x:
+	mrs	x0, midr_el1
+	ubfx	x1, x0, MIDR_PN_SHIFT, #12
+	cmp     w1, #((CORTEX_A57_MIDR >> MIDR_PN_SHIFT) & MIDR_PN_MASK)
+	b.eq	A57
+
+	ret
+
+A57:
+	/* --------------------------------------------------------------------
+	 * Cortex-A57 specific settings
+	 * --------------------------------------------------------------------
+	 */
+	mrs	x0, L2CTLR_EL1		/* Get data from L2CTLR_EL1		*/
+	/*
+	 * On R-Car H3/M3
+	 *
+	 * L2 Tag RAM latency is bit8-6 of L2CTLR_EL1
+	 * L2 Data RAM setup is bit5 of L2CTLR_EL1
+	 * L2 Data RAM latency is bit2-0 of L2CTLR_EL1
+	 */
+	mov	x1, #0x1e7		/* for clear bit of L2 RAM		*/
+	neg	x1, x1			/* ~(0x1e7) -> x1			*/
+	and	x0, x0, x1		/* clear bit of L2 RAM -> x0		*/
+	orr	x0, x0, #0x2 << 6  	/* L2 Tag RAM latency (3 cycles)	*/
+	cbnz	x2, M3_L2		/* If M3 then L2 Data RAM setup is 0	*/
+	orr	x0, x0, #0x1 << 5  	/* L2 Data RAM setup (1 cycle)		*/
+M3_L2:
+	orr	x0, x0, #0x3       	/* L2 Data RAM latency (4 cycles)	*/
+	msr     L2CTLR_EL1, x0		/* Store data to L2CTLR_EL1		*/
+
+apply_l2_ram_latencies:
+
+	ret
+endfunc plat_reset_handler
+
+
+	/* ---------------------------------------------
+	 * void iciallu(void)
+	 * Instruction Cache Invalidate All to PoU
+	 * ---------------------------------------------
+	 */
+func iciallu
+	ic	iallu
+
+	ret
+endfunc iciallu
diff --git a/plat/renesas/rcar/bl2_cpg_init.c b/plat/renesas/rcar/bl2_cpg_init.c
new file mode 100644
index 0000000..e3e903d
--- /dev/null
+++ b/plat/renesas/rcar/bl2_cpg_init.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <mmio.h>
+#include "rcar_def.h"
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_init.h"
+
+typedef struct {
+	uintptr_t	adr;
+	uint32_t	val;
+} reg_setting_t;
+
+static const reg_setting_t reg_setting[] = {
+
+	/* CPG (SECURITY) registers */
+
+	/* Secure Module Stop Control Register 0 */
+	{SCMSTPCR0,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 1 */
+	{SCMSTPCR1,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 2 */
+	{SCMSTPCR2,		0xEBFFFFFFU},
+	/* Secure Module Stop Control Register 3 */
+	{SCMSTPCR3,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 4 */
+	{SCMSTPCR4,		0x7FFFFFFFU},
+	/* Secure Module Stop Control Register 5 */
+	{SCMSTPCR5,		0xBFFFFFFFU},
+	/* Secure Module Stop Control Register 6 */
+	{SCMSTPCR6,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 7 */
+	{SCMSTPCR7,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 8 */
+	{SCMSTPCR8,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 9 */
+	{SCMSTPCR9,		0xFFFDFFFFU},
+	/* Secure Module Stop Control Register 10 */
+	{SCMSTPCR10,		0xFFFFFFFFU},
+	/* Secure Module Stop Control Register 11 */
+	{SCMSTPCR11,		0xFFFFFFFFU},
+	/* Secure Software Reset Access Enable Control Register 0 */
+	{SCSRSTECR0,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 1 */
+	{SCSRSTECR1,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 2 */
+	{SCSRSTECR2,		0x14000000U},
+	/* Secure Software Reset Access Enable Control Register 3 */
+	{SCSRSTECR3,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 4 */
+	{SCSRSTECR4,		0x80000003U},
+	/* Secure Software Reset Access Enable Control Register 5 */
+	{SCSRSTECR5,		0x40000000U},
+	/* Secure Software Reset Access Enable Control Register 6 */
+	{SCSRSTECR6,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 7 */
+	{SCSRSTECR7,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 8 */
+	{SCSRSTECR8,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 9 */
+	{SCSRSTECR9,		0x00020000U},
+	/* Secure Software Reset Access Enable Control Register 10 */
+	{SCSRSTECR10,		0x00000000U},
+	/* Secure Software Reset Access Enable Control Register 11 */
+	{SCSRSTECR11,		0x00000000U},
+
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* CPG (REALTIME) registers */
+
+	/* Realtime Module Stop Control Register 0 */
+	{RMSTPCR0,		0x00000000U},
+	/* Realtime Module Stop Control Register 1 */
+	{RMSTPCR1,		0xFFFFFFFFU},
+	/* Realtime Module Stop Control Register 2 */
+	{RMSTPCR2,		0x340E2FDCU},
+	/* Realtime Module Stop Control Register 3 */
+	{RMSTPCR3,		0xFFFFFFDFU},
+	/* Realtime Module Stop Control Register 4 */
+	{RMSTPCR4,		0x80000184U},
+	/* Realtime Module Stop Control Register 5 */
+	{RMSTPCR5,		0xC3FFFFFFU},
+	/* Realtime Module Stop Control Register 6 */
+	{RMSTPCR6,		0xFFFFFFFFU},
+	/* Realtime Module Stop Control Register 7 */
+	{RMSTPCR7,		0xFFFFFFFFU},
+	/* Realtime Module Stop Control Register 8 */
+	{RMSTPCR8,		0x01F1FFF4U},
+	/* Realtime Module Stop Control Register 9 */
+	{RMSTPCR9,		0xFFFFFFFEU},
+	/* Realtime Module Stop Control Register 10 */
+	{RMSTPCR10,		0xFFFEFFE0U},
+	/* Realtime Module Stop Control Register 11 */
+	{RMSTPCR11,		0x00000037U}
+#endif
+};
+
+void bl2_cpg_init(void)
+{
+	uint32_t	i;
+	uint32_t	ie;
+
+	ie = (uint32_t)(sizeof(reg_setting) / sizeof(reg_setting_t));
+
+	for (i = 0U; i < ie; i++) {
+		cpg_write(reg_setting[i].adr, reg_setting[i].val);
+	}
+}
+
+void cpg_write(uintptr_t regadr, uint32_t regval)
+{
+	uint32_t value = (regval);
+	mmio_write_32((uintptr_t)CPG_CPGWPR,~value);
+	mmio_write_32(regadr,value);
+}
diff --git a/plat/renesas/rcar/bl2_rcar_setup.c b/plat/renesas/rcar/bl2_rcar_setup.c
new file mode 100755
index 0000000..8bc1218
--- /dev/null
+++ b/plat/renesas/rcar/bl2_rcar_setup.c
@@ -0,0 +1,630 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch_helpers.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <console.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <string.h>
+#include <arm_gic.h>
+#include "rcar_def.h"
+#include "rcar_private.h"
+#include "io_common.h"
+#include "pfc_init.h"
+#include "rpc_driver.h"
+#include "dma_driver.h"
+#include "bl2_secure_setting.h"
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_init.h"
+#include <debug.h>
+#include <mmio.h>
+#include "ddr/boot_init_dram.h"
+#include "qos/qos_init.h"
+#include "rcar_version.h"
+#include "bl2_swdt.h"
+#include "avs_driver.h"
+#include "scif.h"
+
+
+/* CPG write protect registers */
+/*#define	CPG_CPGWPR		(CPG_BASE + 0x900U)*/
+/*#define	CPG_CPGWPCR		(CPG_BASE + 0x904U)*/
+#define	CPGWPR_PASSWORD		(0x5A5AFFFFU)
+#define	CPGWPCR_PASSWORD	(0xA5A50000U)
+
+/* CA57 Debug Resource control registers */
+#define	CPG_CA57DBGRCR		(CPG_BASE + 0x2180U)
+#define	DBGCPUPREN		((uint32_t)1U << 19U)
+#define	CPG_PLL0CR		(CPG_BASE + 0x00D8U)
+#define	CPG_PLL2CR		(CPG_BASE + 0x002CU)
+#define	CPG_PLL4CR		(CPG_BASE + 0x01F4U)
+
+/* RST Registers */
+#define	RST_BASE		(0xE6160000U)
+#define	RST_WDTRSTCR		(RST_BASE + 0x0054U)
+#define	WDTRSTCR_PASSWORD	(0xA55A0000U)
+#define	WDTRSTCR_RWDT_RSTMSK	((uint32_t)1U << 0U)
+
+/* IPMMUregisters */
+#define IPMMU_MM_BASE		(0xE67B0000U)	/* IPMMU-MM */
+#define IPMMUMM_SYSCTRL		(IPMMU_MM_BASE + 0x0500U)
+#define IPMMUMM_SYSAUX		(IPMMU_MM_BASE + 0x0504U)
+
+/* MIDR */
+#define MIDR_CA57		(0x0D07U << MIDR_PN_SHIFT)
+#define MIDR_CA53		(0x0D03U << MIDR_PN_SHIFT)
+
+/* MaskROM API */
+typedef uint32_t(*ROM_GETLCS_API)(uint32_t *pLcs);
+#if RCAR_LSI == RCAR_H3
+#define ROM_GETLCS_API_ADDR	((ROM_GETLCS_API)0xEB10DFE0U)
+#elif RCAR_LSI == RCAR_M3
+#define ROM_GETLCS_API_ADDR	((ROM_GETLCS_API)0xEB110578U)
+#endif
+#define LCS_CM			(0x0U)
+#define LCS_DM			(0x1U)
+#define LCS_SD			(0x3U)
+#define LCS_SE			(0x5U)
+#define LCS_FA			(0x7U)
+
+/* R-Car Gen3 product check */
+#if RCAR_LSI == RCAR_H3
+#define TARGET_PRODUCT		RCAR_PRODUCT_H3
+#define TARGET_NAME		"R-Car H3"
+#elif RCAR_LSI == RCAR_M3
+#define TARGET_PRODUCT		RCAR_PRODUCT_M3
+#define TARGET_NAME		"R-Car M3"
+#endif
+
+
+/*******************************************************************************
+ * Declarations of linker defined symbols which will help us find the layout
+ * of trusted SRAM
+ ******************************************************************************/
+extern unsigned long __RO_START__;
+extern unsigned long __RO_END__;
+
+#if USE_COHERENT_MEM
+extern unsigned long __COHERENT_RAM_START__;
+extern unsigned long __COHERENT_RAM_END__;
+#endif
+
+/*
+ * The next 2 constants identify the extents of the code & RO data region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __RO_START__ and __RO_END__ linker symbols refer to page-aligned addresses.
+ */
+#define BL2_RO_BASE (unsigned long)(&__RO_START__)
+#define BL2_RO_LIMIT (unsigned long)(&__RO_END__)
+
+#if USE_COHERENT_MEM
+/*
+ * The next 2 constants identify the extents of the coherent memory region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __COHERENT_RAM_START__ and __COHERENT_RAM_END__ linker symbols refer to
+ * page-aligned addresses.
+ */
+#define BL2_COHERENT_RAM_BASE (unsigned long)(&__COHERENT_RAM_START__)
+#define BL2_COHERENT_RAM_LIMIT (unsigned long)(&__COHERENT_RAM_END__)
+#endif
+
+/* Data structure which holds the extents of the trusted SRAM for BL2 */
+static meminfo_t bl2_tzram_layout
+__attribute__ ((aligned(PLATFORM_CACHE_LINE_SIZE)));
+
+/* Assert that BL3-1 parameters fit in shared memory */
+CASSERT((PARAMS_BASE + sizeof(bl2_to_bl31_params_mem_t)) <
+	(RCAR_SHARED_MEM_BASE + RCAR_SHARED_MEM_SIZE),
+	assert_bl31_params_do_not_fit_in_shared_memory);
+
+/*******************************************************************************
+ * Reference to structures which holds the arguments which need to be passed
+ * to BL31
+ ******************************************************************************/
+static bl31_params_t *bl2_to_bl31_params;
+static entry_point_info_t *bl31_ep_info;
+
+meminfo_t *bl2_plat_sec_mem_layout(void)
+{
+	return &bl2_tzram_layout;
+}
+
+/*******************************************************************************
+ * This function assigns a pointer to the memory that the platform has kept
+ * aside to pass platform specific and trusted firmware related information
+ * to BL31. This memory is allocated by allocating memory to
+ * bl2_to_bl31_params_mem_t structure which is a superset of all the
+ * structure whose information is passed to BL31
+ * NOTE: This function should be called only once and should be done
+ * before generating params to BL31
+ ******************************************************************************/
+bl31_params_t *bl2_plat_get_bl31_params(void)
+{
+	bl2_to_bl31_params_mem_t *bl31_params_mem;
+
+	/*
+	 * Allocate the memory for all the arguments that needs to
+	 * be passed to BL31
+	 */
+	bl31_params_mem = (bl2_to_bl31_params_mem_t *)PARAMS_BASE;
+	memset((void *)PARAMS_BASE, 0, sizeof(bl2_to_bl31_params_mem_t));
+
+	/* Assign memory for TF related information */
+	bl2_to_bl31_params = &bl31_params_mem->bl31_params;
+	SET_PARAM_HEAD(bl2_to_bl31_params, PARAM_BL31, VERSION_1, 0);
+
+	/* Fill BL31 related information */
+	bl31_ep_info = &bl31_params_mem->bl31_ep_info;
+	bl2_to_bl31_params->bl31_image_info = &bl31_params_mem->bl31_image_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl31_image_info, PARAM_IMAGE_BINARY,
+						VERSION_1, 0);
+
+	/* Fill BL32 related information if it exists */
+	if (BL32_BASE) {
+		bl2_to_bl31_params->bl32_ep_info =
+					&bl31_params_mem->bl32_ep_info;
+		SET_PARAM_HEAD(bl2_to_bl31_params->bl32_ep_info,
+					PARAM_EP, VERSION_1, 0);
+		bl2_to_bl31_params->bl32_image_info =
+					&bl31_params_mem->bl32_image_info;
+		SET_PARAM_HEAD(bl2_to_bl31_params->bl32_image_info,
+					PARAM_IMAGE_BINARY,
+					VERSION_1, 0);
+	}
+
+	/* Fill BL33 related information */
+	bl2_to_bl31_params->bl33_ep_info = &bl31_params_mem->bl33_ep_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl33_ep_info,
+					PARAM_EP, VERSION_1, 0);
+	bl2_to_bl31_params->bl33_image_info = &bl31_params_mem->bl33_image_info;
+	SET_PARAM_HEAD(bl2_to_bl31_params->bl33_image_info, PARAM_IMAGE_BINARY,
+					VERSION_1, 0);
+
+	return bl2_to_bl31_params;
+}
+
+
+/*******************************************************************************
+ * This function returns a pointer to the shared memory that the platform
+ * has kept to point to entry point information of BL31 to BL2
+ ******************************************************************************/
+struct entry_point_info *bl2_plat_get_bl31_ep_info(void)
+{
+#if 0
+#if DEBUG
+	bl31_ep_info->args.arg1 = RCAR_BL31_PLAT_PARAM_VAL;
+#endif
+#else
+	bl31_ep_info->args.arg1 = 0x00000000;	/* nomal boot/cold boot */
+#endif
+	return bl31_ep_info;
+}
+
+/* Settings for Lossy Decompression */
+#define LOSSY_PARAMS_BASE 		(0x47FD7000U)
+
+#define	AXI_DCMPAREACRA0		(0xE6784100U)
+#define	AXI_DCMPAREACRB0		(0xE6784104U)
+
+#define LOSSY_ENABLE			(0x80000000U)
+#define LOSSY_DISABLE			(0x00000000U)
+
+#define LOSSY_FMT_YUVPLANAR		(0x00000000U)
+#define LOSSY_FMT_YUV422INTLV	(0x20000000U)
+#define LOSSY_FMT_ARGB8888		(0x40000000U)
+
+/* Settings of Entry 0 */
+#define	LOSSY_ST_ADDR0			(0x54000000U)
+#define	LOSSY_END_ADDR0			(0x57000000U)
+#define	LOSSY_FMT0				LOSSY_FMT_YUVPLANAR
+#define	LOSSY_ENA_DIS0			LOSSY_ENABLE
+
+/* Settings of Entry 1 */
+#define	LOSSY_ST_ADDR1			0x0 /* Undefined */
+#define	LOSSY_END_ADDR1			0x0 /* Undefined */
+#define	LOSSY_FMT1				LOSSY_FMT_ARGB8888
+#define	LOSSY_ENA_DIS1			LOSSY_DISABLE
+
+/* Settings of Entry 2 */
+#define	LOSSY_ST_ADDR2			0x0 /* Undefined */
+#define	LOSSY_END_ADDR2			0x0 /* Undefined */
+#define	LOSSY_FMT2				LOSSY_FMT_YUV422INTLV
+#define	LOSSY_ENA_DIS2			LOSSY_DISABLE
+
+typedef struct bl2_lossy_info {
+	uint32_t magic;
+	uint32_t a0;
+	uint32_t b0;
+} bl2_lossy_info_t;
+
+void bl2_lossy_setting(uint32_t no, uint32_t start_addr, uint32_t end_addr,
+	uint32_t format, uint32_t enable)
+{
+	uint32_t reg;
+	bl2_lossy_info_t *bl2_lossy_info;
+
+	/* Setting of the start address and format */
+	reg = format | (start_addr >> 20);
+	mmio_write_32(AXI_DCMPAREACRA0 + 0x8 * no, reg);
+
+	/* Setting of the end address */
+	mmio_write_32(AXI_DCMPAREACRB0 + 0x8 * no,
+		(end_addr >> 20));
+
+	/* Enable or Disable of Lossy setting */
+	mmio_write_32(AXI_DCMPAREACRA0 + 0x8 * no, (reg | enable));
+
+	bl2_lossy_info = (bl2_lossy_info_t *)(LOSSY_PARAMS_BASE);
+	bl2_lossy_info += no;
+	bl2_lossy_info->magic = 0x12345678;
+	bl2_lossy_info->a0 = mmio_read_32(AXI_DCMPAREACRA0 + 0x8 * no);
+	bl2_lossy_info->b0 = mmio_read_32(AXI_DCMPAREACRB0 + 0x8 * no);
+
+	NOTICE("     Entry %d: DCMPAREACRAx:0x%x DCMPAREACRBx:0x%x\n", no,
+		mmio_read_32(AXI_DCMPAREACRA0 + 0x8 * no),
+		mmio_read_32(AXI_DCMPAREACRB0 + 0x8 * no));
+}
+
+/*******************************************************************************
+ * BL1 has passed the extents of the trusted SRAM that should be visible to BL2
+ * in x0. This memory layout is sitting at the base of the free trusted SRAM.
+ * Copy it to a safe loaction before its reclaimed by later BL2 functionality.
+ ******************************************************************************/
+void bl2_early_platform_setup(meminfo_t *mem_layout)
+{
+	const unsigned int irq_sec_array[] = {
+		ARM_IRQ_SEC_WDT                /* 173          */
+	};
+	const ROM_GETLCS_API	ROM_GetLcs = ROM_GETLCS_API_ADDR;
+	uint32_t reg;
+	uint32_t lcs;
+	const char *str;
+	const char *cpu_ca57        = "CA57";
+	const char *cpu_ca53        = "CA53";
+	const char *product_h3      = "H3";
+	const char *product_m3      = "M3";
+	const char *lcs_cm          = "CM";
+	const char *lcs_dm          = "DM";
+	const char *lcs_sd          = "SD";
+	const char *lcs_secure      = "SE";
+	const char *lcs_fa          = "FA";
+	const char *unknown         = "unknown";
+
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* initialize Pin Function */
+	pfc_init();
+#endif
+
+	/* Initialize CPG configuration */
+	bl2_cpg_init();
+
+	/* Initialize the console to provide early debug support */
+	(void)console_init(0U, 0U, 0U);
+
+	/* GIC initialize		*/
+	arm_gic_init(RCAR_GICC_BASE, RCAR_GICD_BASE, RCAR_GICR_BASE
+			,irq_sec_array, ARRAY_SIZE(irq_sec_array));
+	/* GIC setup			*/
+	arm_gic_setup();
+
+	/* Enable FIQ interrupt		*/
+	enable_fiq();
+
+	/* System WDT initialize	*/
+	bl2_swdt_init();
+
+	bl2_avs_init();		/*  Initialize AVS Settings */
+	
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+	
+	/* boot message */
+	reg = (uint32_t)read_midr();
+	switch (reg & (uint32_t)(MIDR_PN_MASK << MIDR_PN_SHIFT)) { 
+	case MIDR_CA57:
+		str = cpu_ca57;
+		break;
+	case MIDR_CA53:
+		str = cpu_ca53;
+		break;
+	default:
+		str = unknown;
+		break;
+	}
+	NOTICE("BL2: R-Car Gen3 Initial Program Loader(%s) Rev.%s\n", str, version_of_renesas);
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+	
+	/* R-Car Gen3 product display & check */
+	reg = mmio_read_32(RCAR_PRR);
+	switch (reg & RCAR_PRODUCT_MASK) {
+	case RCAR_PRODUCT_H3:
+		str = product_h3;
+		break;
+	case RCAR_PRODUCT_M3:
+		str = product_m3;
+		break;
+	default:
+		str = unknown;
+		break;
+	}
+	NOTICE("BL2: PRR is R-Car %s ES%d.%d\n", str,
+		((reg & RCAR_MAJOR_MASK) >> RCAR_MAJOR_SHIFT) + RCAR_MAJOR_OFFSET,
+		 (reg & RCAR_MINOR_MASK));
+	if((reg & RCAR_PRODUCT_MASK) != TARGET_PRODUCT) {
+		ERROR("BL2: This IPL has been built for the %s.\n", 
+								TARGET_NAME);
+		ERROR("BL2: Please write the correct IPL to flash memory.\n");
+		panic();
+	}
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+
+	reg = ROM_GetLcs(&lcs);
+	if (reg == 0U) {
+		switch (lcs) {
+		case LCS_CM:
+			str = lcs_cm;
+			break;
+		case LCS_DM:
+			str = lcs_dm;
+			break;
+		case LCS_SD:
+			str = lcs_sd;
+			break;
+		case LCS_SE:
+			str = lcs_secure;
+			break;
+		case LCS_FA:
+			str = lcs_fa;
+			break;
+		default:
+			str = unknown;
+			break;
+		}
+	} else {
+		str = unknown;
+	}
+	NOTICE("BL2: LCM state is %s\n", str);
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+	
+	/* Setup the BL2 memory layout */
+	bl2_tzram_layout = *mem_layout;
+
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	/* Initialize SDRAM */
+	InitDram();
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+
+	/* initialize QoS configration */
+	qos_init();
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+#endif
+
+	/* Initialize RPC */
+	initRPC();
+
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+
+	/* Initialize DMA */
+	initDMA();
+
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+	bl2_avs_setting();	/*  Proceed with separated AVS processing */
+
+	/* Initialize secure configuration */
+	bl2_secure_setting();
+#endif
+
+	bl2_avs_end();		/* End of AVS Settings */
+
+	/* unmask the detection of RWDT overflow */
+	reg = mmio_read_32(RST_WDTRSTCR);
+	reg &= ~WDTRSTCR_RWDT_RSTMSK;
+	reg |= WDTRSTCR_PASSWORD;
+	mmio_write_32(RST_WDTRSTCR, reg);
+
+	/* Release CPG write protect */
+	mmio_write_32(CPG_CPGWPR, CPGWPR_PASSWORD);
+	mmio_write_32(CPG_CPGWPCR, CPGWPCR_PASSWORD);
+
+	/* CA57 debug resource control */
+	mmio_write_32(CPG_CA57DBGRCR,
+			DBGCPUPREN | mmio_read_32(CPG_CA57DBGRCR));
+
+	/* STA restriction check for R-Car H3 WS1.0 */
+	reg = mmio_read_32(RCAR_PRR) & (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+	if (reg  == RCAR_PRODUCT_H3_CUT10) {
+		/* PLL0, PLL2, PLL4 setting */
+		reg = mmio_read_32(CPG_PLL2CR);
+		reg &= ~((uint32_t)1U << 5U);	/* bit5 = 0 */
+		mmio_write_32(CPG_PLL2CR, reg);
+
+		reg = mmio_read_32(CPG_PLL4CR);
+		reg &= ~((uint32_t)1U << 5U);	/* bit5 = 0 */
+		mmio_write_32(CPG_PLL4CR, reg);
+
+		reg = mmio_read_32(CPG_PLL0CR);
+		reg &= ~((uint32_t)1U << 12U);	/* bit12 = 0 */
+		mmio_write_32(CPG_PLL0CR, reg);
+	}
+
+	NOTICE("BL2: Lossy Decomp areas\n");
+	/* Lossy setting : entry 0 */
+	bl2_lossy_setting(0, LOSSY_ST_ADDR0, LOSSY_END_ADDR0,
+		LOSSY_FMT0, LOSSY_ENA_DIS0);
+
+	/* Lossy setting : entry 1 */
+	bl2_lossy_setting(1, LOSSY_ST_ADDR1, LOSSY_END_ADDR1,
+		LOSSY_FMT1, LOSSY_ENA_DIS1);
+
+	/* Lossy setting : entry 2 */
+	bl2_lossy_setting(2, LOSSY_ST_ADDR2, LOSSY_END_ADDR2,
+		LOSSY_FMT2, LOSSY_ENA_DIS2);
+
+	/* Initialise the IO layer and register platform IO devices */
+	rcar_io_setup();
+}
+
+/*******************************************************************************
+ * Perform platform specific setup. For now just initialize the memory location
+ * to use for passing arguments to BL31.
+ ******************************************************************************/
+void bl2_platform_setup(void)
+{
+	/*
+	 * Do initial security configuration to allow DRAM/device access. On
+	 * Base RCAR only DRAM security is programmable (via TrustZone), but
+	 * other platforms might have more programmable security devices
+	 * present.
+	 */
+
+	/* IPMMU-MM setting for linux */
+	mmio_write_32(IPMMUMM_SYSCTRL, 0xC0000000U);
+	mmio_write_32(IPMMUMM_SYSAUX, 0x01000000U);
+}
+
+/* Flush the TF params and the TF plat params */
+void bl2_plat_flush_bl31_params(void)
+{
+	uint32_t val;
+
+	/* disable the System WDT, FIQ and GIC	*/
+	bl2_swdt_release();
+
+	/* Finalize a console of provide early debug support */
+	console_finalize();
+
+	/* Disable instruction cache */
+	val = (uint32_t)read_sctlr_el1();
+	val &= ~((uint32_t)SCTLR_I_BIT);
+	write_sctlr_el1((uint64_t)val);
+	isb();
+
+	/* Invalidate instruction cache */
+	iciallu();
+	dsb();
+	isb();
+}
+
+
+/*******************************************************************************
+ * Perform the very early platform specific architectural setup here. At the
+ * moment this is only intializes the mmu in a quick and dirty way.
+ ******************************************************************************/
+void bl2_plat_arch_setup(void)
+{
+#if 0
+	rcar_configure_mmu_el1(bl2_tzram_layout.total_base,
+			      bl2_tzram_layout.total_size,
+			      BL2_RO_BASE,
+			      BL2_RO_LIMIT
+#if USE_COHERENT_MEM
+			      , BL2_COHERENT_RAM_BASE,
+			      BL2_COHERENT_RAM_LIMIT
+#endif
+			      );
+#endif
+}
+
+/*******************************************************************************
+ * Before calling this function BL31 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL31 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl31_ep_info(image_info_t *bl31_image_info,
+					entry_point_info_t *bl31_ep_info)
+{
+	SET_SECURITY_STATE(bl31_ep_info->h.attr, SECURE);
+	bl31_ep_info->spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
+					DISABLE_ALL_EXCEPTIONS);
+}
+
+
+/*******************************************************************************
+ * Before calling this function BL32 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL32 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl32_ep_info(image_info_t *bl32_image_info,
+					entry_point_info_t *bl32_ep_info)
+{
+	SET_SECURITY_STATE(bl32_ep_info->h.attr, SECURE);
+	bl32_ep_info->spsr = rcar_get_spsr_for_bl32_entry();
+}
+
+/*******************************************************************************
+ * Before calling this function BL33 is loaded in memory and its entrypoint
+ * is set by load_image. This is a placeholder for the platform to change
+ * the entrypoint of BL33 and set SPSR and security state.
+ * On RCAR we are only setting the security state, entrypoint
+ ******************************************************************************/
+void bl2_plat_set_bl33_ep_info(image_info_t *image,
+					entry_point_info_t *bl33_ep_info)
+{
+	SET_SECURITY_STATE(bl33_ep_info->h.attr, NON_SECURE);
+	bl33_ep_info->spsr = rcar_get_spsr_for_bl33_entry();
+}
+
+
+/*******************************************************************************
+ * Populate the extents of memory available for loading BL32
+ ******************************************************************************/
+void bl2_plat_get_bl32_meminfo(meminfo_t *bl32_meminfo)
+{
+	/*
+	 * Populate the extents of memory available for loading BL32.
+	 */
+	bl32_meminfo->total_base = BL32_BASE;
+	bl32_meminfo->free_base = BL32_BASE;
+	bl32_meminfo->total_size = BL32_BASE;
+	bl32_meminfo->free_size = BL32_LIMIT - BL32_BASE;
+}
+
+
+/*******************************************************************************
+ * Populate the extents of memory available for loading BL33
+ ******************************************************************************/
+void bl2_plat_get_bl33_meminfo(meminfo_t *bl33_meminfo)
+{
+	bl33_meminfo->total_base = DRAM1_NS_BASE;
+	bl33_meminfo->total_size = DRAM1_NS_SIZE;
+	bl33_meminfo->free_base = DRAM1_NS_BASE;
+	bl33_meminfo->free_size = DRAM1_NS_SIZE;
+}
diff --git a/plat/renesas/rcar/bl2_secure_setting.c b/plat/renesas/rcar/bl2_secure_setting.c
new file mode 100644
index 0000000..fd2a800
--- /dev/null
+++ b/plat/renesas/rcar/bl2_secure_setting.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "bl2_lifec_register.h"
+#include "bl2_axi_register.h"
+#include "bl2_secure_setting.h"
+#include "mmio.h"
+
+typedef struct {
+	uint32_t	adr;
+	uint32_t	val;
+} reg_setting_t;
+
+static const reg_setting_t lifec_reg_setting[] = {
+
+	/* LIFEC0 (SECURITY) settings */
+
+	/* Security attribute setting for master ports */
+	{SEC_SRC,		0x0000001EU},
+	/** Security attribute setting for slave ports 0 */
+	{SEC_SEL0,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 1 */
+	{SEC_SEL1,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 2 */
+	{SEC_SEL2,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 3 */
+	{SEC_SEL3,		0xFFF7FDFFU},
+	/** Security attribute setting for slave ports 4 */
+	{SEC_SEL4,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 5 */
+	{SEC_SEL5,		0xFFFFFFBFU},
+	/** Security attribute setting for slave ports 6 */
+	{SEC_SEL6,		0xFFFFDBFFU},
+	/** Security attribute setting for slave ports 7 */
+	{SEC_SEL7,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 8 */
+	{SEC_SEL8,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 9 */
+	{SEC_SEL9,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 10 */
+	{SEC_SEL10,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 11 */
+	{SEC_SEL11,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 12 */
+	{SEC_SEL12,		0xFFFFFFFFU},
+	/** Security attribute setting for slave ports 13 */
+	{SEC_SEL13,		0xFFBFFFEFU},
+	/** Security attribute setting for slave ports 14 */
+	{SEC_SEL14,		0xF3FFFFFFU},
+	/** Security attribute setting for slave ports 15 */
+	{SEC_SEL15,		0xFFFFDE7FU},
+	/** Security group 0 attribute setting for master ports 0 */
+	{SEC_GRP0CR0,		0x00000000U},
+	/** Security group 1 attribute setting for master ports 0 */
+	{SEC_GRP1CR0,		0x00000000U},
+	/** Security group 0 attribute setting for master ports 1 */
+	{SEC_GRP0CR1,		0x00000000U},
+	/** Security group 1 attribute setting for master ports 1 */
+	{SEC_GRP1CR1,		0x00000000U},
+	/** Security group 0 attribute setting for master ports 2 */
+	{SEC_GRP0CR2,		0x00020000U},
+	/** Security group 1 attribute setting for master ports 2 */
+	{SEC_GRP1CR2,		0x00020000U},
+	/** Security group 0 attribute setting for master ports 3 */
+	{SEC_GRP0CR3,		0x00000500U},
+	/** Security group 1 attribute setting for master ports 3 */
+	{SEC_GRP1CR3,		0x00000500U},
+	/** Security group 0 attribute setting for slave ports 0 */
+	{SEC_GRP0COND0,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 0 */
+	{SEC_GRP1COND0,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 1 */
+	{SEC_GRP0COND1,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 1 */
+	{SEC_GRP1COND1,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 2 */
+	{SEC_GRP0COND2,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 2 */
+	{SEC_GRP1COND2,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 3 */
+	{SEC_GRP0COND3,		0x00080200U},
+	/** Security group 1 attribute setting for slave ports 3 */
+	{SEC_GRP1COND3,		0x00080200U},
+	/** Security group 0 attribute setting for slave ports 4 */
+	{SEC_GRP0COND4,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 4 */
+	{SEC_GRP1COND4,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 5 */
+	{SEC_GRP0COND5,		0x00000040U},
+	/** Security group 1 attribute setting for slave ports 5 */
+	{SEC_GRP1COND5,		0x00000040U},
+	/** Security group 0 attribute setting for slave ports 6 */
+	{SEC_GRP0COND6,		0x00002400U},
+	/** Security group 1 attribute setting for slave ports 6 */
+	{SEC_GRP1COND6,		0x00002400U},
+	/** Security group 0 attribute setting for slave ports 7 */
+	{SEC_GRP0COND7,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 7 */
+	{SEC_GRP1COND7,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 8 */
+	{SEC_GRP0COND8,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 8 */
+	{SEC_GRP1COND8,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 9 */
+	{SEC_GRP0COND9,		0x00000000U},
+	/** Security group 1 attribute setting for slave ports 9 */
+	{SEC_GRP1COND9,		0x00000000U},
+	/** Security group 0 attribute setting for slave ports 10 */
+	{SEC_GRP0COND10,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 10 */
+	{SEC_GRP1COND10,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 11 */
+	{SEC_GRP0COND11,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 11 */
+	{SEC_GRP1COND11,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 12 */
+	{SEC_GRP0COND12,	0x00000000U},
+	/** Security group 1 attribute setting for slave ports 12 */
+	{SEC_GRP1COND12,	0x00000000U},
+	/** Security group 0 attribute setting for slave ports 13 */
+	{SEC_GRP0COND13,	0x00400010U},
+	/** Security group 1 attribute setting for slave ports 13 */
+	{SEC_GRP1COND13,	0x00400010U},
+	/** Security group 0 attribute setting for slave ports 14 */
+	{SEC_GRP0COND14,	0x0C000000U},
+	/** Security group 1 attribute setting for slave ports 14 */
+	{SEC_GRP1COND14,	0x0C000000U},
+	/** Security group 0 attribute setting for slave ports 15 */
+	{SEC_GRP0COND15,	0x00000180U},
+	/** Security group 1 attribute setting for slave ports 15 */
+	{SEC_GRP1COND15,	0x00000180U},
+	/** Security write protection attribute setting for slave ports 0 */
+	{SEC_READONLY0,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 1 */
+	{SEC_READONLY1,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 2 */
+	{SEC_READONLY2,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 3 */
+	{SEC_READONLY3,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 4 */
+	{SEC_READONLY4,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 5 */
+	{SEC_READONLY5,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 6 */
+	{SEC_READONLY6,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 7 */
+	{SEC_READONLY7,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 8 */
+	{SEC_READONLY8,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 9 */
+	{SEC_READONLY9,		0x00000000U},
+	/** Security write protection attribute setting for slave ports 10 */
+	{SEC_READONLY10,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 11 */
+	{SEC_READONLY11,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 12 */
+	{SEC_READONLY12,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 13 */
+	{SEC_READONLY13,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 14 */
+	{SEC_READONLY14,	0x00000000U},
+	/** Security write protection attribute setting for slave ports 15 */
+	{SEC_READONLY15,	0x00000000U},
+
+	/* LIFEC1 (SAFETY) settings */
+
+	/* Safety group 0 attribute setting for master ports 0 */
+	{SAFE_GRP0CR0,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 0 */
+	{SAFE_GRP1CR0,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 1 */
+	{SAFE_GRP0CR1,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 1 */
+	{SAFE_GRP1CR1,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 2 */
+	{SAFE_GRP0CR2,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 2 */
+	{SAFE_GRP1CR2,		0x00000000U},
+	/* Safety group 0 attribute setting for master ports 3 */
+	{SAFE_GRP0CR3,		0x00000000U},
+	/* Safety group 1 attribute setting for master ports 3 */
+	{SAFE_GRP1CR3,		0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 0 */
+	{SAFE_GRP0COND0,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 0 */
+	{SAFE_GRP1COND0,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 1 */
+	{SAFE_GRP0COND1,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 1 */
+	{SAFE_GRP1COND1,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 2 */
+	{SAFE_GRP0COND2,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 2 */
+	{SAFE_GRP1COND2,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 3 */
+	{SAFE_GRP0COND3,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 3 */
+	{SAFE_GRP1COND3,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 4 */
+	{SAFE_GRP0COND4,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 4 */
+	{SAFE_GRP1COND4,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 5 */
+	{SAFE_GRP0COND5,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 5 */
+	{SAFE_GRP1COND5,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 6 */
+	{SAFE_GRP0COND6,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 6 */
+	{SAFE_GRP1COND6,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 7 */
+	{SAFE_GRP0COND7,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 7 */
+	{SAFE_GRP1COND7,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 8 */
+	{SAFE_GRP0COND8,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 8 */
+	{SAFE_GRP1COND8,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 9 */
+	{SAFE_GRP0COND9,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 9 */
+	{SAFE_GRP1COND9,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 10 */
+	{SAFE_GRP0COND10,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 10 */
+	{SAFE_GRP1COND10,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 11 */
+	{SAFE_GRP0COND11,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 11 */
+	{SAFE_GRP1COND11,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 12 */
+	{SAFE_GRP0COND12,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 12 */
+	{SAFE_GRP1COND12,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 13 */
+	{SAFE_GRP0COND13,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 13 */
+	{SAFE_GRP1COND13,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 14 */
+	{SAFE_GRP0COND14,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 14 */
+	{SAFE_GRP1COND14,	0x00000000U},
+	/* Safety group 0 attribute setting for slave ports 15 */
+	{SAFE_GRP0COND15,	0x00000000U},
+	/* Safety group 1 attribute setting for slave ports 15 */
+	{SAFE_GRP1COND15,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 0 */
+	{SAFE_READONLY0,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 1 */
+	{SAFE_READONLY1,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 2 */
+	{SAFE_READONLY2,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 3 */
+	{SAFE_READONLY3,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 4 */
+	{SAFE_READONLY4,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 5 */
+	{SAFE_READONLY5,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 6 */
+	{SAFE_READONLY6,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 7 */
+	{SAFE_READONLY7,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 8 */
+	{SAFE_READONLY8,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 9 */
+	{SAFE_READONLY9,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 10 */
+	{SAFE_READONLY10,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 11 */
+	{SAFE_READONLY11,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 12 */
+	{SAFE_READONLY12,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 13 */
+	{SAFE_READONLY13,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 14 */
+	{SAFE_READONLY14,	0x00000000U},
+	/* Safety write protection attribute setting for slave ports 15 */
+	{SAFE_READONLY15,	0x00000000U}
+};
+
+static const reg_setting_t axi_reg_setting[] = {
+
+	/* AXI settings */
+
+	/* DRAM protection */
+
+	/* AXI dram protected area division 0 */
+	{AXI_DPTDIVCR0,		0xEE0407E0U},
+	/* AXI dram protected area division 1 */
+	{AXI_DPTDIVCR1,		0xEE080000U},
+	/* AXI dram protected area division 2 */
+	{AXI_DPTDIVCR2,		0xEE080000U},
+	/* AXI dram protected area division 3 */
+	{AXI_DPTDIVCR3,		0xEE080000U},
+	/* AXI dram protected area division 4 */
+	{AXI_DPTDIVCR4,		0xEE080000U},
+	/* AXI dram protected area division 5 */
+	{AXI_DPTDIVCR5,		0xEE080000U},
+	/* AXI dram protected area division 6 */
+	{AXI_DPTDIVCR6,		0xEE080000U},
+	/* AXI dram protected area division 7 */
+	{AXI_DPTDIVCR7,		0xEE080000U},
+	/* AXI dram protected area division 8 */
+	{AXI_DPTDIVCR8,		0xEE080000U},
+	/* AXI dram protected area division 9 */
+	{AXI_DPTDIVCR9,		0xEE080000U},
+	/* AXI dram protected area division 10 */
+	{AXI_DPTDIVCR10,	0xEE080000U},
+	/* AXI dram protected area division 11 */
+	{AXI_DPTDIVCR11,	0xEE080000U},
+	/* AXI dram protected area division 12 */
+	{AXI_DPTDIVCR12,	0xEE080000U},
+	/* AXI dram protected area division 13 */
+	{AXI_DPTDIVCR13,	0xEE080000U},
+	/* AXI dram protected area division 14 */
+	{AXI_DPTDIVCR14,	0xEE080000U},
+
+	/* AXI dram protected area setting 0 */
+	{AXI_DPTCR0,		0xEE00EEEEU},
+	/* AXI dram protected area setting 1 */
+	{AXI_DPTCR1,		0xEE000000U},
+	/* AXI dram protected area setting 2 */
+	{AXI_DPTCR2,		0xEE000000U},
+	/* AXI dram protected area setting 3 */
+	{AXI_DPTCR3,		0xEE000000U},
+	/* AXI dram protected area setting 4 */
+	{AXI_DPTCR4,		0xEE000000U},
+	/* AXI dram protected area setting 5 */
+	{AXI_DPTCR5,		0xEE000000U},
+	/* AXI dram protected area setting 6 */
+	{AXI_DPTCR6,		0xEE000000U},
+	/* AXI dram protected area setting 7 */
+	{AXI_DPTCR7,		0xEE000000U},
+	/* AXI dram protected area setting 8 */
+	{AXI_DPTCR8,		0xEE000000U},
+	/* AXI dram protected area setting 9 */
+	{AXI_DPTCR9,		0xEE000000U},
+	/* AXI dram protected area setting 10 */
+	{AXI_DPTCR10,		0xEE000000U},
+	/* AXI dram protected area setting 11 */
+	{AXI_DPTCR11,		0xEE000000U},
+	/* AXI dram protected area setting 12 */
+	{AXI_DPTCR12,		0xEE000000U},
+	/* AXI dram protected area setting 13 */
+	{AXI_DPTCR13,		0xEE000000U},
+	/* AXI dram protected area setting 14 */
+	{AXI_DPTCR14,		0xEE000000U},
+	/* AXI dram protected area setting 15 */
+	{AXI_DPTCR15,		0xEE000000U}
+
+#if 0
+	/* SRAM ptotection */
+	,
+	/* AXI sram protected area division 0 */
+	{AXI_SPTDIVCR0,		0xEE0E6330U},
+	/* AXI sram protected area division 1 */
+	{AXI_SPTDIVCR1,		0xEE0E6360U},
+	/* AXI sram protected area division 2 */
+	{AXI_SPTDIVCR2,		0xEE0E6360U},
+	/* AXI sram protected area division 3 */
+	{AXI_SPTDIVCR3,		0xEE0E6360U},
+	/* AXI sram protected area division 4 */
+	{AXI_SPTDIVCR4,		0xEE0E6360U},
+	/* AXI sram protected area division 5 */
+	{AXI_SPTDIVCR5,		0xEE0E6360U},
+	/* AXI sram protected area division 6 */
+	{AXI_SPTDIVCR6,		0xEE0E6360U},
+	/* AXI sram protected area division 7 */
+	{AXI_SPTDIVCR7,		0xEE0E6360U},
+	/* AXI sram protected area division 8 */
+	{AXI_SPTDIVCR8,		0xEE0E6360U},
+	/* AXI sram protected area division 9 */
+	{AXI_SPTDIVCR9,		0xEE0E6360U},
+	/* AXI sram protected area division 10 */
+	{AXI_SPTDIVCR10,	0xEE0E6360U},
+	/* AXI sram protected area division 11 */
+	{AXI_SPTDIVCR11,	0xEE0E6360U},
+	/* AXI sram protected area division 12 */
+	{AXI_SPTDIVCR12,	0xEE0E6360U},
+	/* AXI sram protected area division 13 */
+	{AXI_SPTDIVCR13,	0xEE0E6360U},
+	/* AXI sram protected area division 14 */
+	{AXI_SPTDIVCR14,	0xEE0E6360U},
+
+	/* AXI sram protected area setting 0 */
+	{AXI_SPTCR0,		0xEE00EEEEU},
+	/* AXI sram protected area setting 1 */
+	{AXI_SPTCR1,		0xEE000000U},
+	/* AXI sram protected area setting 2 */
+	{AXI_SPTCR2,		0xEE000000U},
+	/* AXI sram protected area setting 3 */
+	{AXI_SPTCR3,		0xEE000000U},
+	/* AXI sram protected area setting 4 */
+	{AXI_SPTCR4,		0xEE000000U},
+	/* AXI sram protected area setting 5 */
+	{AXI_SPTCR5,		0xEE000000U},
+	/* AXI sram protected area setting 6 */
+	{AXI_SPTCR6,		0xEE000000U},
+	/* AXI sram protected area setting 7 */
+	{AXI_SPTCR7,		0xEE000000U},
+	/* AXI sram protected area setting 8 */
+	{AXI_SPTCR8,		0xEE000000U},
+	/* AXI sram protected area setting 9 */
+	{AXI_SPTCR9,		0xEE000000U},
+	/* AXI sram protected area setting 10 */
+	{AXI_SPTCR10,		0xEE000000U},
+	/* AXI sram protected area setting 11 */
+	{AXI_SPTCR11,		0xEE000000U},
+	/* AXI sram protected area setting 12 */
+	{AXI_SPTCR12,		0xEE000000U},
+	/* AXI sram protected area setting 13 */
+	{AXI_SPTCR13,		0xEE000000U},
+	/* AXI sram protected area setting 14 */
+	{AXI_SPTCR14,		0xEE000000U},
+	/* AXI sram protected area setting 15 */
+	{AXI_SPTCR15,		0xEE000000U}
+#endif
+};
+
+void bl2_secure_setting(void)
+{
+#if 0	/* TEST */
+	uint32_t		i, ie;
+	const reg_setting_t	*reg_setting;
+
+	reg_setting = &lifec_reg_setting[0];
+	i = 0;
+	ie = sizeof(*reg_setting) / sizeof(reg_setting_t);
+	for (; i < ie; i++) {
+		mmio_write_32(reg_setting[i].adr, reg_setting[i].val);
+	}
+
+	reg_setting = &axi_reg_setting[0];
+	i = 0;
+	ie = sizeof(*reg_setting) / sizeof(reg_setting_t);
+	for (; i < ie; i++) {
+		mmio_write_32(reg_setting[i].adr, reg_setting[i].val);
+	}
+#endif	/* TEST */
+}
diff --git a/plat/renesas/rcar/bl31_rcar_setup.c b/plat/renesas/rcar/bl31_rcar_setup.c
new file mode 100644
index 0000000..f8e68d2
--- /dev/null
+++ b/plat/renesas/rcar/bl31_rcar_setup.c
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <assert.h>
+#include <bl_common.h>
+#include <bl31.h>
+#include <console.h>
+#include <mmio.h>
+#include <platform.h>
+#include <stddef.h>
+#include <debug.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+#include "rcar_def.h"
+#include "rcar_private.h"
+#include "rcar_version.h"
+
+#define	CHECK_MD13_MD14		(0x6000U)
+#define	FREQ_10M		(0x2000U)
+#define	FREQ_12_5M		(0x4000U)
+#define	FREQ_8_33M		(0x0000U)
+#define	FREQ_16_66M		(0x6000U)
+
+/*******************************************************************************
+ * Declarations of linker defined symbols which will help us find the layout
+ * of trusted SRAM
+ ******************************************************************************/
+extern unsigned long __RO_START__;
+extern unsigned long __RO_END__;
+extern unsigned long __BL31_END__;
+
+#if USE_COHERENT_MEM
+extern unsigned long __COHERENT_RAM_START__;
+extern unsigned long __COHERENT_RAM_END__;
+#endif
+
+/*
+ * The next 3 constants identify the extents of the code, RO data region and the
+ * limit of the BL3-1 image.  These addresses are used by the MMU setup code and
+ * therefore they must be page-aligned.  It is the responsibility of the linker
+ * script to ensure that __RO_START__, __RO_END__ & __BL31_END__ linker symbols
+ * refer to page-aligned addresses.
+ */
+#define BL31_RO_BASE (uint64_t)(&__RO_START__)
+#define BL31_RO_LIMIT (uint64_t)(&__RO_END__)
+#define BL31_END (uint64_t)(&__BL31_END__)
+
+#if USE_COHERENT_MEM
+/*
+ * The next 2 constants identify the extents of the coherent memory region.
+ * These addresses are used by the MMU setup code and therefore they must be
+ * page-aligned.  It is the responsibility of the linker script to ensure that
+ * __COHERENT_RAM_START__ and __COHERENT_RAM_END__ linker symbols
+ * refer to page-aligned addresses.
+ */
+#define BL31_COHERENT_RAM_BASE (uint64_t)(&__COHERENT_RAM_START__)
+#define BL31_COHERENT_RAM_LIMIT (uint64_t)(&__COHERENT_RAM_END__)
+#endif
+
+#if RESET_TO_BL31
+static entry_point_info_t bl32_image_ep_info;
+static entry_point_info_t bl33_image_ep_info;
+#else
+/*******************************************************************************
+ * Reference to structure which holds the arguments that have been passed to
+ * BL31 from BL2.
+ ******************************************************************************/
+static bl31_params_t *bl2_to_bl31_params;
+#endif
+
+/* Array of secure interrupts to be configured by the gic driver */
+const unsigned int irq_sec_array[] = {
+	ARM_IRQ_SEC_PHY_TIMER,		/* 29		*/
+	ARM_IRQ_SEC_SGI_0,		/* 8		*/
+	ARM_IRQ_SEC_SGI_1,		/* 9		*/
+	ARM_IRQ_SEC_SGI_2,		/* 10		*/
+	ARM_IRQ_SEC_SGI_3,		/* 11		*/
+	ARM_IRQ_SEC_SGI_4,		/* 12		*/
+	ARM_IRQ_SEC_SGI_5,		/* 13		*/
+	ARM_IRQ_SEC_SGI_6,		/* 14		*/
+	ARM_IRQ_SEC_SGI_7,		/* 15		*/
+	ARM_IRQ_SEC_RPC,		/* 70		*/
+	ARM_IRQ_SEC_TIMER,		/* 166		*/
+	ARM_IRQ_SEC_TIMER_UP,		/* 171		*/
+	ARM_IRQ_SEC_WDT,		/* 173		*/
+	ARM_IRQ_SEC_CRYPT,		/* 102		*/
+	ARM_IRQ_SEC_CRYPT_SecPKA,	/* 97		*/
+	ARM_IRQ_SEC_CRYPT_PubPKA	/* 98		*/
+};
+
+uint32_t rcar_boot_kind_flag __attribute__((section("data")));
+
+/*******************************************************************************
+ * Return a pointer to the 'entry_point_info' structure of the next image for the
+ * security state specified. BL33 corresponds to the non-secure image type
+ * while BL32 corresponds to the secure image type. A NULL pointer is returned
+ * if the image does not exist.
+ ******************************************************************************/
+entry_point_info_t *bl31_plat_get_next_image_ep_info(uint32_t type)
+{
+	entry_point_info_t *next_image_info;
+
+	assert(sec_state_is_valid(type));
+
+	next_image_info =
+			(type == NON_SECURE) ?
+					bl2_to_bl31_params->bl33_ep_info :
+					bl2_to_bl31_params->bl32_ep_info;
+
+	/* None of the images on this platform can have 0x0 as the entrypoint */
+	if (next_image_info->pc)
+		return next_image_info;
+	else
+		return NULL;
+}
+
+/*******************************************************************************
+ * Perform any BL31 specific platform actions. Here is an opportunity to copy
+ * parameters passed by the calling EL (S-EL1 in BL2) before they
+ * are lost (potentially). This needs to be done before the MMU is initialized
+ * so that the memory layout can be used while creating page tables. On the RCAR
+ * we know that BL2 has populated the parameters. So we just use
+ * the reference passed in 'from_bl2' instead of copying. The 'data' parameter
+ * is not used since all the information is contained in 'from_bl2'. Also, BL2
+ * has flushed this information to memory, so we are guaranteed to pick up good
+ * data
+ ******************************************************************************/
+void bl31_early_platform_setup(bl31_params_t *from_bl2,
+		void *plat_params_from_bl2)
+{
+	uint32_t chk_data;
+	uint32_t freq_data;
+	uint32_t product_cut = mmio_read_32((uintptr_t)RCAR_PRR)
+				& (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+
+	/*
+	 * Set frequency data to CNTFID0
+	 */
+	chk_data = mmio_read_32((uintptr_t)RCAR_MODEMR) & CHECK_MD13_MD14;
+	switch (chk_data) {
+	case FREQ_8_33M:
+		freq_data = 8333300U; /* 8.33MHz	*/
+		break;
+	case FREQ_10M:
+		freq_data = 10000000U; /* 10MHz	*/
+		break;
+	case FREQ_12_5M:
+		freq_data = 12500000U; /* 12.5MHz	*/
+		break;
+	case FREQ_16_66M:
+		freq_data = 16666600U; /* 16.66MHz	*/
+		if (product_cut == (RCAR_PRODUCT_H3 | RCAR_CUT_ES10)) {
+			freq_data = freq_data >> 1;
+		}
+		break;
+	default:
+		freq_data = 0U;
+		break;
+	}
+	mmio_write_32(RCAR_CNTC_BASE + CNTFID_OFF, freq_data);
+
+	/* Initialize the log area to provide early debug support */
+	console_init(1U, 0U, 0U);
+
+	NOTICE("BL3-1 : Rev.%s\n",version_of_renesas);
+
+	/* Check params passed from BL2 should not be NULL,
+	 * We are not checking plat_params_from_bl2 as NULL as we are not
+	 * using it on RCAR
+	 */
+	assert(from_bl2 != NULL);
+	assert(from_bl2->h.type == PARAM_BL31);
+	assert(from_bl2->h.version >= VERSION_1);
+
+	bl2_to_bl31_params = from_bl2;
+
+	/*
+	 * Initialize CCI for this cluster during cold boot.
+	 * No need for locks as no other CPU is active.
+	 */
+	rcar_cci_init();
+	/*
+	 * Enable CCI coherency for the primary CPU's cluster
+	 * RCAR PSCI code will enable coherency for other clusters.
+	 */
+	rcar_cci_enable();
+
+}
+
+/*******************************************************************************
+ * Initialize the gic, configure the CLCD and zero out variables needed by the
+ * secondaries to boot up correctly.
+ ******************************************************************************/
+void bl31_platform_setup(void)
+{
+
+	/* Initialize the gic cpu and distributor interfaces */
+	arm_gic_init(RCAR_GICC_BASE, RCAR_GICD_BASE, RCAR_GICR_BASE,
+			irq_sec_array, ARRAY_SIZE(irq_sec_array));
+	arm_gic_setup();
+
+	/* Enable and initialize the System level generic timer */
+	mmio_write_32(RCAR_CNTC_BASE + CNTCR_OFF, CNTCR_FCREQ(0) | CNTCR_EN);
+
+	/* Intialize the power controller */
+	rcar_pwrc_setup();
+
+	/* Topologies are best known to the platform. */
+	rcar_setup_topology();
+}
+
+/*******************************************************************************
+ * Perform the very early platform specific architectural setup here. At the
+ * moment this is only intializes the mmu in a quick and dirty way.
+ ******************************************************************************/
+void bl31_plat_arch_setup(void)
+{
+	rcar_configure_mmu_el3(BL31_RO_BASE, (BL31_END - BL31_RO_BASE),
+			BL31_RO_BASE,
+			BL31_RO_LIMIT
+#if USE_COHERENT_MEM
+			, BL31_COHERENT_RAM_BASE,
+			BL31_COHERENT_RAM_LIMIT
+#endif
+	);
+
+}
diff --git a/plat/renesas/rcar/drivers/auth/rcarboot.c b/plat/renesas/rcar/drivers/auth/rcarboot.c
new file mode 100644
index 0000000..92872a2
--- /dev/null
+++ b/plat/renesas/rcar/drivers/auth/rcarboot.c
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+
+#include <assert.h>
+#include <auth_mod.h>
+#include <debug.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <mmio.h>
+
+#include "rcarboot.h"
+
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+#define RCAR_BOOT_KEY_CERT	(0xE6300C00U)
+#elif RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CR7
+#define RCAR_BOOT_KEY_CERT	(0xE6300400U)
+#endif
+#if RCAR_LSI == RCAR_H3
+#define RCAR_SBROM_API		(0xeb10dd64U)
+#elif RCAR_LSI == RCAR_M3
+#define RCAR_SBROM_API		(0xeb1102fcU)
+#endif
+#define	RST_BASE		(0xE6160000U)
+#define	RST_MODEMR		(RST_BASE + 0x0060U)
+#define LIFEC_CC_LCS		(0xE6110028U)		/* cc_lcs  Life cycle state read */
+#define	MFISSOFTMDR		(0xE6260600U)		/* SOFTMD register */
+
+static SECURE_BOOT_API	sbrom_SecureBootAPI;
+
+#if !RCAR_SECURE_BOOT
+static int32_t local_verify(uint32_t a, uint32_t b, void *c);
+#endif
+
+/*
+ * Return the parent id in the output parameter '*parent_id'
+ *
+ * Return value:
+ *   0 = Image has parent, 1 = Image has no parent or parent is authenticated
+ */
+int auth_mod_get_parent_id(unsigned int img_id, unsigned int *parent_id)
+{
+	return 1;
+}
+
+/*
+ * Authenticate a certificate/image
+ *
+ * Return: 0 = success, Otherwise = error
+ */
+int auth_mod_verify_img(unsigned int img_id, void *img_ptr,
+			unsigned int img_len)
+{
+	int32_t ret = 0;
+	uint32_t cert_addr;
+
+	switch (img_id) {
+#if IMAGE_BL2
+	case (uint32_t)TRUSTED_KEY_CERT_ID:
+	case (uint32_t)BL31_KEY_CERT_ID:
+	case (uint32_t)BL32_KEY_CERT_ID:
+	case (uint32_t)BL33_KEY_CERT_ID:
+	case (uint32_t)BL332_KEY_CERT_ID:
+	case (uint32_t)BL333_KEY_CERT_ID:
+	case (uint32_t)BL334_KEY_CERT_ID:
+	case (uint32_t)BL335_KEY_CERT_ID:
+	case (uint32_t)BL336_KEY_CERT_ID:
+	case (uint32_t)BL337_KEY_CERT_ID:
+	case (uint32_t)BL338_KEY_CERT_ID:
+	case (uint32_t)BL31_CERT_ID:
+	case (uint32_t)BL32_CERT_ID:
+	case (uint32_t)BL33_CERT_ID:
+	case (uint32_t)BL332_CERT_ID:
+	case (uint32_t)BL333_CERT_ID:
+	case (uint32_t)BL334_CERT_ID:
+	case (uint32_t)BL335_CERT_ID:
+	case (uint32_t)BL336_CERT_ID:
+	case (uint32_t)BL337_CERT_ID:
+	case (uint32_t)BL338_CERT_ID:
+		/* no check */
+		break;
+	case (uint32_t)BL31_IMAGE_ID:
+		ret = file_to_cert(BL31_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL31\n", ret);
+			}
+		}
+		break;
+	case (uint32_t)BL32_IMAGE_ID:
+		ret = file_to_cert(BL32_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL32\n", ret);
+			}
+		}
+		break;
+	case (uint32_t)BL33_IMAGE_ID:
+		ret = file_to_cert(BL33_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL33\n", ret);
+			}
+		}
+		break;
+	case (uint32_t)BL332_IMAGE_ID:
+		ret = file_to_cert(BL332_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL332\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL333_IMAGE_ID:
+		ret = file_to_cert(BL333_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL333\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL334_IMAGE_ID:
+		ret = file_to_cert(BL334_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL334\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL335_IMAGE_ID:
+		ret = file_to_cert(BL335_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL335\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL336_IMAGE_ID:
+		ret = file_to_cert(BL336_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL336\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL337_IMAGE_ID:
+		ret = file_to_cert(BL337_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL337\n", ret);
+			} 
+		}
+		break;
+	case (uint32_t)BL338_IMAGE_ID:
+		ret = file_to_cert(BL338_CERT_ID, &cert_addr);
+		if (0 == ret) {
+			ret = sbrom_SecureBootAPI(RCAR_BOOT_KEY_CERT, cert_addr, NULL);
+			if (0 != ret) {
+				ERROR("Verification Failed!!! 0x%x -> BL338\n", ret);
+			} 
+		}
+		break;
+#endif /* IMAGE_BL2 */
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+static int32_t local_verify(uint32_t a, uint32_t b, void *c)
+{
+	return 0;
+}
+
+/*
+ * Initialize the different modules in the authentication framework
+ */
+void auth_mod_init(void)
+{
+#if RCAR_SECURE_BOOT
+	uint32_t lcs = (mmio_read_32(LIFEC_CC_LCS) & 0x000000F0U) >> 4;
+	uint32_t md = (mmio_read_32(RST_MODEMR) & 0x00000020U) >> 5;
+	uint32_t softmd = (mmio_read_32(MFISSOFTMDR) & 0x00000001U);
+
+	/* default is Secure boot */
+	sbrom_SecureBootAPI = (SECURE_BOOT_API)RCAR_SBROM_API;
+
+	if (lcs == 0x5U) { /* LCS=Secure */
+		if (softmd == 0x1U) {
+			sbrom_SecureBootAPI = &local_verify; /* LCS=Secure + Normal boot (temp setting) */
+		}  /* else is LCS=Secure + Secure boot */
+	} else if (md != 0U) {
+		sbrom_SecureBootAPI = &local_verify; /* MD5=1 => LCS=CM/DM + Normal boot */
+	} /* else is MD5=0 => LCS=CM/DM + Secure boot */
+
+	if (sbrom_SecureBootAPI == &local_verify) {
+		NOTICE("BL2: Normal boot\n");
+	} else {
+		NOTICE("BL2: Secure boot\n");
+	}
+#else
+	sbrom_SecureBootAPI = &local_verify;
+	NOTICE("BL2: Normal boot\n");
+#endif
+}
diff --git a/plat/renesas/rcar/drivers/auth/rcarboot.h b/plat/renesas/rcar/drivers/auth/rcarboot.h
new file mode 100644
index 0000000..2d015ca
--- /dev/null
+++ b/plat/renesas/rcar/drivers/auth/rcarboot.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_RCARBOOT_H_
+#define RCAR_RCARBOOT_H_
+
+/* Define */
+typedef int32_t (*SECURE_BOOT_API)(uint32_t a, uint32_t b, void *c);
+
+/* Prototype */
+extern int32_t file_to_cert(const int32_t filename, uint32_t *cert_addr);
+
+#endif /* RCAR_RCARBOOT_H_ */
diff --git a/plat/renesas/rcar/drivers/avs/avs_driver.c b/plat/renesas/rcar/drivers/avs/avs_driver.c
new file mode 100644
index 0000000..415d670
--- /dev/null
+++ b/plat/renesas/rcar/drivers/avs/avs_driver.c
@@ -0,0 +1,654 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <mmio.h>
+#include <debug.h>
+#include "bl2_cpg_init.h"
+#include "bl2_cpg_register.h"
+#include "avs_driver.h"
+
+#if AVS_SETTING_ENABLE == 1
+/* Read PMIC register for debug. 1:enable / 0:disable */
+#define AVS_READ_PMIC_REG_ENABLE	0
+/* The re-try number of times of the AVS setting. */
+#define AVS_RETRY_NUM			(1U)
+
+/* Base address of ADVFS Module registers*/
+#define	ADVFS_BASE			(0xE60A0000U)
+/* Register address in eFuse indicates individual R-Car information */
+#define	ADVFS_KSEN_ADJCNTS		(ADVFS_BASE + 0x013CU)
+
+/* Mask VOLCOND bit in KSEN_ADJCNTS registers */
+#define	KSEN_ADJCNTS_VOLCOND_MASK	(0x0000000FU)
+#define	VOLCOND_INVALID_VAL		(0x7U)	/* Invalid value */
+#define	VOLCOND_CANCEL_BIT		(0x8U)	/* Cancel bit */
+
+/* Mode Monitor Register */
+#define	RCAR_MODEMR			(0xE6160060U)	/* Mode pin register */
+#define MODEMR_MD13			(0x2000U)	/* MD13 bit mask */
+#define MODEMR_MD14			(0x4000U)	/* MD14 bit mask */
+/* CP Phy input frequency */
+#define	CP_PHY_FREQ_8p33M		(0x0000U)	/* 8.3333MHz */
+#define	CP_PHY_FREQ_10M			(0x2000U)	/* 10MHz */
+#define	CP_PHY_FREQ_12p5M		(0x4000U)	/* 12.5MHz */
+#define	CP_PHY_FREQ_16p66M		(0x6000U)	/* 16.6666MHz */
+
+/* I2C for DVFS bit in CPG registers for module standby and software reset*/
+#define CPG_SYS_DVFS_BIT		(0x04000000U)
+/* ADVFS Module bit in CPG registers for module standby and software reset*/
+#define CPG_SYS_ADVFS_BIT		(0x02000000U)
+
+/* Base address of IICDVFS registers*/
+#define	IIC_DVFS_BASE			(0xE60B0000U)
+/* IIC bus data register */
+#define	IIC_ICDR			(IIC_DVFS_BASE + 0x0000U)
+/* IIC bus control register */
+#define	IIC_ICCR			(IIC_DVFS_BASE + 0x0004U)
+/* IIC bus status register */
+#define	IIC_ICSR			(IIC_DVFS_BASE + 0x0008U)
+/* IIC interrupt control register */
+#define	IIC_ICIC			(IIC_DVFS_BASE + 0x000CU)
+/* IIC clock control register low */
+#define	IIC_ICCL			(IIC_DVFS_BASE + 0x0010U)
+/* IIC clock control register high */
+#define	IIC_ICCH			(IIC_DVFS_BASE + 0x0014U)
+
+/* Bit in ICSR register */
+#define ICSR_BUSY			(0x10U)
+#define ICSR_AL				(0x08U)
+#define ICSR_TACK			(0x04U)
+#define ICSR_WAIT			(0x02U)
+#define ICSR_DTE			(0x01U)
+
+/* Bit in ICIC register */
+#define ICIC_TACKE			(0x04U)
+#define ICIC_WAITE			(0x02U)
+#define ICIC_DTEE			(0x01U)
+
+/* I2C bus interface enable */
+#define ICCR_ENABLE			(0x80U)
+/* Start condition */
+#define ICCR_START			(0x94U)
+/* Stop condition */
+#define ICCR_STOP			(0x90U)
+/* Restart condition with change to receive mode change */
+#define ICCR_START_RECV			(0x81U)
+/* Stop condition for receive mode */
+#define ICCR_STOP_RECV			(0xC0U)
+
+/* Low-level period of SCL */
+#define	ICCL_FREQ_8p33M			(0x07U)	/* for CP Phy 8.3333MHz */
+#define	ICCL_FREQ_10M			(0x09U)	/* for CP Phy 10MHz */
+#define	ICCL_FREQ_12p5M			(0x0BU)	/* for CP Phy 12.5MHz */
+#define	ICCL_FREQ_16p66M		(0x0EU)	/* for CP Phy 16.6666MHz */
+/* High-level period of SCL */
+#define	ICCH_FREQ_8p33M			(0x01U)	/* for CP Phy 8.3333MHz */
+#define	ICCH_FREQ_10M			(0x02U)	/* for CP Phy 10MHz */
+#define	ICCH_FREQ_12p5M			(0x03U)	/* for CP Phy 12.5MHz */
+#define	ICCH_FREQ_16p66M		(0x05U)	/* for CP Phy 16.6666MHz */
+
+#define	PMIC_W_SLAVE_ADDRESS		(0x60U)	/* PMIC slave address + (W) */
+#define	PMIC_R_SLAVE_ADDRESS		(0x61U)	/* PMIC slave address + (R) */
+#define	PMIC_DVFS_SETVID		(0x54U)	/* PMIC DVFS SetVID register */
+
+/* Individual information */
+#define EFUSE_AVS0			(0U)
+#define EFUSE_AVS_NUM			(7U)
+static const uint8_t pmic_setvid_reg[EFUSE_AVS_NUM] = {
+		0x52U, /* AVS0 0.82V */
+		0x52U, /* AVS1 0.82V */
+		0x52U, /* AVS2 0.82V */
+		0x4FU, /* AVS3 0.79V */
+		0x4FU, /* AVS4 0.79V */
+		0x4DU, /* AVS5 0.77V */
+		0x4BU  /* AVS6 0.75V */
+};
+
+/* Kind of AVS settings status */
+typedef enum
+{
+		avs_status_none = 0,
+		avs_status_init,
+		avs_status_start_condition,
+		avs_status_set_slave_addr,
+		avs_status_write_reg_addr,
+		avs_status_write_reg_data,
+		avs_status_stop_condition,
+		avs_status_end,
+		avs_status_complete,
+		avs_status_al_start,
+		avs_status_al_transfer,
+		avs_status_nack,
+		avs_status_error_stop,
+		ave_status_error_end
+} avs_status_t;
+
+/* Kind of AVS error */
+typedef enum
+{
+		avs_error_none = 0,
+		avs_error_al,
+		avs_error_nack
+} avs_error_t;
+
+static avs_status_t avs_status = avs_status_none;
+static uint32_t avs_retry = 0U;
+static uint32_t efuse_avs = EFUSE_AVS0;
+
+/* prototype */
+static avs_error_t avs_check_error(void);
+static void avs_set_iic_clock(void);
+#if AVS_READ_PMIC_REG_ENABLE == 1
+static uint8_t avs_read_pmic_reg(uint8_t addr);
+static void avs_poll(uint8_t bit_pos, uint8_t val);
+#endif
+#endif	/* AVS_SETTING_ENABLE */
+
+/*
+ * Initialize to enable the AVS setting.
+ */
+void bl2_avs_init(void)
+{
+#if AVS_SETTING_ENABLE == 1
+	uint32_t val;
+	uint32_t mstp;
+
+	INFO("BL2: AVS setting start. \n");
+
+	/* Initialize AVS status */
+	avs_status = avs_status_init;
+
+	/* Bit of the module which wants to enable clock supply. */
+	mstp = CPG_SYS_DVFS_BIT | CPG_SYS_ADVFS_BIT;
+	/* Enables the clock supply to the CPG. */
+	cpg_write(CPG_SMSTPCR9, mmio_read_32(CPG_SMSTPCR9) & (~mstp));
+	/* Is the clock supply to the CPG disabled ? */
+	while((mmio_read_32(CPG_MSTPSR9) & mstp) != 0U) {
+		/* Enables the clock supply to the CPG. */
+		cpg_write(CPG_SMSTPCR9,
+				mmio_read_32(CPG_SMSTPCR9) & (~mstp));
+	}
+
+	/* Disable I2C module and All internal registers initialized. */
+	mmio_write_8(IIC_ICCR, 0x00U);
+	while ((mmio_read_8(IIC_ICCR) & ICCR_ENABLE) != 0U) {
+		/* Disable I2C module and All internal registers initialized. */
+		mmio_write_8(IIC_ICCR, 0x00U);
+	}
+
+	/* Read eFuse indicates individual R-Car information */
+	val = mmio_read_32(ADVFS_KSEN_ADJCNTS) & KSEN_ADJCNTS_VOLCOND_MASK;
+
+	if ((val == VOLCOND_INVALID_VAL)
+			|| ((val & VOLCOND_CANCEL_BIT) == VOLCOND_CANCEL_BIT)) {
+		efuse_avs = EFUSE_AVS0;
+	} else {
+		efuse_avs = val;
+	}
+
+	/* Set next status */
+	avs_status = avs_status_start_condition;
+
+	INFO("BL2: Read KSEN_ADJCNTS.VOLCOND=0x%x efuse_avs=%u\n",
+		val, efuse_avs);
+#endif	/* AVS_SETTING_ENABLE */
+}
+
+/*
+ * Set the value of register corresponding to the voltage
+ * by transfer of I2C to PIMC.
+ */
+void bl2_avs_setting(void)
+{
+#if AVS_SETTING_ENABLE == 1
+	avs_error_t err;
+
+	INFO("BL2: bl2_avs_setting avs_status=%d\n", avs_status);
+
+	switch (avs_status) {
+	case avs_status_start_condition:
+		/* Set ICCR.ICE=1 to activate the I2C module. */
+		mmio_write_8(IIC_ICCR, mmio_read_8(IIC_ICCR) | ICCR_ENABLE);
+		/* Set frequency of 400kHz */
+		avs_set_iic_clock();
+		/* Set ICIC.TACKE=1, ICIC.WAITE=1, ICIC.DTEE=1 to */
+		/* enable interrupt control. 			  */
+		mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC)
+				| ICIC_TACKE | ICIC_WAITE | ICIC_DTEE);
+		/* Write H'94 in ICCR to issue start condition */
+		mmio_write_8(IIC_ICCR, ICCR_START);
+		/* Set next status */
+		avs_status = avs_status_set_slave_addr;
+		break;
+	case avs_status_set_slave_addr:
+		/* Check error. */
+		err = avs_check_error();
+		if (err == avs_error_al) {
+			/* Recovery sequence of just after start. */
+			avs_status = avs_status_al_start;
+		} else if (err == avs_error_nack) {
+			/* Recovery sequence of detected NACK */
+			avs_status = avs_status_nack;
+		} else {
+			/* Was data transmission enabled ? */
+			if ((mmio_read_8(IIC_ICSR) & ICSR_DTE) == ICSR_DTE) {
+				/* Clear ICIC.DTEE to disable a DTE interrupt */
+				mmio_write_8(IIC_ICIC,
+					mmio_read_8(IIC_ICIC)
+						& (uint8_t)(~ICIC_DTEE));
+				/* Send PMIC slave address + (W) */
+				mmio_write_8(IIC_ICDR, PMIC_W_SLAVE_ADDRESS);
+				/* Set next status */
+				avs_status = avs_status_write_reg_addr;
+			}
+		}
+		break;
+	case avs_status_write_reg_addr:
+		/* Check error. */
+		err = avs_check_error();
+		if (err == avs_error_al) {
+			/* Recovery sequence of during data transfer. */
+			avs_status = avs_status_al_transfer;
+		} else if (err == avs_error_nack) {
+			/* Recovery sequence of detected NACK */
+			avs_status = avs_status_nack;
+		} else {
+			/* If wait state after data transmission. */
+			if ((mmio_read_8(IIC_ICSR) & ICSR_WAIT) == ICSR_WAIT) {
+				/* Write PMIC DVFS_SetVID address */
+				mmio_write_8(IIC_ICDR, PMIC_DVFS_SETVID);
+				/* Clear ICSR.WAIT to exit from wait state. */
+				mmio_write_8(IIC_ICSR,
+					mmio_read_8(IIC_ICSR)
+						& (uint8_t)(~ICSR_WAIT));
+				/* Set next status */
+				avs_status = avs_status_write_reg_data;
+			}
+		}
+		break;
+	case avs_status_write_reg_data:
+		/* Check error. */
+		err = avs_check_error();
+		if (err == avs_error_al) {
+			/* Recovery sequence of during data transfer. */
+			avs_status = avs_status_al_transfer;
+		} else if (err == avs_error_nack) {
+			/* Recovery sequence of detected NACK */
+			avs_status = avs_status_nack;
+		} else {
+			/* If wait state after data transmission. */
+			if ((mmio_read_8(IIC_ICSR) & ICSR_WAIT) == ICSR_WAIT) {
+				/* Dose efuse_avs exceed the number of */
+				/* the tables? */
+				if (efuse_avs >= EFUSE_AVS_NUM) {
+					ERROR("BL2: AVS number of eFuse is out "
+						"of a range. number=%u\n",
+						 efuse_avs);
+					/* Infinite loop */
+					panic();
+				}
+				/* Write PMIC DVFS_SetVID value */
+				mmio_write_8(IIC_ICDR,
+						pmic_setvid_reg[efuse_avs]);
+				/* Clear ICSR.WAIT to exit from wait state. */
+				mmio_write_8(IIC_ICSR,
+					mmio_read_8(IIC_ICSR)
+						& (uint8_t)(~ICSR_WAIT));
+				/* Set next status */
+				avs_status = avs_status_stop_condition;
+			}
+		}
+		break;
+	case avs_status_stop_condition:
+		err = avs_check_error();
+		if (err == avs_error_al) {
+			/* Recovery sequence of during data transfer. */
+			avs_status = avs_status_al_transfer;
+		} else if (err == avs_error_nack) {
+			/* Recovery sequence of detected NACK */
+			avs_status = avs_status_nack;
+		} else {
+			/* If wait state after data transmission. */
+			if ((mmio_read_8(IIC_ICSR) & ICSR_WAIT) == ICSR_WAIT) {
+				/* Write H'90 in ICCR to issue stop condition */
+				mmio_write_8(IIC_ICCR, ICCR_STOP);
+				/* Clear ICSR.WAIT to exit from wait state. */
+				mmio_write_8(IIC_ICSR,
+					mmio_read_8(IIC_ICSR)
+						& (uint8_t)(~ICSR_WAIT));
+				/* Set next status */
+				avs_status = avs_status_end;
+			}
+		}
+		break;
+	case avs_status_end:
+		/* Is this module not busy?. */
+		if ((mmio_read_8(IIC_ICSR) & ICSR_BUSY) == 0U) {
+			/* Set ICCR=H'00 to disable the I2C module. */
+			mmio_write_8(IIC_ICCR, 0x00U);
+			/* Set next status */
+			avs_status = avs_status_complete;
+		}
+		break;
+	case avs_status_al_start:
+		/* Clear ICSR.AL bit */
+		mmio_write_8(IIC_ICSR,
+				(mmio_read_8(IIC_ICSR)
+					& (uint8_t)(~ICSR_AL)));
+		/* Transmit a clock pulse */
+		mmio_write_8(IIC_ICDR, pmic_setvid_reg[EFUSE_AVS0]);
+		/* Set next status */
+		avs_status = avs_status_error_stop;
+		break;
+	case avs_status_al_transfer:
+		/* Clear ICSR.AL bit */
+		mmio_write_8(IIC_ICSR,
+				(mmio_read_8(IIC_ICSR)
+					& (uint8_t)(~ICSR_AL)));
+		/* Set next status */
+		avs_status = avs_status_error_stop;
+		break;
+	case avs_status_nack:
+		/* Write H'90 in ICCR to issue stop condition */
+		mmio_write_8(IIC_ICCR, ICCR_STOP);
+		/* Disable a WAIT and DTEE interrupt. */
+		mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC)
+				& (uint8_t)(~(ICIC_WAITE | ICIC_DTEE)));
+		/* Clear ICSR.TACK bit */
+		mmio_write_8(IIC_ICSR, mmio_read_8(IIC_ICSR)
+				& (uint8_t)(~ICSR_TACK));
+		/* Set next status */
+		avs_status = ave_status_error_end;
+		break;
+	case avs_status_error_stop:
+		/* If wait state after data transmission. */
+		if ((mmio_read_8(IIC_ICSR) & ICSR_WAIT) == ICSR_WAIT) {
+			/* Write H'90 in ICCR to issue stop condition */
+			mmio_write_8(IIC_ICCR, ICCR_STOP);
+			/* Clear ICSR.WAIT to exit from wait state. */
+			mmio_write_8(IIC_ICSR,
+					mmio_read_8(IIC_ICSR)
+						& (uint8_t)(~ICSR_WAIT));
+			/* Set next status */
+			avs_status = ave_status_error_end;
+		}
+		break;
+	case ave_status_error_end:
+		/* Is this module not busy?. */
+		if ((mmio_read_8(IIC_ICSR) & ICSR_BUSY) == 0U) {
+			/* Set ICCR=H'00 to disable the I2C module. */
+			mmio_write_8(IIC_ICCR, 0x00U);
+			/* Increment the re-try number of times. */
+			avs_retry++;
+			/* Set start a re-try to status. */
+			avs_status = avs_status_start_condition;
+		}
+		break;
+	case avs_status_complete:
+		/* After "avs_status" became the "avs_status_complete", */
+		/* "bl2_avs_setting()" function may be called. */
+		break;
+	default:
+		/* This case is not possible. */
+		ERROR("BL2: AVS setting is in invalid status. status=%u\n",
+			avs_status);
+		/* Infinite loop */
+		panic();
+		break;
+	}
+#endif	/* AVS_SETTING_ENABLE */
+}
+
+/*
+ * Finish the AVS setting.
+ */
+void bl2_avs_end(void)
+{
+#if AVS_SETTING_ENABLE == 1
+	uint32_t mstp;
+
+	INFO("BL2: bl2_avs_end avs_status=%d\n", avs_status);
+
+	/* While status is not completion, be repeated. */
+	while (avs_status != avs_status_complete) {
+		bl2_avs_setting();
+	}
+	NOTICE("BL2: AVS setting succeeded. DVFS_SetVID=0x%x\n",
+			pmic_setvid_reg[efuse_avs]);
+
+#if AVS_READ_PMIC_REG_ENABLE == 1
+	{
+		uint8_t addr = PMIC_DVFS_SETVID;
+		uint8_t value;
+		value = avs_read_pmic_reg(addr);
+		NOTICE("BL2: Read PMIC register. address=0x%x value=0x%x \n",
+				addr, value);
+	}
+#endif
+
+	/* Bit of the module which wants to disable clock supply. */
+	mstp = CPG_SYS_DVFS_BIT | CPG_SYS_ADVFS_BIT;
+	/* Disables the supply of clock signal to a module. */
+	cpg_write(CPG_SMSTPCR9,
+			mmio_read_32(CPG_SMSTPCR9) | mstp);
+#endif	/* AVS_SETTING_ENABLE */
+}
+
+#if AVS_SETTING_ENABLE == 1
+/*
+ * Check error and judge re-try.
+ */
+static avs_error_t avs_check_error(void)
+{
+	avs_error_t ret;
+
+	INFO("BL2: avs_check_error avs_status=%d\n", avs_status);
+
+	if ((mmio_read_8(IIC_ICSR) & ICSR_AL) == ICSR_AL) {
+		NOTICE("BL2: Loss of arbitration is detected. "
+				"AVS status=%d Retry=%u\n",
+				avs_status, avs_retry);
+		/* Check of retry number of times*/
+		if (avs_retry >= AVS_RETRY_NUM) {
+			ERROR("BL2: AVS setting failed in retry. max=%u\n",
+				AVS_RETRY_NUM);
+			/* Infinite loop */
+			panic();
+		}
+		/* Set the error detected to error status. */
+		ret = avs_error_al;
+	} else if ((mmio_read_8(IIC_ICSR) & ICSR_TACK) == ICSR_TACK) {
+		NOTICE("BL2: Non-acknowledge is detected. "
+				"AVS status=%d Retry=%u\n",
+				avs_status, avs_retry);
+		/* Check of retry number of times*/
+		if (avs_retry >= AVS_RETRY_NUM) {
+			ERROR("BL2: AVS setting failed in retry. max=%u\n",
+				AVS_RETRY_NUM);
+			/* Infinite loop */
+			panic();
+		}
+		/* Set the error detected to error status. */
+		ret = avs_error_nack;
+	} else {
+		/* Not error. */
+		ret = avs_error_none;
+	}
+	return ret;
+}
+
+/*
+ * Set I2C for DVFS clock.
+ */
+static void avs_set_iic_clock(void)
+{
+	uint32_t md_pin;
+
+	/* Read Mode pin register. */
+	md_pin = mmio_read_32(RCAR_MODEMR) & (MODEMR_MD13 | MODEMR_MD14);
+	switch (md_pin) {
+	case CP_PHY_FREQ_8p33M:		/* 8.3333MHz */
+		mmio_write_8(IIC_ICCL, ICCL_FREQ_8p33M);
+		mmio_write_8(IIC_ICCH, ICCH_FREQ_8p33M);
+		break;
+	case CP_PHY_FREQ_10M:		/* 10MHz */
+		mmio_write_8(IIC_ICCL, ICCL_FREQ_10M);
+		mmio_write_8(IIC_ICCH, ICCH_FREQ_10M);
+		break;
+	case CP_PHY_FREQ_12p5M:		/* 12.5MHz */
+		mmio_write_8(IIC_ICCL, ICCL_FREQ_12p5M);
+		mmio_write_8(IIC_ICCH, ICCH_FREQ_12p5M);
+		break;
+	case CP_PHY_FREQ_16p66M:	/* 16.6666MHz */
+		mmio_write_8(IIC_ICCL, ICCL_FREQ_16p66M);
+		mmio_write_8(IIC_ICCH, ICCH_FREQ_16p66M);
+		break;
+	default:			/* This case is not possible. */
+		/* CP Phy frequency is to be set for the 16.66MHz */
+		mmio_write_8(IIC_ICCL, ICCL_FREQ_16p66M);
+		mmio_write_8(IIC_ICCH, ICCH_FREQ_16p66M);
+		break;
+	}
+}
+
+#if AVS_READ_PMIC_REG_ENABLE == 1
+/*
+ * Read the value of the register of PMIC.
+ */
+static uint8_t avs_read_pmic_reg(uint8_t addr)
+{
+	uint8_t reg;
+
+	INFO("BL2: Read PMIC register start.\n");
+
+	/* Set ICCR.ICE=1 to activate the I2C module. */
+	mmio_write_8(IIC_ICCR, mmio_read_8(IIC_ICCR) | ICCR_ENABLE);
+
+	/* Set frequency of 400kHz */
+	avs_set_iic_clock();
+
+	/* Set ICIC.WAITE=1, ICIC.DTEE=1 to enable data transmission	*/
+	/* interrupt and wait interrupt.				*/
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) | ICIC_WAITE | ICIC_DTEE);
+
+	/* Write H'94 in ICCR to issue start condition */
+	mmio_write_8(IIC_ICCR, ICCR_START);
+
+	/* Wait for a until ICSR.DTE becomes 1. */
+	avs_poll( ICSR_DTE, 1U);
+
+	/* Clear ICIC.DTEE to disable a DTE interrupt. */
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) & (uint8_t)(~ICIC_DTEE));
+	/* Send slave address of PMIC */
+	mmio_write_8(IIC_ICDR, PMIC_W_SLAVE_ADDRESS);
+
+	/* Wait for a until ICSR.WAIT becomes 1. */
+	avs_poll(ICSR_WAIT, 1U);
+
+	/* write PMIC address */
+	mmio_write_8(IIC_ICDR, addr);
+	/* Clear ICSR.WAIT to exit from WAIT status. */
+	mmio_write_8(IIC_ICSR, mmio_read_8(IIC_ICSR) & (uint8_t)(~ICSR_WAIT));
+
+	/* Wait for a until ICSR.WAIT becomes 1. */
+	avs_poll(ICSR_WAIT, 1U);
+
+	/* Write H'94 in ICCR to issue restart condition */
+	mmio_write_8(IIC_ICCR, ICCR_START);
+	/* Clear ICSR.WAIT to exit from WAIT status. */
+	mmio_write_8(IIC_ICSR, mmio_read_8(IIC_ICSR) & (uint8_t)(~ICSR_WAIT));
+	/* Set ICIC.DTEE=1 to enable data transmission interrupt. */
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) | ICIC_DTEE);
+
+	/* Wait for a until ICSR.DTE becomes 1. */
+	avs_poll( ICSR_DTE, 1U);
+
+	/* Clear ICIC.DTEE to disable a DTE interrupt. */
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) & (uint8_t)(~ICIC_DTEE));
+	/* Send slave address of PMIC */
+	mmio_write_8(IIC_ICDR, PMIC_R_SLAVE_ADDRESS);
+
+	/* Wait for a until ICSR.WAIT becomes 1. */
+	avs_poll(ICSR_WAIT, 1U);
+
+	/* Write H'81 to ICCR to issue the repeated START condition 	*/
+	/* for changing the transmission mode to the receive mode.	*/
+	mmio_write_8(IIC_ICCR, ICCR_START_RECV);
+	/* Clear ICSR.WAIT to exit from WAIT status. */
+	mmio_write_8(IIC_ICSR, mmio_read_8(IIC_ICSR) & (uint8_t)(~ICSR_WAIT));
+
+	/* Wait for a until ICSR.WAIT becomes 1. */
+	avs_poll(ICSR_WAIT, 1U);
+
+	/* Set ICCR to H'C0 for the STOP condition */
+	mmio_write_8(IIC_ICCR, ICCR_STOP_RECV);
+	/* Clear ICSR.WAIT to exit from WAIT status. */
+	mmio_write_8(IIC_ICSR, mmio_read_8(IIC_ICSR) & (uint8_t)(~ICSR_WAIT));
+	/* Set ICIC.DTEE=1 to enable data transmission interrupt. */
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) | ICIC_DTEE);
+
+	/* Wait for a until ICSR.DTE becomes 1. */
+	avs_poll( ICSR_DTE, 1U);
+
+	/* Receive DVFS SetVID register */
+	/* Clear ICIC.DTEE to disable a DTE interrupt. */
+	mmio_write_8(IIC_ICIC, mmio_read_8(IIC_ICIC) & (uint8_t)(~ICIC_DTEE));
+	/* Receive DVFS SetVID register */
+	reg = mmio_read_8(IIC_ICDR);
+
+	/* Wait until ICSR.BUSY is cleared. */
+	avs_poll( ICSR_BUSY, 0U);
+
+	/* Set ICCR=H'00 to disable the I2C module. */
+	mmio_write_8(IIC_ICCR, 0x00U);
+
+	return reg;
+}
+
+/*
+ * Wait processing by the polling.
+ */
+static void avs_poll(uint8_t bit_pos, uint8_t val)
+{
+	uint8_t bit_val = 0U;
+
+	if (val != 0U) {
+		bit_val = bit_pos;
+	}
+
+	while (1) {
+		if ((mmio_read_8(IIC_ICSR) & bit_pos) == bit_val) {
+			break;
+		}
+	}
+}
+#endif	/* AVS_READ_PMIC_REG_ENABLE */
+#endif	/* AVS_SETTING_ENABLE */
diff --git a/plat/renesas/rcar/drivers/dma/dma_driver.c b/plat/renesas/rcar/drivers/dma/dma_driver.c
new file mode 100644
index 0000000..ac3650e
--- /dev/null
+++ b/plat/renesas/rcar/drivers/dma/dma_driver.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <mmio.h>
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_init.h"
+#include "bl2_dma_register.h"
+#include "dma_driver.h"
+#include "debug.h"
+
+static void regdump(void);
+
+static void enableDMA(void);
+static void setupDMA(void);
+static void startDMA(uint32_t dst, uint32_t src, uint32_t len);
+static void endDMA(void);
+#if DEBUG
+static void disableDMA(void);
+#endif
+
+static void regdump(void)
+{
+#if DEBUG
+	INFO("BL2:\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n"
+		"%s(0x%x) : 0x%x\n",
+		"CPG_SMSTPCR2",CPG_SMSTPCR2,mmio_read_32(CPG_SMSTPCR2),
+		"CPG_SRCR2   ",CPG_SRCR2,mmio_read_32(CPG_SRCR2),
+		"CPG_MSTPSR2 ",CPG_MSTPSR2,mmio_read_32(CPG_MSTPSR2),
+		"DMAOR2      ",DMA_DMAOR2,mmio_read_16(DMA_DMAOR2),
+		"DMASEC2     ",DMA_DMASEC2,mmio_read_32(DMA_DMASEC2),
+		"DMACHCLR2   ",DMA_DMACHCLR2,mmio_read_32(DMA_DMACHCLR2),
+		"DMASAR32    ",DMA_DMASAR32,mmio_read_32(DMA_DMASAR32),
+		"DMADAR32    ",DMA_DMADAR32,mmio_read_32(DMA_DMADAR32),
+		"DMATCR32    ",DMA_DMATCR32,mmio_read_32(DMA_DMATCR32),
+		"DMACHCR32   ",DMA_DMACHCR32,mmio_read_32(DMA_DMACHCR32)
+	);
+#endif
+}
+
+static void enableDMA(void)
+{
+	/* Is the clock supply to the CPG disabled ? */
+	while((mmio_read_32(CPG_MSTPSR2) & SYS_DMAC2_BIT) != 0U) {
+		/* Enables the clock supply to the CPG. */
+		cpg_write(CPG_SMSTPCR2,
+			mmio_read_32(CPG_SMSTPCR2) & (~SYS_DMAC2_BIT));
+	}
+}
+
+static void setupDMA(void)
+{
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0000U);
+	/* DMA channel clear 2 */
+	mmio_write_32(DMA_DMACHCLR2,0x0000FFFFU);
+	mmio_write_32(DMA_DMACHCLR2,0x00000000U);
+}
+
+static void startDMA(uint32_t dst, uint32_t src, uint32_t len)
+{
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0301U);
+	/* DMA destination address 32 */
+	mmio_write_32(DMA_DMADAR32,dst);
+	/* DMA source address 32 */
+	mmio_write_32(DMA_DMASAR32,src);
+	/* DMA 64bytes-unit transfer  count 32 */
+	mmio_write_32(DMA_DMATCR32,len >> 6);
+	/* DMA channel control 32 */
+	mmio_write_32(DMA_DMACHCR32,0x00105409U);
+}
+
+static void endDMA(void)
+{
+	/* DMA channel control 32 */
+	while((mmio_read_32(DMA_DMACHCR32) & 0x00000002U) == 0x00000000U) {
+		/* DMA channel control 32 */
+		if ((mmio_read_32(DMA_DMACHCR32) & 0x80000000U) != 0U) {
+			ERROR("BL2: DMA - Channel Address Error\n");
+			regdump();
+			break;
+		}
+	}
+	/* DMA operation 2 */
+	mmio_write_16(DMA_DMAOR2,0x0000U);
+	/* DMA channel clear 2 */
+	mmio_write_32(DMA_DMACHCLR2,0x00000001U);
+	mmio_write_32(DMA_DMACHCLR2,0x00000000U);
+}
+
+#if DEBUG
+static void disableDMA(void)
+{
+	/* Disable the clock supply to the CPG. */
+	cpg_write(CPG_SMSTPCR2,
+		mmio_read_32(CPG_SMSTPCR2) | SYS_DMAC2_BIT);
+}
+#endif
+
+void initDMA(void)
+{
+	enableDMA();
+	setupDMA();
+}
+
+void execDMA(uint32_t dst, uint32_t src, uint32_t len)
+{
+	uint32_t dmalen;
+	uint32_t memlen;
+
+	if (((dst & 0x3FU) != 0U) || ((src & 0x3FU) != 0U) ||
+		((len & 0xC0000000U) != 0U)) {
+		/* dst or src are not 64-bit alignment. */
+		dmalen = 0U;
+		memlen = len;
+	} else {
+		/* dst and src are 64-bit alignment. */
+		dmalen = len & 0x3FFFFFC0U;
+		memlen = len & 0x3FU;
+	}
+	if (dmalen != 0U) {
+		startDMA(dst, src, dmalen);
+		endDMA();
+		dst += dmalen;
+		src += dmalen;
+	} else {
+		if (memlen == 0U) {
+			startDMA(dst, src, 0U);
+			endDMA();
+			dmalen = 0x01000000U << 6;
+			dst += dmalen;
+			src += dmalen;
+		}
+	}
+	if (memlen != 0U) {
+		(void)memcpy((void*)(uint64_t)dst,
+			(const void*)(uint64_t)src,
+				(size_t)memlen);
+	}
+	if (dmalen != 0U) {
+		INFO("BL2: DMA    len=%d(0x%x)\n",
+			dmalen, dmalen);
+	}
+	if (memlen != 0U) {
+		INFO("BL2: memcpy len=%d(0x%x)\n",
+			memlen, memlen);
+	}
+}
+
+#if DEBUG
+void termDMA(void)
+{
+	disableDMA();
+}
+#endif
diff --git a/plat/renesas/rcar/drivers/error/bl2_int_error.c b/plat/renesas/rcar/drivers/error/bl2_int_error.c
new file mode 100644
index 0000000..48bb403
--- /dev/null
+++ b/plat/renesas/rcar/drivers/error/bl2_int_error.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <bl_common.h>
+#include <arm_gic.h>
+#include <mmio.h>
+#include <debug.h>
+#include "bl2_int_error.h"
+#include "../../rcar_def.h"
+
+#define INT_ID_MASK	(0x000003FFU)
+#define SWDT_ERROR_ID	(1024U)
+#define SWDT_ERROR_TYPE	(16U)
+#define SWDT_CHAR_MAX	(13U)
+
+void bl2_interrupt_error_id(uint32_t wrong_id)
+{
+	if (wrong_id >= SWDT_ERROR_ID) {
+		ERROR("\n");
+		ERROR("BL2: bl2_interrupt_error_id error, invalid ID = %d\n"
+			 ,wrong_id);
+		/* Endless loop		*/
+		panic();
+	}
+	/* Clear the interrupt request	*/
+	arm_gic_end_of_interrupt((uint32_t)wrong_id);
+	bl2_swdt_release();
+	ERROR("\n");
+	ERROR("BL2: This interrupt is Invalid, receive interrupt ID = %d\n"
+		 ,wrong_id);
+	/* Endless loop		*/
+	panic();
+}
+
+void bl2_interrupt_error_type(uint32_t wrong_type)
+{
+	const uint8_t interrupt_ex[SWDT_ERROR_TYPE][SWDT_CHAR_MAX] = {
+		"SYNC SP EL0",
+		"IRQ SP EL0",
+		"FIQ SP EL0",
+		"SERR SP EL0",
+		"SYNC SP ELx",
+		"IRQ SP ELx",
+		"FIQ SP ELx",
+		"SERR SP ELx",
+		"SYNC AARCH64",
+		"IRQ AARCH64",
+		"FIQ AARCH64",
+		"SERR AARCH64",
+		"SYNC AARCH32",
+		"IRQ AARCH32",
+		"FIQ AARCH32",
+		"SERR AARCH32"
+	};
+	uint32_t interrupt_id;
+
+	if (wrong_type >= SWDT_ERROR_TYPE) {
+		/* Clear the interrupt request	*/
+		(void)arm_gic_acknowledge_interrupt();
+		ERROR("\n");
+		ERROR("BL2: bl2_interrupt_error_type error, invalid type = %d\n"
+			,wrong_type);
+		/* endless loop		*/
+		panic();
+	}
+	interrupt_id = arm_gic_acknowledge_interrupt() & INT_ID_MASK;
+	bl2_swdt_release();
+
+	ERROR("\n");
+	ERROR("BL2: This interrupt is not FIQ, interrupt type = %s, ID = %d\n"
+			,&interrupt_ex[wrong_type][0], interrupt_id);
+	/* Endless loop		*/
+	panic();
+}
diff --git a/plat/renesas/rcar/drivers/io/io_memdrv.c b/plat/renesas/rcar/drivers/io/io_memdrv.c
new file mode 100644
index 0000000..efc8443
--- /dev/null
+++ b/plat/renesas/rcar/drivers/io/io_memdrv.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <debug.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <string.h>
+#include "io_memdrv.h"
+#include "dma_driver.h"
+
+/* As we need to be able to keep state for seek, only one file can be open
+ * at a time. Make this a structure and point to the entity->info. When we
+ * can malloc memory we can change this to support more open files.
+ */
+typedef struct {
+	/* Use the 'in_use' flag as any value for base and file_pos could be
+	 * valid.
+	 */
+	uint32_t	in_use;
+	uintptr_t	base;
+	ssize_t		file_pos;
+} file_state_t;
+
+static file_state_t current_file = {0};
+
+/* memdrv device functions */
+static io_type_t device_type_memdrv(void);
+static int32_t memdrv_dev_open(const uintptr_t dev_spec,
+				io_dev_info_t **dev_info);
+static int32_t memdrv_block_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			     io_entity_t *entity);
+static int32_t memdrv_block_seek(io_entity_t *entity, int32_t mode,
+			     ssize_t offset);
+static int32_t memdrv_block_read(io_entity_t *entity, uintptr_t buffer,
+			     size_t length, size_t *length_read);
+static int32_t memdrv_block_close(io_entity_t *entity);
+static int32_t memdrv_dev_close(io_dev_info_t *dev_info);
+
+
+static const io_dev_connector_t memdrv_dev_connector = {
+	.dev_open = &memdrv_dev_open
+};
+
+
+static const io_dev_funcs_t memdrv_dev_funcs = {
+	.type = &device_type_memdrv,
+	.open = &memdrv_block_open,
+	.seek = &memdrv_block_seek,
+	.size = NULL,
+	.read = &memdrv_block_read,
+	.write = NULL,
+	.close = &memdrv_block_close,
+	.dev_init = NULL,
+	.dev_close = &memdrv_dev_close,
+};
+
+
+/* No state associated with this device so structure can be const */
+static const io_dev_info_t memdrv_dev_info = {
+	.funcs = &memdrv_dev_funcs,
+	.info = (uintptr_t)0
+};
+
+/* Identify the device type as memdrv */
+static io_type_t device_type_memdrv(void)
+{
+	return IO_TYPE_MEMMAP;
+}
+
+
+/* Open a connection to the memdrv device */
+static int32_t memdrv_dev_open(
+			const uintptr_t dev_spec __attribute__((unused)),
+			io_dev_info_t **dev_info)
+{
+	assert(dev_info != NULL);
+	*dev_info = (io_dev_info_t *)&memdrv_dev_info; /* cast away const */
+
+	return IO_SUCCESS;
+}
+
+
+
+/* Close a connection to the memdrv device */
+static int32_t memdrv_dev_close(io_dev_info_t *dev_info)
+{
+	/* NOP */
+	/* TODO: Consider tracking open files and cleaning them up here */
+	return IO_SUCCESS;
+}
+
+
+/* Open a file on the memdrv device */
+/* TODO: Can we do any sensible limit checks on requested memory */
+static int32_t memdrv_block_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			     io_entity_t *entity)
+{
+	int32_t result;
+	const io_block_spec_t *block_spec = (io_block_spec_t *)spec;
+
+	/* Since we need to track open state for seek() we only allow one open
+	 * spec at a time. When we have dynamic memory we can malloc and set
+	 * entity->info.
+	 */
+	if (current_file.in_use == 0U) {
+		assert(block_spec != NULL);
+		assert(entity != NULL);
+
+		current_file.in_use = 1U;
+		current_file.base = block_spec->offset;
+		/* File cursor offset for seek and incremental reads etc. */
+		current_file.file_pos = 0;
+		entity->info = (uintptr_t)&current_file;
+		result = IO_SUCCESS;
+	} else {
+		WARN("A memdrv device is already active. Close first.\n");
+		result = IO_RESOURCES_EXHAUSTED;
+	}
+
+	return result;
+}
+
+
+/* Seek to a particular file offset on the memdrv device */
+static int32_t memdrv_block_seek(io_entity_t *entity, int32_t mode,
+				ssize_t offset)
+{
+	int32_t result;
+
+	/* We only support IO_SEEK_SET for the moment. */
+	if ((io_seek_mode_t)mode == IO_SEEK_SET) {
+		assert(entity != NULL);
+		assert(entity->info != (uintptr_t)NULL);
+
+		/* TODO: can we do some basic limit checks on seek? */
+		((file_state_t *)entity->info)->file_pos = offset;
+		result = IO_SUCCESS;
+	} else {
+		result = IO_FAIL;
+	}
+
+	return result;
+}
+
+
+/* Read data from a file on the memdrv device */
+static int32_t memdrv_block_read(io_entity_t *entity, uintptr_t buffer,
+			     size_t length, size_t *length_read)
+{
+	file_state_t *fp;
+
+	assert(entity != NULL);
+	assert(buffer != (uintptr_t)NULL);
+	assert(length_read != NULL);
+
+	fp = (file_state_t *)entity->info;
+
+	NOTICE("BL2: dst=0x%x src=0x%x len=%d(0x%x)\n",
+		(uint32_t)buffer,
+		(uint32_t)(fp->base + fp->file_pos),
+		(uint32_t)length, (uint32_t)length);
+
+#if 1	/* DMA driver */
+	execDMA((uint32_t)buffer, (uint32_t)(fp->base + fp->file_pos),
+		(uint32_t)length);
+#else
+	(void)memcpy((void *)buffer, (void *)(fp->base + fp->file_pos),
+		length);
+#endif
+
+	*length_read = length;
+	/* advance the file 'cursor' for incremental reads */
+	fp->file_pos += (ssize_t)length;
+
+	return IO_SUCCESS;
+}
+
+
+/* Close a file on the memdrv device */
+static int32_t memdrv_block_close(io_entity_t *entity)
+{
+	assert(entity != NULL);
+
+	entity->info = 0U;
+
+	/* This would be a mem free() if we had malloc.*/
+	(void)memset((void *)&current_file, 0, sizeof(current_file));
+
+	return IO_SUCCESS;
+}
+
+
+/* Exported functions */
+
+/* Register the memdrv driver with the IO abstraction */
+int32_t register_io_dev_memdrv(const io_dev_connector_t **dev_con)
+{
+	int32_t result;
+	assert(dev_con != NULL);
+
+	result = io_register_device(&memdrv_dev_info);
+	if (result == IO_SUCCESS) {
+		*dev_con = &memdrv_dev_connector;
+	}
+
+	return result;
+}
diff --git a/plat/renesas/rcar/drivers/io/io_rcar.c b/plat/renesas/rcar/drivers/io/io_rcar.c
new file mode 100644
index 0000000..ed368c8
--- /dev/null
+++ b/plat/renesas/rcar/drivers/io/io_rcar.c
@@ -0,0 +1,620 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <auth_mod.h>
+#include <bl_common.h>
+#include <debug.h>
+#include <errno.h>
+#include <firmware_image_package.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <stdint.h>
+#include <string.h>
+#include <uuid.h>
+#include "io_rcar.h"
+
+
+typedef struct {
+	const int32_t	name;
+	const uint32_t	offset;
+	const uint32_t	attr;
+} plat_rcar_name_offset_t;
+
+typedef struct {
+	/* Put file_pos above the struct to allow {0} on static init.
+	 * It is a workaround for a known bug in GCC
+	 * http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53119
+	 */
+	uint32_t	file_pos;
+	uint32_t	is_noload;
+	uint32_t	offset_address;
+	uint32_t	size;
+	uint32_t	dest_address;
+} file_state_t;
+
+#define RCAR_GET_FLASH_ADR(a,b)		(uint32_t)((0x40000U*(a)) + (b))
+#define RCAR_ATTR_SET_CALCADDR(a)	((a) & 0xF)			/* lower 4bit use */
+#define RCAR_ATTR_SET_ISNOLOAD(a)	(((a) & 0x1) << 16U)		/* 16bit use */
+#define RCAR_ATTR_SET_CERTOFF(a)	(((a) & 0xF) << 8U)		/* 11-8bit use */
+#define RCAR_ATTR_SET_ALL(a,b,c)	(uint32_t)(RCAR_ATTR_SET_CALCADDR(a) |\
+					RCAR_ATTR_SET_ISNOLOAD(b) | RCAR_ATTR_SET_CERTOFF(c))
+
+#define RCAR_ATTR_GET_CALCADDR(a)	((a) & 0xFU)			/* lower 4bit use */
+#define RCAR_ATTR_GET_ISNOLOAD(a)	(((a) >> 16) & 0x1U)		/* 16bit use */
+#define RCAR_ATTR_GET_CERTOFF(a)	(((a) >> 8) & 0xFU)		/* 11-8bit use */
+
+#define RCAR_MAX_BL3X_IMAGE		(8U)
+#define RCAR_SECTOR6_CERT_OFFSET	(0x400U)
+#define RCAR_SDRAM_CERT_ADDRESS		(0x43F00000U)
+#define RCAR_CERT_SIZE			(0x400U)
+#define RCAR_CERT_INFO_SIZE_OFFSET	(0x264U)	/* byte address set : must 4byte alignment */
+#define RCAR_CERT_INFO_DST_OFFSET	(0x154U)	/* byte address set : must 4byte alignment */
+
+#define RCAR_CERT_LOAD			(1U)
+
+static const plat_rcar_name_offset_t name_offset[] = {		/* calc addr, no load, cert offset */
+	{BL31_IMAGE_ID,		RCAR_GET_FLASH_ADR(7U,0x000U),	RCAR_ATTR_SET_ALL(0,0,0)},
+	/* BL3-2 is optional in the platform */
+	{BL32_IMAGE_ID,		RCAR_GET_FLASH_ADR(8U,0x000U),	RCAR_ATTR_SET_ALL(0,0,1)},
+	{BL33_IMAGE_ID,		0U,				RCAR_ATTR_SET_ALL(1,0,2)},
+	{BL332_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(2,0,3)},
+	{BL333_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(3,0,4)},
+	{BL334_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(4,0,5)},
+	{BL335_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(5,0,6)},
+	{BL336_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(6,0,7)},
+	{BL337_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(7,0,8)},
+	{BL338_IMAGE_ID,	0U,				RCAR_ATTR_SET_ALL(8,0,9)},
+};
+#if TRUSTED_BOARD_BOOT
+static const plat_rcar_name_offset_t cert_offset[] = {
+	/* Certificates */
+	{TRUSTED_KEY_CERT_ID,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{BL31_KEY_CERT_ID,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{BL32_KEY_CERT_ID,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{BL33_KEY_CERT_ID,	0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{BL31_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,0)},
+	{BL32_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,1)},
+	{BL33_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,2)},
+	{BL332_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,3)},
+	{BL333_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,4)},
+	{BL334_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,5)},
+	{BL335_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,6)},
+	{BL336_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,7)},
+	{BL337_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,8)},
+	{BL338_CERT_ID,		0U,				RCAR_ATTR_SET_ALL(0,1,9)},
+};
+#endif /* TRUSTED_BOARD_BOOT */
+
+
+static file_state_t current_file = {0};
+static uintptr_t backend_dev_handle;
+static uintptr_t backend_image_spec;
+static uint32_t rcar_image_header[RCAR_MAX_BL3X_IMAGE + 1U] = {0U};
+static uint32_t	rcar_cert_load = {0U};
+
+
+/* prototype */
+static io_type_t device_type_rcar(void);
+static int32_t rcar_dev_open(const uintptr_t dev_spec, io_dev_info_t **dev_info);
+static int32_t rcar_file_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			  io_entity_t *entity);
+static int32_t rcar_file_len(io_entity_t *entity, size_t *length);
+static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer, size_t length,
+			  size_t *length_read);
+static int32_t rcar_file_close(io_entity_t *entity);
+static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t init_params);
+static int32_t rcar_dev_close(io_dev_info_t *dev_info);
+static int32_t file_to_offset(const int32_t file, uint32_t *offset, uint32_t *cert_addr, uint32_t *is_noload);
+static int32_t load_bl33x(uintptr_t handle);
+
+
+/* Identify the device type as a virtual driver */
+static io_type_t device_type_rcar(void)
+{
+	return IO_TYPE_FIRMWARE_IMAGE_PACKAGE;
+}
+
+
+static const io_dev_connector_t rcar_dev_connector = {
+	.dev_open = &rcar_dev_open
+};
+
+
+static const io_dev_funcs_t rcar_dev_funcs = {
+	.type = &device_type_rcar,
+	.open = &rcar_file_open,
+	.seek = NULL,
+	.size = &rcar_file_len,
+	.read = &rcar_file_read,
+	.write = NULL,
+	.close = &rcar_file_close,
+	.dev_init = &rcar_dev_init,
+	.dev_close = &rcar_dev_close,
+};
+
+
+/* No state associated with this device so structure can be const */
+static const io_dev_info_t rcar_dev_info = {
+	.funcs = &rcar_dev_funcs,
+	.info = (uintptr_t)0
+};
+
+
+/* Open a connection to the FIP device */
+static int32_t rcar_dev_open(const uintptr_t dev_spec __attribute__((unused)),
+			 io_dev_info_t **dev_info)
+{
+	assert(dev_info != NULL);
+	*dev_info = (io_dev_info_t *)&rcar_dev_info; /* cast away const */
+
+	return IO_SUCCESS;
+}
+
+int32_t file_to_cert(const int32_t filename, uint32_t *cert_addr)
+{
+	int32_t i;
+	int32_t status = -EINVAL;
+
+	for (i = 0; i < (int32_t)ARRAY_SIZE(cert_offset); i++) {
+		if (filename == cert_offset[i].name) {
+			*cert_addr = RCAR_CERT_SIZE;
+			*cert_addr *= (uint32_t)RCAR_ATTR_GET_CERTOFF(cert_offset[i].attr);
+			*cert_addr += RCAR_SDRAM_CERT_ADDRESS;
+			status = 0;
+			break;
+		}
+	}
+	return status;
+}
+
+static int32_t file_to_offset(const int32_t file, uint32_t *offset, uint32_t *cert_addr, uint32_t *is_noload)
+{
+	int32_t i;
+	int32_t status = -EINVAL;
+	uint32_t is_calc_addr;
+	
+	assert(offset != NULL);
+	assert(cert_addr != NULL);
+	assert(is_noload != NULL);
+
+	for (i = 0; i < (int32_t)ARRAY_SIZE(name_offset); i++) {
+		if (file == name_offset[i].name) {
+			is_calc_addr = RCAR_ATTR_GET_CALCADDR(name_offset[i].attr);
+			if (rcar_image_header[0] >= is_calc_addr)
+			{
+				if (0U != is_calc_addr)
+				{
+					*offset = rcar_image_header[is_calc_addr];
+				} else {
+					*offset = name_offset[i].offset;
+				}
+				*cert_addr = RCAR_CERT_SIZE;
+				*cert_addr *= RCAR_ATTR_GET_CERTOFF(name_offset[i].attr);
+				*cert_addr += RCAR_SDRAM_CERT_ADDRESS;
+				*is_noload = RCAR_ATTR_GET_ISNOLOAD(name_offset[i].attr);
+				status = IO_SUCCESS;
+				break;
+			}
+		}
+	}
+
+	if (IO_SUCCESS != status) {
+		for (i = 0; i < (int32_t)ARRAY_SIZE(cert_offset); i++) {
+			if (file == cert_offset[i].name) {
+				*offset = 0U;
+				*cert_addr = 0U;
+				*is_noload = RCAR_ATTR_GET_ISNOLOAD(cert_offset[i].attr);
+				status = IO_SUCCESS;
+				break;
+			}
+		}
+	}
+	return status;
+}
+
+void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr)
+{
+	assert(size != NULL);
+	assert(dest_addr != NULL);
+	
+	cert_addr &= 0xFFFFFFFFU;		/* need? */
+
+	*size = *((uint32_t *)(cert_addr + RCAR_CERT_INFO_SIZE_OFFSET)) * 4U;
+	*dest_addr = *((uint32_t *)(cert_addr + RCAR_CERT_INFO_DST_OFFSET));
+}
+
+static int32_t load_bl33x(uintptr_t handle)
+{
+	int32_t result = IO_SUCCESS;
+	uint32_t loop = 1U;	/* start is BL332 */
+	uint32_t file_offset;
+	uint32_t noload;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	size_t bytes_read;
+	const int32_t load_names[] = {
+		BL33_IMAGE_ID,
+		BL332_IMAGE_ID,
+		BL333_IMAGE_ID,
+		BL334_IMAGE_ID,
+		BL335_IMAGE_ID,
+		BL336_IMAGE_ID,
+		BL337_IMAGE_ID,
+		BL338_IMAGE_ID
+	};
+
+	for (; loop < rcar_image_header[0]; loop++) {
+
+		if (IO_SUCCESS != result){
+			break;
+		}
+
+		result = file_to_offset(load_names[loop], &file_offset,
+			&cert_addr, &noload);
+		if (IO_SUCCESS != result) {
+			WARN("load_bl33x: failed to get offset\n");
+			result = IO_FAIL;
+		} else {
+
+			get_info_from_cert((uint64_t) cert_addr, &l_image_size,
+				&dest_addr);
+
+				result = io_seek(handle, IO_SEEK_SET,
+					(ssize_t) file_offset);
+				if (IO_SUCCESS != result) {
+					WARN("load_bl33x: failed to seek\n");
+					result = IO_FAIL;
+				}
+			}
+
+		if (IO_SUCCESS == result) {
+
+			result = io_read(handle, (uintptr_t)dest_addr, (size_t)l_image_size,
+				(size_t *)&bytes_read);
+			if (IO_SUCCESS != result) {
+				WARN("load_bl33x: failed to read\n");
+				result = IO_FAIL;
+			}
+#if TRUSTED_BOARD_BOOT
+			else {
+				/* Authenticate it */
+				result = (int32_t)auth_mod_verify_img(
+					(unsigned int)load_names[loop],
+					(void *)((uintptr_t)dest_addr),
+					(unsigned int)l_image_size);
+				if (0 != result) {
+					memset((void *)((uintptr_t)dest_addr),
+						0x00,
+						(size_t)l_image_size);
+					result = IO_FAIL;
+				}
+			}
+#endif /* TRUSTED_BOARD_BOOT */
+		}
+	}
+
+	return result;
+}
+
+/* Do some basic package checks. */
+static int32_t rcar_dev_init(io_dev_info_t *dev_info, const uintptr_t init_params)
+{
+	int32_t result;
+	int32_t image_name = (int32_t)init_params;
+	uintptr_t backend_handle;
+	size_t bytes_read;
+
+	/* Obtain a reference to the image by querying the platform layer */
+	/* get rcar flash memory address... (certain BL2, BL31, BL32, BL33... max 64MB:RPC LBSC address) */
+	/* sakata check image number */
+	result = plat_get_image_source(image_name, &backend_dev_handle,
+				       &backend_image_spec);
+	if (result != IO_SUCCESS) {
+		WARN("Failed to obtain reference to image '%d' (%i)\n",
+			image_name, result);
+		result = IO_FAIL;
+	} else {
+
+		if (RCAR_CERT_LOAD == rcar_cert_load) {
+			/* not load certificate file after 1at initialize */
+			result = IO_SUCCESS;
+		} else {
+
+			/* Attempt to access the RCAR image */
+			/* open memory driver (certain SYS-DMAC2 initialize) */
+			result = io_open(backend_dev_handle, backend_image_spec,
+					&backend_handle);
+			if (result != IO_SUCCESS) {
+				WARN("Failed to access image '%d' (%i)\n",
+						image_name, result);
+				result = IO_FAIL;
+			}
+
+			/* get start address list */
+			/* [0] address num */
+			/* [1] BL33-1 image address */
+			/* [2] BL33-2 image address */
+			/* [3] BL33-3 image address */
+			/* [4] BL33-4 image address */
+			/* [5] BL33-5 image address */
+			/* [6] BL33-6 image address */
+			/* [7] BL33-7 image address */
+			/* [8] BL33-8 image address */
+			if (IO_SUCCESS == result) {
+				result = io_seek(backend_handle, IO_SEEK_SET,
+					(ssize_t) RCAR_GET_FLASH_ADR(6U, 0U));
+				if (result != IO_SUCCESS) {
+					WARN("Firmware Image Package header "\
+						"failed to seek\n");
+					result = IO_FAIL;
+					(void) io_close(backend_handle);
+				}
+			}
+			if (IO_SUCCESS == result) {
+				result = io_read(backend_handle,
+					(uintptr_t) &rcar_image_header,
+					sizeof(rcar_image_header), &bytes_read);
+				if (result == IO_SUCCESS) {
+					if ((rcar_image_header[0] == 0U)
+						|| (rcar_image_header[0] > 8U)) {
+						WARN("Firmware Image Package "\
+							"header check failed.\n");
+						result = IO_FAIL;
+						(void) io_close(backend_handle);
+					} else {
+						VERBOSE("header looks OK.\n");
+					}
+				}
+			}
+			/* load cert file */
+			if (IO_SUCCESS == result) {
+				result = io_seek(backend_handle, IO_SEEK_SET,
+					(ssize_t) (RCAR_GET_FLASH_ADR(6U, 0U)
+						+ RCAR_SECTOR6_CERT_OFFSET));
+				if (result != IO_SUCCESS) {
+					WARN("Firmware Image Package "\
+						"header failed to seek\n");
+					result = IO_FAIL;
+					(void) io_close(backend_handle);
+				}
+			}
+			if (IO_SUCCESS == result) {
+				result = io_read(backend_handle,
+						(uintptr_t) RCAR_SDRAM_CERT_ADDRESS,
+						(size_t) (RCAR_CERT_SIZE *
+						 (2U + (size_t) rcar_image_header[0])),
+						&bytes_read);
+				if (result != IO_SUCCESS) {
+					WARN("cert file road error.\n");
+					result = IO_FAIL;
+				} else {
+
+					rcar_cert_load = RCAR_CERT_LOAD;
+				}
+				(void) io_close(backend_handle);
+			}
+		}
+	}
+
+	return result;
+}
+
+/* Close a connection to the FIP device */
+static int32_t rcar_dev_close(io_dev_info_t *dev_info)
+{
+	/* TODO: Consider tracking open files and cleaning them up here */
+
+	/* Clear the backend. */
+	backend_dev_handle = (uintptr_t)0;
+	backend_image_spec = (uintptr_t)0;
+
+	return IO_SUCCESS;
+}
+
+
+/* Open a file for access from package. */
+static int32_t rcar_file_open(io_dev_info_t *dev_info, const uintptr_t spec,
+			 io_entity_t *entity)
+{
+	int32_t result;
+	uint32_t file_offset;
+	uint32_t noload;
+	uint32_t cert_addr;
+	uint32_t l_image_size;
+	uint32_t dest_addr;
+	const io_block_spec_t *file_spec = (io_block_spec_t *)spec;
+
+	assert(file_spec != NULL);
+	assert(entity != NULL);
+
+	/* Can only have one file open at a time for the moment. We need to
+	 * track state like file cursor position. We know the header lives at
+	 * offset zero, so this entry should never be zero for an active file.
+	 * When the system supports dynamic memory allocation we can allow more
+	 * than one open file at a time if needed.
+	 */
+	if (current_file.offset_address != 0U) {
+		WARN("rcar_file_open : Only one open file at a time.\n");
+		result = IO_RESOURCES_EXHAUSTED;
+	} else {
+
+		/* get file offset(but BL33 image id not get) */
+		result = file_to_offset(file_spec->offset,
+			&file_offset, &cert_addr, &noload);
+		if (result != IO_SUCCESS) {
+			WARN("Failed to open file name %ld (%i)\n",
+				file_spec->offset, result);
+			result = IO_FAIL;
+		} else {
+			if (0U != noload) {
+				current_file.offset_address = 1U;
+				current_file.dest_address = 0U;
+				current_file.size = 1U;
+				current_file.file_pos = 0U;
+				current_file.is_noload = noload;
+				entity->info = (uintptr_t) &current_file;
+
+			} else {
+
+				/* get image size and destination address */
+				get_info_from_cert((uint64_t) cert_addr,
+					&l_image_size, &dest_addr);
+
+				current_file.offset_address = file_offset;
+				current_file.dest_address = dest_addr;
+				current_file.size = l_image_size;
+				current_file.file_pos = 0U;
+				current_file.is_noload = noload;
+				entity->info = (uintptr_t) &current_file;
+			}
+		}
+	}
+
+	return result;
+}
+
+
+/* Return the size of a file in package */
+static int32_t rcar_file_len(io_entity_t *entity, size_t *length)
+{
+	assert(entity != NULL);
+	assert(length != NULL);
+
+	*length =  ((file_state_t *)entity->info)->size;
+
+	return IO_SUCCESS;
+}
+
+
+/* Read data from a file in package */
+static int32_t rcar_file_read(io_entity_t *entity, uintptr_t buffer, size_t length,
+			  size_t *length_read)
+{
+	int32_t result;
+	file_state_t *fp;
+	ssize_t file_offset;
+	size_t bytes_read;
+	uintptr_t backend_handle;
+
+	assert(entity != NULL);
+	assert(buffer != (uintptr_t)NULL);
+	assert(length_read != NULL);
+	assert(entity->info != (uintptr_t)NULL);
+
+	/* cert image no load */
+	if ( 0U != current_file.is_noload ) {
+		result = IO_SUCCESS;
+		*length_read = length;
+	} else {
+
+		/* Open the backend, attempt to access the blob image */
+		result = io_open(backend_dev_handle, backend_image_spec,
+			&backend_handle);
+		if (result != IO_SUCCESS) {
+			WARN("Failed to open FIP (%i)\n", result);
+			result = IO_FAIL;
+		} else {
+
+			fp = (file_state_t *) entity->info;
+
+			/* Seek to the position in the FIP where the payload lives */
+			file_offset = (ssize_t) fp->offset_address
+				+ (ssize_t) fp->file_pos;
+			result = io_seek(backend_handle, IO_SEEK_SET,
+				file_offset);
+			if (result != IO_SUCCESS) {
+				WARN("rcar_file_read: failed to seek\n");
+				result = IO_FAIL;
+			}
+
+			if (result == IO_SUCCESS) {
+				result = io_read(backend_handle, buffer, length,
+					&bytes_read);
+				if (result != IO_SUCCESS) {
+					/* We cannot read our data. Fail. */
+					WARN("Failed to read payload (%i)\n",
+						result);
+					result = IO_FAIL;
+				} else {
+					/* Set caller length and new file position. */
+					*length_read = bytes_read;
+					fp->file_pos += (uint32_t) bytes_read;
+				}
+			}
+
+			if ((result == IO_SUCCESS) && (buffer == (uintptr_t)NS_IMAGE_OFFSET)) {
+				result = load_bl33x(backend_handle);
+			}
+			/* Close the backend. */
+			(void) io_close(backend_handle);
+		}
+	}
+
+	return result;
+}
+
+
+/* Close a file in package */
+static int32_t rcar_file_close(io_entity_t *entity)
+{
+	/* Clear our current file pointer.
+	 * If we had malloc() we would free() here.
+	 */
+	assert(entity != NULL);
+	if (current_file.offset_address != 0U) {
+		(void)memset(&current_file, 0, sizeof(current_file));
+	}
+
+	/* Clear the Entity info. */
+	entity->info = 0U;
+
+	return IO_SUCCESS;
+}
+
+/* Exported functions */
+
+/* Register the Firmware Image Package driver with the IO abstraction */
+int32_t register_io_dev_rcar(const io_dev_connector_t **dev_con)
+{
+	int32_t result;
+	assert(dev_con != NULL);
+
+	result = io_register_device(&rcar_dev_info);
+	if (result == IO_SUCCESS) {
+		*dev_con = &rcar_dev_connector;
+	}
+
+	return result;
+}
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_console.S b/plat/renesas/rcar/drivers/memdrv/rcar_console.S
new file mode 100644
index 0000000..e8f5c04
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_console.S
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2013-2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <arch.h>
+#include <asm_macros.S>
+
+/*
+ * Pull in generic functions to provide backwards compatibility for
+ * platform makefiles
+ */
+#include "../../../drivers/console/console.S"
+
+	.globl	console_core_init
+	.globl	console_core_putc
+	.globl	console_core_getc
+	.globl	readreg_cntpct_el0
+
+	.extern	rcar_log_init
+	.extern	rcar_set_log_data
+
+	/* -----------------------------------------------
+	 * int console_core_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the log area. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * Return 1 on SUCCESS, 0 on error
+	 * In: x0 - Not used
+	 *     w1 - Not used
+	 *     w2 - Not used
+	 * -----------------------------------------------
+	 */
+func console_core_init
+	b	rcar_log_init
+endfunc console_core_init
+
+	/* --------------------------------------------------------
+	 * int console_core_putc(int c, unsigned long base_addr)
+	 * Function to output a character over the log area.
+	 * Return 1 on SUCCESS, 0 on error
+	 * In : w0 - Not used
+	 *      x1 - Not used
+	 * --------------------------------------------------------
+	 */
+func console_core_putc
+	b	rcar_set_log_data
+endfunc console_core_putc
+
+	/* ---------------------------------------------
+	 * int console_core_getc(unsigned long base_addr)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on error.
+	 * In : x0 - console base address
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_core_getc
+	ret
+endfunc console_core_getc
+
+
+	/* --------------------------------------------
+	 * uint64_t readreg_cntpct_el0(void)
+	 * Function to read CNTPCT_EL0 register.
+	 * --------------------------------------------
+	 */
+func readreg_cntpct_el0
+	mrs	x0, cntpct_el0
+	ret
+endfunc readreg_cntpct_el0
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_printf.c b/plat/renesas/rcar/drivers/memdrv/rcar_printf.c
new file mode 100644
index 0000000..15a4bcf
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_printf.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <debug.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include	<arch_helpers.h>
+#include	<platform_def.h>
+#include	<bakery_lock.h>
+#include	"../../rcar_def.h"
+#include	"../../rcar_private.h"
+#include	"rcar_printf.h"
+
+extern RCAR_INSTANTIATE_LOCK
+
+typedef struct log_head
+{
+	uint8_t head[4];
+	uint32_t index;
+	uint32_t size;
+	uint8_t res[4];
+} loghead_t;
+
+typedef struct log_map
+{
+	loghead_t header;
+	uint8_t log_data[RCAR_BL31_LOG_MAX];
+	uint8_t res_data[RCAR_LOG_RES_SIZE];
+} logmap_t;
+
+void rcar_set_log_time(void)
+{
+	uint64_t now_time;
+	uint64_t freq;
+	uint64_t second;
+	uint64_t micro_sec;
+	uint64_t t_log[2][15];
+	int32_t i;
+	int32_t start_counter;
+
+	now_time = readreg_cntpct_el0();
+	freq = read_cntfrq_el0(); /* get the frequency	*/
+	if (freq == 0U) { /* for zero division	*/
+		second = 0U;
+		micro_sec = 0U;
+	} else {
+		second = now_time / freq;
+		micro_sec = ((now_time % freq) * 1000000U) / freq;
+	}
+	i = 14; /* counter initialize	*/
+	do {
+		t_log[0][i] = second % 10U;
+		second = second / 10U;
+		i--;
+	} while (second != 0U);
+	start_counter = i + 1;
+	t_log[1][0] = micro_sec / 100000U;
+	micro_sec %= 100000U;
+	t_log[1][1] = micro_sec / 10000U;
+	micro_sec %= 10000U;
+	t_log[1][2] = micro_sec / 1000U;
+	micro_sec %= 1000U;
+	t_log[1][3] = micro_sec / 100U;
+	micro_sec %= 100U;
+	t_log[1][4] = micro_sec / 10U;
+	t_log[1][5] = micro_sec % 10U;
+
+	(void)putchar((int)'[');
+	for (i = start_counter; i < 15; i++) {
+		(void)putchar((int)((int)t_log[0][i] + (int)0x30));
+	}
+	(void)putchar((int)'.');
+	for (i = 0; i < 6; i++) {
+		(void)putchar((int)((int)t_log[1][i] + (int)0x30));
+	}
+	(void)putchar((int)']');
+}
+
+int32_t rcar_set_log_data(int32_t c)
+{
+	logmap_t *t_log;
+
+	t_log = (logmap_t *)RCAR_BL31_LOG_BASE;
+
+	rcar_lock_get();
+
+	/*
+	 * If index is broken, then index and size initialize
+	 */
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		t_log->header.index = 0U;
+		t_log->header.size = 0U;
+	}
+	/*
+	 * data store to log area then index and size renewal
+	 */
+	t_log->log_data[t_log->header.index] = (uint8_t)c;
+	t_log->header.index++;
+	if (t_log->header.size < t_log->header.index) {
+		t_log->header.size = t_log->header.index;
+	}
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		t_log->header.index = 0U;
+	}
+
+	rcar_lock_release();
+
+	return(1);
+}
+
+int32_t rcar_log_init(void)
+{
+
+	static const uint8_t const_header[] = "TLOG";
+	logmap_t *t_log;
+	int16_t init_flag = 0;
+
+	t_log = (logmap_t *)RCAR_BL31_LOG_BASE;
+	if (memcmp((const void *)t_log->header.head, (const void *)const_header, sizeof(t_log->header.head)) != 0) {
+		/*
+		 * Log header is not "TLOG", then log area initialize
+		 */
+		init_flag = 1;
+	}
+	if (t_log->header.index	>= (uint32_t)RCAR_BL31_LOG_MAX) {
+		/*
+		 * index is broken, then log area initialize
+		 */
+		init_flag = 1;
+	}
+	if (init_flag == 1) {
+		(void)memset((void *)t_log->log_data, 0, (size_t)RCAR_BL31_LOG_MAX);
+		(void)memcpy((void *)t_log->header.head, (const void *)const_header, sizeof(t_log->header.head));
+		t_log->header.index = 0U;
+		t_log->header.size = 0U;
+	}
+	rcar_lock_init();
+
+	return(1);
+}
diff --git a/plat/renesas/rcar/drivers/memdrv/rcar_printf.h b/plat/renesas/rcar/drivers/memdrv/rcar_printf.h
new file mode 100644
index 0000000..f9e4e54
--- /dev/null
+++ b/plat/renesas/rcar/drivers/memdrv/rcar_printf.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	RCAR_PRINTF_H__
+#define	RCAR_PRINTF_H__
+
+#include <string.h>
+
+void		rcar_set_log_time(void);
+int32_t		rcar_set_log_data(int32_t c);
+int32_t		rcar_log_init(void);
+
+extern uint64_t	readreg_cntpct_el0(void);
+
+#endif	/* RCAR_PRINTF_H__	*/
diff --git a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
new file mode 100644
index 0000000..f00cf5b
--- /dev/null
+++ b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
@@ -0,0 +1,291 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <bakery_lock.h>
+#include <mmio.h>
+#include <debug.h>
+#include <arch.h>
+#include "../../rcar_def.h"
+#include "../../rcar_private.h"
+#include "rcar_pwrc.h"
+
+/*
+ * TODO: Someday there will be a generic power controller api. At the moment
+ * each platform has its own pwrc so just exporting functions is fine.
+ */
+RCAR_INSTANTIATE_LOCK
+
+#define	WUP_IRQ_SHIFT	(0U)
+#define	WUP_FIQ_SHIFT	(8U)
+#define	WUP_CSD_SHIFT	(16U)
+
+#define	BIT_SOFTRESET	((uint32_t)1U<<15)
+#define	BIT_CA53_SCU	((uint32_t)1U<<21)
+#define	BIT_CA57_SCU	((uint32_t)1U<<12)
+#define	REQ_RESUME	((uint32_t)1U<<1)
+#define	REQ_OFF		((uint32_t)1U<<0)
+#define	STATUS_PWRUP	((uint32_t)1U<<1)
+#define	STATUS_PWRDOWN	((uint32_t)1U<<0)
+
+#define	STATE_CA57_CPU	(27U)
+#define	STATE_CA53_CPU	(22U)
+
+#define	STATUS_L2RST	((uint32_t)0U<<4)
+#define	MODE_L2_DOWN	(0x00000002U)
+#define	CPU_PWR_OFF	(0x00000003U)
+
+#define	RCAR_PSTR_MASK	(0x00000003U)
+#define	ST_ALL_STANDBY	(0x00003333U)
+
+static void SCU_power_up(uint64_t mpidr);
+
+uint32_t rcar_pwrc_status(uint64_t mpidr)
+{
+	uint32_t rc;
+	uint64_t cpu_no;
+	uint32_t prr_data;
+
+	rcar_lock_get();
+	prr_data = mmio_read_32((uintptr_t)RCAR_PRR);
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		if ((prr_data & ((uint32_t)1U << (STATE_CA53_CPU + cpu_no)))
+				== 0U) {
+			rc = 0U;
+		} else {
+			rc = RCAR_INVALID;
+		}
+	} else {
+		/* A57 side				*/
+		if ((prr_data & ((uint32_t)1U << (STATE_CA57_CPU + cpu_no)))
+				== 0U) {
+			rc = 0U;
+		} else {
+			rc = RCAR_INVALID;
+		}
+	}
+	rcar_lock_release();
+
+	return rc;
+}
+
+void rcar_pwrc_cpuon(uint64_t mpidr)
+{
+
+	uintptr_t res_reg;
+	uint32_t res_data;
+	uintptr_t on_reg;
+	uint64_t cpu_no;
+	uint32_t upper_value;
+	uint32_t wup_data;
+
+	rcar_lock_get();
+
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		res_reg = (uintptr_t)RCAR_CA53RESCNT;
+		on_reg = (uintptr_t)RCAR_CA53WUPCR;
+		upper_value = 0x5A5A0000U;
+	} else {
+		/* A57 side				*/
+		res_reg = (uintptr_t)RCAR_CA57RESCNT;
+		on_reg = (uintptr_t)RCAR_CA57WUPCR;
+		upper_value = 0xA5A50000U;
+	}
+	res_data = mmio_read_32(res_reg) | upper_value;
+	/* Assert to CPU reset	*/
+	mmio_write_32(res_reg, (res_data | ((uint32_t)1U << (3U - cpu_no))));
+	SCU_power_up(mpidr);
+	wup_data = (uint32_t)((uint32_t)1U << cpu_no);
+	do {
+		mmio_write_32(RCAR_CPGWPR, ~wup_data);
+		mmio_write_32(on_reg, wup_data);
+	} while ((mmio_read_32(on_reg) & wup_data) == 0U);
+	/* Dessert to CPU reset	*/
+	mmio_write_32(res_reg, (res_data & (~((uint32_t)1U << (3U - cpu_no)))));
+	rcar_lock_release();
+}
+
+static void SCU_power_up(uint64_t mpidr)
+{
+	uint32_t reg_SYSC_bit;
+	uintptr_t reg_PWRONCR;
+	volatile uintptr_t reg_PWRER;
+	uintptr_t reg_PWRSR;
+	uintptr_t reg_CPUCMCR;
+	uintptr_t reg_SYSCIER = (uintptr_t)RCAR_SYSCIER;
+	uintptr_t reg_SYSCIMR = (uintptr_t)RCAR_SYSCIMR;
+	volatile uintptr_t reg_SYSCSR = (volatile uintptr_t)RCAR_SYSCSR;
+	volatile uintptr_t reg_SYSCISR = (volatile uintptr_t)RCAR_SYSCISR;
+	volatile uintptr_t reg_SYSCISCR = (volatile uintptr_t)RCAR_SYSCISCR;
+
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) == 0U) {
+		/* CA57-SCU	*/
+		reg_SYSC_bit = (uint32_t)BIT_CA57_SCU;
+		reg_PWRONCR = (uintptr_t)RCAR_PWRONCR5;
+		reg_PWRER = (volatile uintptr_t)RCAR_PWRER5;
+		reg_PWRSR = (uintptr_t)RCAR_PWRSR5;
+		reg_CPUCMCR = (uintptr_t)RCAR_CA57CPUCMCR;
+	} else {
+		/* CA53-SCU	*/
+		reg_SYSC_bit = (uint32_t)BIT_CA53_SCU;
+		reg_PWRONCR = (uintptr_t)RCAR_PWRONCR3;
+		reg_PWRER = (volatile uintptr_t)RCAR_PWRER3;
+		reg_PWRSR = (uintptr_t)RCAR_PWRSR3;
+		reg_CPUCMCR = (uintptr_t)RCAR_CA53CPUCMCR;
+	}
+	if ((mmio_read_32(reg_PWRSR) & (uint32_t)STATUS_PWRDOWN) != 0x0000U) {
+		if (mmio_read_32(reg_CPUCMCR) != 0U) {
+			mmio_write_32(reg_CPUCMCR, (uint32_t)0x00000000U);
+		}
+		/* set SYSCIER and SYSCIMR		*/
+		mmio_write_32(reg_SYSCIER,
+				(mmio_read_32(reg_SYSCIER) | reg_SYSC_bit));
+		mmio_write_32(reg_SYSCIMR,
+				(mmio_read_32(reg_SYSCIMR) | reg_SYSC_bit));
+		do {
+			/* SYSCSR[1]=1?				*/
+			while ((mmio_read_32(reg_SYSCSR) & (uint32_t)REQ_RESUME)
+					== 0U) {
+				;
+			}
+			/* If SYSCSR[1]=1 then set bit in PWRONCRn to 1	*/
+			mmio_write_32(reg_PWRONCR, 0x0001U);
+		} while ((mmio_read_32(reg_PWRER) & 0x0001U) != 0U);
+
+		/* bit in SYSCISR=1 ?				*/
+		while ((mmio_read_32(reg_SYSCISR) & reg_SYSC_bit) == 0U) {
+			;
+		}
+		/* clear bit in SYSCISR				*/
+		mmio_write_32(reg_SYSCISCR, reg_SYSC_bit);
+	}
+}
+
+void rcar_pwrc_cpuoff(uint64_t mpidr)
+{
+	uintptr_t off_reg;
+	uint64_t cpu_no;
+
+	rcar_lock_get();
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		off_reg = (uintptr_t)RCAR_CA53CPU0CR;
+	} else {
+		/* A57 side				*/
+		off_reg = (uintptr_t)RCAR_CA57CPU0CR;
+	}
+	if (read_mpidr_el1() == mpidr) {
+		mmio_write_32(RCAR_CPGWPR, ~((uint32_t)CPU_PWR_OFF));
+		mmio_write_32(off_reg + (cpu_no * 0x0010U),
+				(uint32_t)CPU_PWR_OFF);
+	} else {
+		panic();
+	}
+	rcar_lock_release();
+}
+
+void rcar_pwrc_enable_interrupt_wakeup(uint64_t mpidr)
+{
+	uintptr_t reg;
+	uint64_t cpu_no;
+	uint32_t shift_irq;
+	uint32_t shift_fiq;
+
+	rcar_lock_get();
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA53;
+	} else {
+		/* A57 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA57;
+	}
+	shift_irq = WUP_IRQ_SHIFT + (uint32_t)cpu_no;
+	shift_fiq = WUP_FIQ_SHIFT + (uint32_t)cpu_no;
+	mmio_write_32(reg, (uint32_t)((~((uint32_t)1U << shift_irq))
+			& (~((uint32_t)1U << shift_fiq))));
+	rcar_lock_release();
+}
+
+void rcar_pwrc_disable_interrupt_wakeup(uint64_t mpidr)
+{
+	uintptr_t reg;
+	uint64_t cpu_no;
+	uint32_t shift_irq;
+	uint32_t shift_fiq;
+
+	rcar_lock_get();
+	cpu_no = mpidr & (uint64_t)MPIDR_CPU_MASK;
+	if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != 0U) {
+		/* A53 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA53;
+	} else {
+		/* A57 side				*/
+		reg = (uintptr_t)RCAR_WUPMSKCA57;
+	}
+	shift_irq = WUP_IRQ_SHIFT + (uint32_t)cpu_no;
+	shift_fiq = WUP_FIQ_SHIFT + (uint32_t)cpu_no;
+	mmio_write_32(reg, (uint32_t)(((uint32_t)1U << shift_irq)
+			| ((uint32_t)1U << shift_fiq)));
+	rcar_lock_release();
+}
+
+void rcar_pwrc_clusteroff(uint64_t mpidr)
+{
+	uint64_t target_core;
+	uintptr_t reg_CPUCMCR;
+
+	rcar_lock_get();
+	target_core = mpidr & ((uint64_t)MPIDR_CLUSTER_MASK);
+	if (target_core == 0U) {
+		reg_CPUCMCR = (uintptr_t)RCAR_CA57CPUCMCR;
+	} else {
+		reg_CPUCMCR = (uintptr_t)RCAR_CA53CPUCMCR;
+	}
+	/* all of the CPUs in the cluster is in the CoreStandby mode	*/
+	mmio_write_32(reg_CPUCMCR, (uint32_t)(STATUS_L2RST | MODE_L2_DOWN));
+	rcar_lock_release();
+}
+
+void rcar_pwrc_system_reset(void)
+{
+	mmio_write_32(RCAR_SRESCR, (0x5AA50000U | BIT_SOFTRESET));
+}
+
+/* Nothing else to do here apart from initializing the lock */
+void rcar_pwrc_setup(void)
+{
+	rcar_lock_init();
+}
diff --git a/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
new file mode 100644
index 0000000..4b83dc5
--- /dev/null
+++ b/plat/renesas/rcar/drivers/pwrc/rcar_pwrc.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PWRC_H__
+#define RCAR_PWRC_H__
+
+/* RCAR Power controller register offset etc */
+#define PPOFFR_OFF		0x0
+#define PPONR_OFF		0x4
+#define PCOFFR_OFF		0x8
+#define PWKUPR_OFF		0xc
+#define PSYSR_OFF		0x10
+
+#define PWKUPR_WEN		(1ull << 31)
+
+#define PSYSR_AFF_L2		(1 << 31)
+#define PSYSR_AFF_L1		(1 << 30)
+#define PSYSR_AFF_L0		(1 << 29)
+#define PSYSR_WEN		(1 << 28)
+#define PSYSR_PC		(1 << 27)
+#define PSYSR_PP		(1 << 26)
+
+#define PSYSR_WK_SHIFT		(24)
+#define PSYSR_WK_MASK		(0x3)
+#define PSYSR_WK(x)		(((x) >> PSYSR_WK_SHIFT) & PSYSR_WK_MASK)
+
+#define WKUP_COLD		0x0
+#define WKUP_RESET		0x1
+#define WKUP_PPONR		0x2
+#define WKUP_GICREQ		0x3
+
+#define	RCAR_INVALID		(0xffffffffU)
+#define PSYSR_INVALID		0xffffffff
+
+#ifndef __ASSEMBLY__
+
+/*******************************************************************************
+ * Function & variable prototypes
+ ******************************************************************************/
+void rcar_pwrc_setup(void);
+void rcar_pwrc_clusteroff(uint64_t mpidr);
+void rcar_pwrc_cpuoff(uint64_t mpidr);
+void rcar_pwrc_cpuon(uint64_t mpidr);
+void rcar_pwrc_enable_interrupt_wakeup(uint64_t mpidr);
+void rcar_pwrc_disable_interrupt_wakeup(uint64_t mpidr);
+uint32_t rcar_pwrc_status(uint64_t mpidr);
+uint32_t rcar_pwrc_get_cpu_wkr(uint64_t mpidr);
+void rcar_pwrc_system_reset(void);
+
+#endif /*__ASSEMBLY__*/
+
+#endif /* RCAR_PWRC_H__ */
diff --git a/plat/renesas/rcar/drivers/rpc/rpc_driver.c b/plat/renesas/rcar/drivers/rpc/rpc_driver.c
new file mode 100644
index 0000000..1c92ea6
--- /dev/null
+++ b/plat/renesas/rcar/drivers/rpc/rpc_driver.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <mmio.h>
+#include "bl2_cpg_register.h"
+#include "bl2_cpg_init.h"
+#include "bl2_rpc_register.h"
+#include "rpc_driver.h"
+#include "debug.h"
+
+static void enableRPC(void);
+static void setupRPC(void);
+#if DEBUG
+static void disableRPC(void);
+#endif
+
+static void enableRPC(void)
+{
+	while((mmio_read_32(CPG_MSTPSR9) & 0x00020000U) != 0U) {
+		cpg_write(CPG_SMSTPCR9,
+			mmio_read_32(CPG_SMSTPCR9) & (~0x00020000U));
+	}
+}
+
+static void setupRPC(void)
+{
+	/* manual mode */
+	if ((mmio_read_32(RPC_CMNCR) & 0x80000000U) != 0U) {
+		/* external address space read mode */
+		mmio_write_32(RPC_CMNCR,
+			mmio_read_32(RPC_CMNCR) & (~0x80000000U));
+	}
+}
+
+#if DEBUG
+static void disableRPC(void)
+{
+	cpg_write(CPG_SMSTPCR9,
+		mmio_read_32(CPG_SMSTPCR9) | 0x00020000U);
+}
+#endif
+
+void initRPC(void)
+{
+	enableRPC();
+	setupRPC();
+}
+
+#if DEBUG
+void termRPC(void)
+{
+	disableRPC();
+}
+#endif
diff --git a/plat/renesas/rcar/drivers/scif/scif.S b/plat/renesas/rcar/drivers/scif/scif.S
new file mode 100644
index 0000000..816ed95
--- /dev/null
+++ b/plat/renesas/rcar/drivers/scif/scif.S
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include "scif.h"
+
+/* Product Register */
+#define	PRR			(0xFFF00044)
+#define	PRR_PRODUCT_MASK	(0x00007FFF)
+#define	PRR_PRODUCT_H3_ES_1_0	(0x00004F00)	/* R-Car H3 ES1.0 */
+
+/* module stop */
+#define	CPG_BASE		(0xE6150000)
+#define	CPG_SMSTPCR3		(0x013C)
+#define	MSTP310			(1 << 10)
+#define	CPG_CPGWPR		(0x0900)
+
+/* SCIF2 */
+#define	SCIF2_BASE		(0xE6E88000)	/* SCIF-2 base address */
+
+#define	SCIF_SCSMR		(0x00)		/* Serial mode register */
+#define	SCIF_SCBRR		(0x04)		/* Bit rate register */
+#define	SCIF_SCSCR		(0x08)		/* Serial control register */
+#define	SCIF_SCFTDR		(0x0C)		/* Transmit FIFO data register */
+#define	SCIF_SCFSR		(0x10)		/* Serial status register */
+#define SCIF_SCFRDR		(0x14)		/* Receive FIFO data register */
+#define	SCIF_SCFCR		(0x18)		/* FIFO control register */
+#define	SCIF_SCFDR		(0x1C)		/* FIFO data count register */
+#define SCIF_SCSPTR		(0x20)		/* Serial port register */
+#define	SCIF_SCLSR		(0x24)		/* Line status register */
+#define	SCIF_DL			(0x30)		/* Frequency division register */
+#define	SCIF_CKS		(0x34)		/* Clock Select register */
+#define	SCIF_SCSMRIR		(0x40)		/* Serial mode register */
+
+
+#define	SCSMR_CA_MASK		(1 << 7)
+#define	SCSMR_CA_ASYNC		(0x0000)
+#define	SCSMR_CHR_MASK		(1 << 6)
+#define	SCSMR_CHR_8		(0x0000)
+#define	SCSMR_PE_MASK		(1 << 5)
+#define	SCSMR_PE_DIS		(0x0000)
+#define	SCSMR_STOP_MASK		(1 << 3)
+#define	SCSMR_STOP_1		(0x0000)
+#define	SCSMR_CKS_MASK		(3 << 0)
+#define	SCSMR_CKS_DIV1		(0x0000)
+#define	SCSMR_INIT_DATA		(SCSMR_CA_ASYNC + SCSMR_CHR_8 + \
+				SCSMR_PE_DIS + SCSMR_STOP_1 + \
+				SCSMR_CKS_DIV1)
+
+#define	SCBRR_115200BPS		(17)		/* 115200bps@66MHz */
+#define	SCBRR_230400BPS		(8)		/* 230400bps@66MHz */
+
+#define	SCSCR_TE_MASK		(1 << 5)
+#define	SCSCR_TE_DIS		(0x0000)
+#define	SCSCR_TE_EN		(0x0020)
+#define	SCSCR_RE_MASK		(1 << 4)
+#define	SCSCR_RE_DIS		(0x0000)
+#define	SCSCR_RE_EN		(0x0010)
+#define	SCSCR_CKE_MASK		(3 << 0)
+#define SCSCR_CKE_INT		(0x0000)
+#define SCSCR_CKE_BRG		(0x0002)
+#if SCIF_CLK == SCIF_EXTARNAL_CLK
+#define	SCSCR_CKE_INT_CLK	(SCSCR_CKE_BRG)
+#else
+#define	SCSCR_CKE_INT_CLK	(SCSCR_CKE_INT)
+#endif
+
+#define	SCFSR_INIT_DATA		(0x0000)
+
+#define	SCFCR_TTRG_MASK		(3 << 4)
+#define	SCFCR_TTRG_8		(0x0000)
+#define	SCFCR_TTRG_0		(0x0030)
+#define	SCFCR_TFRST_MASK	(1 << 2)
+#define	SCFCR_TFRST_DIS		(0x0000)
+#define	SCFCR_TFRST_EN		(0x0004)
+#define	SCFCR_RFRS_MASK		(1 << 1)
+#define	SCFCR_RFRS_DIS		(0x0000)
+#define	SCFCR_RFRS_EN		(0x0002)
+#define	SCFCR_INIT_DATA		(SCFCR_TTRG_8)
+
+#define SCFDR_T_MASK		(0x1f << 8)
+
+#define	DL_INIT_DATA		(8)		/* 14.7456MHz/(115200bps*16)*/
+			
+#define	CKS_CKS_DIV_MASK		(1 << 15)
+#define	CKS_CKS_DIV_CLK		(0x0000)
+#define	CKS_XIN_MASK		(1 << 14)
+#define	CKS_XIN_SCIF_CLK		(0x0000)
+#define	CKS_INIT_DATA		(CKS_CKS_DIV_CLK + CKS_XIN_SCIF_CLK)
+
+	.globl	console_init
+	.globl	console_putc
+	.globl	console_core_init
+	.globl	console_core_putc
+	.globl	console_getc
+	.globl	console_finalize
+
+	/*
+	 *  The console base is in the data section and not in .bss
+	 *  even though it is zero-init. In particular, this allows
+	 *  the console functions to start using this variable before
+	 *  the runtime memory is initialized for images which do not
+	 *  need to copy the .data section from ROM to RAM.
+	 */
+	/* -----------------------------------------------
+	 * int console_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. It saves
+	 * the console base to the data section.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * out: return 1 on success.
+	 * Clobber list : x1 - x3
+	 * -----------------------------------------------
+	 */
+func console_init
+	b	console_core_init
+endfunc console_init
+
+	/* -----------------------------------------------
+	 * int console_core_init(unsigned long base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success
+	 * Clobber list : x1, x2
+	 * -----------------------------------------------
+	 */
+func console_core_init
+	ldr	x0, =CPG_BASE
+	ldr	w1, [x0, #CPG_SMSTPCR3]
+	and	w1, w1, #~MSTP310		/* MSTP310=0 */
+	mvn	w2, w1
+	str	w2, [x0, #CPG_CPGWPR]
+	str	w1, [x0, #CPG_SMSTPCR3]
+
+	ldr	x0, =SCIF2_BASE
+	mov	w1, #0
+	strh	w1, [x0, #SCIF_SCSMRIR]
+	/* Clear bits TE and RE in SCSCR to 0 */
+	mov	w1, #(SCSCR_TE_DIS + SCSCR_RE_DIS)	/* TE=0,RE=0 */
+	strh	w1, [x0, #SCIF_SCSCR]
+	/* Set bits TFRST and RFRST in SCFCR to 1 */
+	ldrh	w1, [x0, #SCIF_SCFCR]
+	orr	w1, w1, #(SCFCR_TFRST_EN + SCFCR_RFRS_EN)	/* TFRESET=1,RFRESET=1 */
+	strh	w1, [x0, #SCIF_SCFCR]
+	/* Read flags of ER, DR, BRK, and RDF in SCFSR and those of TO and ORER in SCLSR, then clear them to 0 */
+	mov	w1, #SCFSR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCFSR]
+	mov	w1, #0
+	strh	w1, [x0, #SCIF_SCLSR]
+	/* Set bits CKE[1:0] in SCSCR */
+	ldrh	w1, [x0, #SCIF_SCSCR]
+	and	w1, w1, #~SCSCR_CKE_MASK
+	mov	w2, #SCSCR_CKE_INT_CLK		/* CKE=00 */
+	orr	w1, w1, w2
+	strh	w1, [x0, #SCIF_SCSCR]
+	/* Set data transfer format in SCSMR */
+	mov	w1, #SCSMR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCSMR]		/* CA=0,CHR=0,PE=0,STOP=0,CKS=P */
+	/* Set value in SCBRR */
+#if SCIF_CLK == SCIF_INTERNAL_CLK
+	ldr	x1, =PRR
+	ldr	w1, [x1]
+	and	w1, w1, #PRR_PRODUCT_MASK
+	mov	w2, #PRR_PRODUCT_H3_ES_1_0
+	cmp	w1, w2
+	beq	3f
+	mov	w1, #SCBRR_115200BPS	/* 115200bps */
+	b	2f
+3:
+	mov	w1, #SCBRR_230400BPS	/* H3 ES1.0 sets clock to doubling */
+2:
+	strb	w1, [x0, SCIF_SCBRR]
+#else
+	mov	w1, #DL_INIT_DATA
+	strh	w1, [x0, #SCIF_DL]
+	mov	w1, #CKS_INIT_DATA		/* CKS=0,XIN=0 */
+	strh	w1, [x0, #SCIF_CKS]
+#endif
+	/* 1-bit interval elapsed */
+	mov	w1, #100			/* 100 times */
+1:
+	subs	w1, w1, #1
+	cbnz	w1, 1b
+	/* Set bits RTRG[1:0], TTRG[1:0], and MCE in SCFCR, and clear bits FRST and RFRST to 0 */
+	mov	w1, #SCFCR_INIT_DATA
+	strh	w1, [x0, #SCIF_SCFCR]
+	/* Set bits TE and RE in SCSCR to 1 */
+	ldrh	w1, [x0, #SCIF_SCSCR]
+	orr	w1, w1, #(SCSCR_TE_EN + SCSCR_RE_EN)	/* TE=1,RE=1 */
+	strh	w1, [x0, #SCIF_SCSCR]
+	mov	x1, #1
+
+	ret
+endfunc console_core_init
+
+	/* ---------------------------------------------
+	 * int console_putc(int c)
+	 * Function to output a character over the
+	 * console. It returns the character printed on
+	 * success or -1 on error.
+	 * In : x0 - character to be printed
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x1, x2
+	 * ---------------------------------------------
+	 */
+func console_putc
+	b	console_core_putc
+endfunc console_putc
+
+	/* --------------------------------------------------------
+	 * int console_core_putc(int c, unsigned int base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_core_putc
+	ldr	x1, =SCIF2_BASE
+	cmp	w0, #0xA
+	/* Prepend '\r' to '\n' */
+	bne	2f
+1:
+	/* Check if the transmit FIFO is full */
+	ldrh	w2, [x1, #SCIF_SCFDR]
+	ubfx	w2, w2, #8, #5
+	cmp	w2, #16
+	bcs	1b
+	mov	w2, #0x0D
+	strb	w2, [x1, #SCIF_SCFTDR]
+2:
+	/* Check if the transmit FIFO is full */
+	ldrh	w2, [x1, #SCIF_SCFDR]
+	ubfx	w2, w2, #8, #5
+	cmp	w2, #16
+	bcs	2b
+	strb	w0, [x1, #SCIF_SCFTDR]
+
+	ret
+endfunc console_core_putc
+
+	/* ---------------------------------------------
+	 * int console_getc(void)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on error.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_getc
+	mov	w0, #-1			/* no support */
+	ret
+endfunc console_getc
+
+	/* -----------------------------------------------
+	 * void console_finalize(void)
+	 * -----------------------------------------------
+	 */
+func console_finalize
+	ldr	x0, =SCIF2_BASE
+1:
+	ldrh	w1, [x0, #SCIF_SCFDR]
+	ubfx	w1, w1, #8, #5
+	cmp	w1, #0
+	bne	1b
+
+	ldrh	w1, [x0, #SCIF_SCSCR]
+	and	w1, w1, #~(SCSCR_TE_EN + SCSCR_RE_EN)	/* TE=0,RE=0 */
+	strh	w1, [x0, #SCIF_SCSCR]
+
+	ret
+endfunc console_finalize
+
diff --git a/plat/renesas/rcar/drivers/timer/bl2_swdt.c b/plat/renesas/rcar/drivers/timer/bl2_swdt.c
new file mode 100644
index 0000000..a2b2b0a
--- /dev/null
+++ b/plat/renesas/rcar/drivers/timer/bl2_swdt.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch_helpers.h>
+#include <mmio.h>
+#include <arm_gic.h>
+#include <gic_v2.h>
+#include <debug.h>
+#include "bl2_swdt.h"
+#include "../../rcar_def.h"
+
+#define RST_BASE		(0xE6160000U)
+#define RST_WDTRSTCR		(RST_BASE + 0x0054U)
+#define SWDT_BASE		(0xE6030000U)
+#define SWDT_WTCNT		(SWDT_BASE + 0x0000U)
+#define SWDT_WTCSRA		(SWDT_BASE + 0x0004U)
+#define SWDT_WTCSRB		(SWDT_BASE + 0x0008U)
+
+#define WDTRSTCR_UPPER_BYTE	(0xA55A0000U)
+#define WTCSRA_UPPER_BYTE	(0xA5A5A500U)
+#define WTCSRB_UPPER_BYTE	(0xA5A5A500U)
+#define WTCNT_UPPER_BYTE	(0x5A5A0000U)
+#define WTCNT_RESET_VALUE	(0xF488U)
+#define WTCSRA_BIT_CKS		(0x0007U)
+#define WTCSRB_BIT_CKS		(0x003FU)
+#define SWDT_RSTMSK		((uint32_t)1U << 1)
+#define WTCSRA_WOVFE		((uint32_t)1U << 3)
+#define WTCSRA_WRFLG		((uint32_t)1U << 5)
+#define SWDT_ENABLE		((uint32_t)1U << 7)
+
+#define WDTRSTCR_MASK_ALL	(0x0000FFFFU)
+#define WTCSRA_MASK_ALL		(0x000000FFU)
+#define WTCNT_INIT_DATA		(WTCNT_UPPER_BYTE + WTCNT_RESET_VALUE)
+#define WTCSRA_INIT_DATA	(WTCSRA_UPPER_BYTE + 0x0FU)
+#define WTCSRB_INIT_DATA	(WTCSRB_UPPER_BYTE + 0x21U)
+
+#define WTCNT_COUNT_8p13k		(0x10000U - 40687U)
+#define WTCNT_COUNT_8p13k_H3ES1p0	(0x10000U - 20343U)
+#define WTCNT_COUNT_8p22k		(0x10000U - 41115U)
+#define WTCSRA_CKS_DIV16		(0x00000002U)
+
+#define CHECK_MD13_MD14			(0x6000U)
+#define FREQ_10p0M			(0x2000U)
+#define FREQ_12p5M			(0x4000U)
+#define FREQ_8p33M			(0x0000U)
+#define FREQ_16p66M			(0x6000U)
+
+static void bl2_swdt_disable(void);
+
+void bl2_swdt_init(void)
+{
+	uint32_t sr;
+	uint32_t rmsk;
+	uint32_t product_cut = mmio_read_32((uintptr_t)RCAR_PRR)
+				& (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+	uint32_t chk_data = mmio_read_32((uintptr_t)RCAR_MODEMR)
+							& CHECK_MD13_MD14;
+
+	if ((mmio_read_32(SWDT_WTCSRA) & SWDT_ENABLE) != 0U) {
+		/* Stop SWDT	*/
+		mmio_write_32(SWDT_WTCSRA,WTCSRA_UPPER_BYTE);
+	}
+
+	/* clock is OSC/16 and overflow interrupt is enabled	*/
+	mmio_write_32(SWDT_WTCSRA,(WTCSRA_UPPER_BYTE | WTCSRA_WOVFE
+							 | WTCSRA_CKS_DIV16));
+
+	/* Set the overflow counter				*/
+	switch (chk_data) {
+	case FREQ_8p33M:	/* MD13=0 and MD14=0		*/
+	case FREQ_12p5M:	/* MD13=0 and MD14=1		*/
+		/* OSCCLK=130.2kHz count=40687, set 0x5A5A6111	*/
+		mmio_write_32(SWDT_WTCNT,(WTCNT_UPPER_BYTE | WTCNT_COUNT_8p13k));
+		break;
+	case FREQ_10p0M:	/* MD13=1 and MD14=0		*/
+		/* OSCCLK=131.57kHz count=41115, set 0x5A5A5F65	*/
+		mmio_write_32(SWDT_WTCNT,(WTCNT_UPPER_BYTE | WTCNT_COUNT_8p22k));
+		break;
+	case FREQ_16p66M:	/* MD13=1 and MD14=1		*/
+		/* OSCCLK=130.2kHz				*/
+		if (product_cut==(RCAR_PRODUCT_H3 | RCAR_CUT_ES10)) {
+			/* R-car H3 ES1.0			*/
+			/* count=20343, set 0x5A5AB089		*/
+			mmio_write_32(SWDT_WTCNT,(WTCNT_UPPER_BYTE | WTCNT_COUNT_8p13k_H3ES1p0));
+		} else {
+			/* count=40687, set 0x5A5A6111		*/
+			mmio_write_32(SWDT_WTCNT,(WTCNT_UPPER_BYTE | WTCNT_COUNT_8p13k));
+		}
+		break;
+	default:
+		/* Error					*/
+		ERROR("BL2: MODEMR ERROR value=%x\n", chk_data);
+		panic();
+		break;
+	}
+
+	rmsk = mmio_read_32(RST_WDTRSTCR) & WDTRSTCR_MASK_ALL;
+	mmio_write_32(RST_WDTRSTCR,(WDTRSTCR_UPPER_BYTE
+					 | (rmsk | SWDT_RSTMSK)));
+	while ((mmio_read_8(SWDT_WTCSRA) & WTCSRA_WRFLG) != 0U) {
+		/* Wait until the WTCNT is reflected		*/
+		;
+	}
+	sr = mmio_read_32(SWDT_WTCSRA) & WTCSRA_MASK_ALL;
+	/* Start the System WatchDog Timer			*/
+	mmio_write_32(SWDT_WTCSRA,(WTCSRA_UPPER_BYTE | sr | SWDT_ENABLE));
+}
+
+static void bl2_swdt_disable(void)
+{
+	uint32_t rmsk;
+	uintptr_t base = (uintptr_t)RCAR_GICD_BASE;
+	uint32_t id = (uint32_t)ARM_IRQ_SEC_WDT;
+
+	/* Initialize the HW initial data, but SWDT is not moved	*/
+	rmsk = mmio_read_32(RST_WDTRSTCR) & WDTRSTCR_MASK_ALL;
+	mmio_write_32(RST_WDTRSTCR,(WDTRSTCR_UPPER_BYTE
+					 | (rmsk | SWDT_RSTMSK)));
+	mmio_write_32(SWDT_WTCNT,WTCNT_INIT_DATA);
+	mmio_write_32(SWDT_WTCSRA,WTCSRA_INIT_DATA);
+	mmio_write_32(SWDT_WTCSRB,WTCSRB_INIT_DATA);
+	/* Set the interrupt clear enable register			*/
+	gicd_set_icenabler(base, id);
+}
+
+void bl2_swdt_release(void)
+{
+        bl2_swdt_disable();
+        disable_fiq();
+        arm_gic_cpuif_deactivate();
+}
+
+void bl2_swdt_exec(uint64_t addr)
+{
+	/* Clear the interrupt request	*/
+	arm_gic_end_of_interrupt((uint32_t)ARM_IRQ_SEC_WDT);
+        bl2_swdt_release();
+	ERROR("\n");
+	ERROR("BL2: System WDT overflow, occured address is 0x%x\n"
+						, (uint32_t)addr);
+	/* Endless loop		*/
+	panic();
+}
diff --git a/plat/renesas/rcar/include/avs_driver.h b/plat/renesas/rcar/include/avs_driver.h
new file mode 100644
index 0000000..287853d
--- /dev/null
+++ b/plat/renesas/rcar/include/avs_driver.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+ 
+#ifndef AVS_DRIVER_H__
+#define AVS_DRIVER_H__
+
+/* AVS Setting. 1:enable / 0:disable */
+#ifndef AVS_SETTING_ENABLE
+#define AVS_SETTING_ENABLE	1
+#endif /* AVS_SETTING_ENABLE */
+
+void bl2_avs_init(void);
+void bl2_avs_setting(void);
+void bl2_avs_end(void);
+
+#endif  /* AVS_DRIVER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_axi_register.h b/plat/renesas/rcar/include/bl2_axi_register.h
new file mode 100644
index 0000000..da449c2
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_axi_register.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_AXI_REGISTER_H__
+#define	BL2_AXI_REGISTER_H__
+
+/* AXI registers */
+
+/* AXI base address */
+#define	AXI_BASE	(0xE6780000U)
+
+/* address split */
+
+/* AXI address split control 0 */
+#define	AXI_ADSPLCR0	(AXI_BASE + 0x4008U)
+/* AXI address split control 1 */
+#define	AXI_ADSPLCR1	(AXI_BASE + 0x400CU)
+/* AXI address split control 2 */
+#define	AXI_ADSPLCR2	(AXI_BASE + 0x4010U)
+/* AXI address split control 3 */
+#define	AXI_ADSPLCR3	(AXI_BASE + 0x4014U)
+
+/* functional safety */
+
+/* AXI functional safety control */
+#define	AXI_FUSACR	(AXI_BASE + 0x4020U)
+
+/* decompression */
+
+/* AXI decompression area configuration A0 */
+#define	AXI_DCMPAREACRA0	(AXI_BASE + 0x4100U)
+/* AXI decompression area configuration B0 */
+#define	AXI_DCMPAREACRB0	(AXI_BASE + 0x4104U)
+/* AXI decompression area configuration A1 */
+#define	AXI_DCMPAREACRA1	(AXI_BASE + 0x4108U)
+/* AXI decompression area configuration B1 */
+#define	AXI_DCMPAREACRB1	(AXI_BASE + 0x410CU)
+/* AXI decompression area configuration A2 */
+#define	AXI_DCMPAREACRA2	(AXI_BASE + 0x4110U)
+/* AXI decompression area configuration B2 */
+#define	AXI_DCMPAREACRB2	(AXI_BASE + 0x4114U)
+/* AXI decompression area configuration A3 */
+#define	AXI_DCMPAREACRA3	(AXI_BASE + 0x4118U)
+/* AXI decompression area configuration B3 */
+#define	AXI_DCMPAREACRB3	(AXI_BASE + 0x411CU)
+/* AXI decompression area configuration A4 */
+#define	AXI_DCMPAREACRA4	(AXI_BASE + 0x4120U)
+/* AXI decompression area configuration B4 */
+#define	AXI_DCMPAREACRB4	(AXI_BASE + 0x4124U)
+/* AXI decompression area configuration A5 */
+#define	AXI_DCMPAREACRA5	(AXI_BASE + 0x4128U)
+/* AXI decompression area configuration B5 */
+#define	AXI_DCMPAREACRB5	(AXI_BASE + 0x412CU)
+/* AXI decompression area configuration A6 */
+#define	AXI_DCMPAREACRA6	(AXI_BASE + 0x4130U)
+/* AXI decompression area configuration B6 */
+#define	AXI_DCMPAREACRB6	(AXI_BASE + 0x4134U)
+/* AXI decompression area configuration A7 */
+#define	AXI_DCMPAREACRA7	(AXI_BASE + 0x4138U)
+/* AXI decompression area configuration B7 */
+#define	AXI_DCMPAREACRB7	(AXI_BASE + 0x413CU)
+/* AXI decompression area configuration A8 */
+#define	AXI_DCMPAREACRA8	(AXI_BASE + 0x4140U)
+/* AXI decompression area configuration B8 */
+#define	AXI_DCMPAREACRB8	(AXI_BASE + 0x4144U)
+/* AXI decompression area configuration A9 */
+#define	AXI_DCMPAREACRA9	(AXI_BASE + 0x4148U)
+/* AXI decompression area configuration B9 */
+#define	AXI_DCMPAREACRB9	(AXI_BASE + 0x414CU)
+/* AXI decompression area configuration A10 */
+#define	AXI_DCMPAREACRA10	(AXI_BASE + 0x4150U)
+/* AXI decompression area configuration B10 */
+#define	AXI_DCMPAREACRB10	(AXI_BASE + 0x4154U)
+/* AXI decompression area configuration A11 */
+#define	AXI_DCMPAREACRA11	(AXI_BASE + 0x4158U)
+/* AXI decompression area configuration B11 */
+#define	AXI_DCMPAREACRB11	(AXI_BASE + 0x415CU)
+/* AXI decompression area configuration A12 */
+#define	AXI_DCMPAREACRA12	(AXI_BASE + 0x4160U)
+/* AXI decompression area configuration B12 */
+#define	AXI_DCMPAREACRB12	(AXI_BASE + 0x4164U)
+/* AXI decompression area configuration A13 */
+#define	AXI_DCMPAREACRA13	(AXI_BASE + 0x4168U)
+/* AXI decompression area configuration B13 */
+#define	AXI_DCMPAREACRB13	(AXI_BASE + 0x416CU)
+/* AXI decompression area configuration A14 */
+#define	AXI_DCMPAREACRA14	(AXI_BASE + 0x4170U)
+/* AXI decompression area configuration B14 */
+#define	AXI_DCMPAREACRB14	(AXI_BASE + 0x4174U)
+/* AXI decompression area configuration A15 */
+#define	AXI_DCMPAREACRA15	(AXI_BASE + 0x4178U)
+/* AXI decompression area configuration B15 */
+#define	AXI_DCMPAREACRB15	(AXI_BASE + 0x417CU)
+/* AXI decompression shadow area configuration */
+#define	AXI_DCMPSHDWCR	(AXI_BASE + 0x4280U)
+
+/* SDRAM protection */
+
+/* AXI dram protected area division 0 */
+#define	AXI_DPTDIVCR0	(AXI_BASE + 0x4400U)
+/* AXI dram protected area division 1 */
+#define	AXI_DPTDIVCR1	(AXI_BASE + 0x4404U)
+/* AXI dram protected area division 2 */
+#define	AXI_DPTDIVCR2	(AXI_BASE + 0x4408U)
+/* AXI dram protected area division 3 */
+#define	AXI_DPTDIVCR3	(AXI_BASE + 0x440CU)
+/* AXI dram protected area division 4 */
+#define	AXI_DPTDIVCR4	(AXI_BASE + 0x4410U)
+/* AXI dram protected area division 5 */
+#define	AXI_DPTDIVCR5	(AXI_BASE + 0x4414U)
+/* AXI dram protected area division 6 */
+#define	AXI_DPTDIVCR6	(AXI_BASE + 0x4418U)
+/* AXI dram protected area division 7 */
+#define	AXI_DPTDIVCR7	(AXI_BASE + 0x441CU)
+/* AXI dram protected area division 8 */
+#define	AXI_DPTDIVCR8	(AXI_BASE + 0x4420U)
+/* AXI dram protected area division 9 */
+#define	AXI_DPTDIVCR9	(AXI_BASE + 0x4424U)
+/* AXI dram protected area division 10 */
+#define	AXI_DPTDIVCR10	(AXI_BASE + 0x4428U)
+/* AXI dram protected area division 11 */
+#define	AXI_DPTDIVCR11	(AXI_BASE + 0x442CU)
+/* AXI dram protected area division 12 */
+#define	AXI_DPTDIVCR12	(AXI_BASE + 0x4430U)
+/* AXI dram protected area division 13 */
+#define	AXI_DPTDIVCR13	(AXI_BASE + 0x4434U)
+/* AXI dram protected area division 14 */
+#define	AXI_DPTDIVCR14	(AXI_BASE + 0x4438U)
+
+/* AXI dram protected area setting 0 */
+#define	AXI_DPTCR0	(AXI_BASE + 0x4440U)
+/* AXI dram protected area setting 1 */
+#define	AXI_DPTCR1	(AXI_BASE + 0x4444U)
+/* AXI dram protected area setting 2 */
+#define	AXI_DPTCR2	(AXI_BASE + 0x4448U)
+/* AXI dram protected area setting 3 */
+#define	AXI_DPTCR3	(AXI_BASE + 0x444CU)
+/* AXI dram protected area setting 4 */
+#define	AXI_DPTCR4	(AXI_BASE + 0x4450U)
+/* AXI dram protected area setting 5 */
+#define	AXI_DPTCR5	(AXI_BASE + 0x4454U)
+/* AXI dram protected area setting 6 */
+#define	AXI_DPTCR6	(AXI_BASE + 0x4458U)
+/* AXI dram protected area setting 7 */
+#define	AXI_DPTCR7	(AXI_BASE + 0x445CU)
+/* AXI dram protected area setting 8 */
+#define	AXI_DPTCR8	(AXI_BASE + 0x4460U)
+/* AXI dram protected area setting 9 */
+#define	AXI_DPTCR9	(AXI_BASE + 0x4464U)
+/* AXI dram protected area setting 10 */
+#define	AXI_DPTCR10	(AXI_BASE + 0x4468U)
+/* AXI dram protected area setting 11 */
+#define	AXI_DPTCR11	(AXI_BASE + 0x446CU)
+/* AXI dram protected area setting 12 */
+#define	AXI_DPTCR12	(AXI_BASE + 0x4470U)
+/* AXI dram protected area setting 13 */
+#define	AXI_DPTCR13	(AXI_BASE + 0x4474U)
+/* AXI dram protected area setting 14 */
+#define	AXI_DPTCR14	(AXI_BASE + 0x4478U)
+/* AXI dram protected area setting 15 */
+#define	AXI_DPTCR15	(AXI_BASE + 0x447CU)
+
+/* SRAM protection */
+
+/* AXI sram protected area division 0 */
+#define	AXI_SPTDIVCR0	(AXI_BASE + 0x4500U)
+/* AXI sram protected area division 1 */
+#define	AXI_SPTDIVCR1	(AXI_BASE + 0x4504U)
+/* AXI sram protected area division 2 */
+#define	AXI_SPTDIVCR2	(AXI_BASE + 0x4508U)
+/* AXI sram protected area division 3 */
+#define	AXI_SPTDIVCR3	(AXI_BASE + 0x450CU)
+/* AXI sram protected area division 4 */
+#define	AXI_SPTDIVCR4	(AXI_BASE + 0x4510U)
+/* AXI sram protected area division 5 */
+#define	AXI_SPTDIVCR5	(AXI_BASE + 0x4514U)
+/* AXI sram protected area division 6 */
+#define	AXI_SPTDIVCR6	(AXI_BASE + 0x4518U)
+/* AXI sram protected area division 7 */
+#define	AXI_SPTDIVCR7	(AXI_BASE + 0x451CU)
+/* AXI sram protected area division 8 */
+#define	AXI_SPTDIVCR8	(AXI_BASE + 0x4520U)
+/* AXI sram protected area division 9 */
+#define	AXI_SPTDIVCR9	(AXI_BASE + 0x4524U)
+/* AXI sram protected area division 10 */
+#define	AXI_SPTDIVCR10	(AXI_BASE + 0x4528U)
+/* AXI sram protected area division 11 */
+#define	AXI_SPTDIVCR11	(AXI_BASE + 0x452CU)
+/* AXI sram protected area division 12 */
+#define	AXI_SPTDIVCR12	(AXI_BASE + 0x4530U)
+/* AXI sram protected area division 13 */
+#define	AXI_SPTDIVCR13	(AXI_BASE + 0x4534U)
+/* AXI sram protected area division 14 */
+#define	AXI_SPTDIVCR14	(AXI_BASE + 0x4538U)
+
+/* AXI sram protected area setting 0 */
+#define	AXI_SPTCR0	(AXI_BASE + 0x4540U)
+/* AXI sram protected area setting 1 */
+#define	AXI_SPTCR1	(AXI_BASE + 0x4544U)
+/* AXI sram protected area setting 2 */
+#define	AXI_SPTCR2	(AXI_BASE + 0x4548U)
+/* AXI sram protected area setting 3 */
+#define	AXI_SPTCR3	(AXI_BASE + 0x454CU)
+/* AXI sram protected area setting 4 */
+#define	AXI_SPTCR4	(AXI_BASE + 0x4550U)
+/* AXI sram protected area setting 5 */
+#define	AXI_SPTCR5	(AXI_BASE + 0x4554U)
+/* AXI sram protected area setting 6 */
+#define	AXI_SPTCR6	(AXI_BASE + 0x4558U)
+/* AXI sram protected area setting 7 */
+#define	AXI_SPTCR7	(AXI_BASE + 0x455CU)
+/* AXI sram protected area setting 8 */
+#define	AXI_SPTCR8	(AXI_BASE + 0x4560U)
+/* AXI sram protected area setting 9 */
+#define	AXI_SPTCR9	(AXI_BASE + 0x4564U)
+/* AXI sram protected area setting 10 */
+#define	AXI_SPTCR10	(AXI_BASE + 0x4568U)
+/* AXI sram protected area setting 11 */
+#define	AXI_SPTCR11	(AXI_BASE + 0x456CU)
+/* AXI sram protected area setting 12 */
+#define	AXI_SPTCR12	(AXI_BASE + 0x4570U)
+/* AXI sram protected area setting 13 */
+#define	AXI_SPTCR13	(AXI_BASE + 0x4574U)
+/* AXI sram protected area setting 14 */
+#define	AXI_SPTCR14	(AXI_BASE + 0x4578U)
+/* AXI sram protected area setting 15 */
+#define	AXI_SPTCR15	(AXI_BASE + 0x457CU)
+
+/* EDC base address */
+#define	EDC_BASE	(0xFF840000U)
+
+/* EDC edc enable */
+#define	EDC_EDCEN	(EDC_BASE + 0x0010U)
+/* EDC edc status 0 */
+#define	EDC_EDCST0	(EDC_BASE + 0x0020U)
+/* EDC edc status 1 */
+#define	EDC_EDCST1	(EDC_BASE + 0x0024U)
+/* EDC edc interrupt enable 0 */
+#define	EDC_EDCINTEN0	(EDC_BASE + 0x0040U)
+/* EDC edc interrupt enable 1 */
+#define	EDC_EDCINTEN1	(EDC_BASE + 0x0044U)
+
+#endif	/* BL2_AXI_REGISTER_H__ */
+
diff --git a/plat/renesas/rcar/include/bl2_cpg_init.h b/plat/renesas/rcar/include/bl2_cpg_init.h
new file mode 100644
index 0000000..0c45767
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_cpg_init.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_CPG_INIT_H__
+#define	BL2_CPG_INIT_H__
+
+void bl2_cpg_init(void);
+void cpg_write(uintptr_t regadr, uint32_t regval);
+
+#endif	/* BL2_CPG_INIT_H__ */
diff --git a/plat/renesas/rcar/include/bl2_cpg_register.h b/plat/renesas/rcar/include/bl2_cpg_register.h
new file mode 100644
index 0000000..4339793
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_cpg_register.h
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_CPG_REGISTER_H__
+#define	BL2_CPG_REGISTER_H__
+
+/* CPG base address */
+#define	CPG_BASE	(0xE6150000U)
+
+/* CPG system module stop control 2 */
+#define CPG_SMSTPCR2	(CPG_BASE + 0x0138U)
+/* CPG software reset 2 */
+#define CPG_SRCR2	(CPG_BASE + 0x00B0U)
+/* CPG module stop status 2 */
+#define CPG_MSTPSR2	(CPG_BASE + 0x0040U)
+/* CPG write protect */
+#define CPG_CPGWPR	(CPG_BASE + 0x0900U)
+/* CPG write protect control */
+#define CPG_CPGWPCR	(CPG_BASE + 0x0904U)
+/* CPG system module stop control 9 */
+#define CPG_SMSTPCR9    (CPG_BASE + 0x0994U)
+/* CPG module stop status 9 */
+#define CPG_MSTPSR9     (CPG_BASE + 0x09A4U)
+
+/* CPG (SECURITY) registers */
+
+/* Secure Module Stop Control Register 0 */
+#define	SCMSTPCR0	(CPG_BASE + 0x0B20U)
+/* Secure Module Stop Control Register 1 */
+#define	SCMSTPCR1	(CPG_BASE + 0x0B24U)
+/* Secure Module Stop Control Register 2 */
+#define	SCMSTPCR2	(CPG_BASE + 0x0B28U)
+/* Secure Module Stop Control Register 3 */
+#define	SCMSTPCR3	(CPG_BASE + 0x0B2CU)
+/* Secure Module Stop Control Register 4 */
+#define	SCMSTPCR4	(CPG_BASE + 0x0B30U)
+/* Secure Module Stop Control Register 5 */
+#define	SCMSTPCR5	(CPG_BASE + 0x0B34U)
+/* Secure Module Stop Control Register 6 */
+#define	SCMSTPCR6	(CPG_BASE + 0x0B38U)
+/* Secure Module Stop Control Register 7 */
+#define	SCMSTPCR7	(CPG_BASE + 0x0B3CU)
+/* Secure Module Stop Control Register 8 */
+#define	SCMSTPCR8	(CPG_BASE + 0x0B40U)
+/* Secure Module Stop Control Register 9 */
+#define	SCMSTPCR9	(CPG_BASE + 0x0B44U)
+/* Secure Module Stop Control Register 10 */
+#define	SCMSTPCR10	(CPG_BASE + 0x0B48U)
+/* Secure Module Stop Control Register 11 */
+#define	SCMSTPCR11	(CPG_BASE + 0x0B4CU)
+
+/* CPG (SECURITY) registers */
+
+/* Secure Software Reset Access Enable Control Register 0 */
+#define	SCSRSTECR0	(CPG_BASE + 0x0B80U)
+/* Secure Software Reset Access Enable Control Register 1 */
+#define	SCSRSTECR1	(CPG_BASE + 0x0B84U)
+/* Secure Software Reset Access Enable Control Register 2 */
+#define	SCSRSTECR2	(CPG_BASE + 0x0B88U)
+/* Secure Software Reset Access Enable Control Register 3 */
+#define	SCSRSTECR3	(CPG_BASE + 0x0B8CU)
+/* Secure Software Reset Access Enable Control Register 4 */
+#define	SCSRSTECR4	(CPG_BASE + 0x0B90U)
+/* Secure Software Reset Access Enable Control Register 5 */
+#define	SCSRSTECR5	(CPG_BASE + 0x0B94U)
+/* Secure Software Reset Access Enable Control Register 6 */
+#define	SCSRSTECR6	(CPG_BASE + 0x0B98U)
+/* Secure Software Reset Access Enable Control Register 7 */
+#define	SCSRSTECR7	(CPG_BASE + 0x0B9CU)
+/* Secure Software Reset Access Enable Control Register 8 */
+#define	SCSRSTECR8	(CPG_BASE + 0x0BA0U)
+/* Secure Software Reset Access Enable Control Register 9 */
+#define	SCSRSTECR9	(CPG_BASE + 0x0BA4U)
+/* Secure Software Reset Access Enable Control Register 10 */
+#define	SCSRSTECR10	(CPG_BASE + 0x0BA8U)
+/* Secure Software Reset Access Enable Control Register 11 */
+#define	SCSRSTECR11	(CPG_BASE + 0x0BACU)
+
+/* CPG (REALTIME) registers */
+
+/* Realtime Module Stop Control Register 0 */
+#define	RMSTPCR0	(CPG_BASE + 0x0110U)
+/* Realtime Module Stop Control Register 1 */
+#define	RMSTPCR1	(CPG_BASE + 0x0114U)
+/* Realtime Module Stop Control Register 2 */
+#define	RMSTPCR2	(CPG_BASE + 0x0118U)
+/* Realtime Module Stop Control Register 3 */
+#define	RMSTPCR3	(CPG_BASE + 0x011CU)
+/* Realtime Module Stop Control Register 4 */
+#define	RMSTPCR4	(CPG_BASE + 0x0120U)
+/* Realtime Module Stop Control Register 5 */
+#define	RMSTPCR5	(CPG_BASE + 0x0124U)
+/* Realtime Module Stop Control Register 6 */
+#define	RMSTPCR6	(CPG_BASE + 0x0128U)
+/* Realtime Module Stop Control Register 7 */
+#define	RMSTPCR7	(CPG_BASE + 0x012CU)
+/* Realtime Module Stop Control Register 8 */
+#define	RMSTPCR8	(CPG_BASE + 0x0980U)
+/* Realtime Module Stop Control Register 9 */
+#define	RMSTPCR9	(CPG_BASE + 0x0984U)
+/* Realtime Module Stop Control Register 10 */
+#define	RMSTPCR10	(CPG_BASE + 0x0988U)
+/* Realtime Module Stop Control Register 11 */
+#define	RMSTPCR11	(CPG_BASE + 0x098CU)
+
+
+#endif	/* BL2_CPG_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_dma_register.h b/plat/renesas/rcar/include/bl2_dma_register.h
new file mode 100644
index 0000000..e168add
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_dma_register.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_DMA_REGISTER_H__
+#define BL2_DMA_REGISTER_H__
+
+#define	DMACH	0	/* DMA CH setting (0/16/32) */
+
+#if (DMACH==0)		/* SYS-DMAC0 (CH0) */
+#define SYS_DMAC2_BIT	(0x00080000U)
+#define DMA_BASE	(0xE6700000U)
+#elif (DMACH==16)	/* SYS-DMAC1 (CH16) */
+#define SYS_DMAC2_BIT	(0x00040000U)
+#define DMA_BASE	(0xE7300000U)
+#elif (DMACH==32)	/* SYS-DMAC2 (CH32) */
+#define SYS_DMAC2_BIT	(0x00020000U)
+#define DMA_BASE	(0xE7320000U)
+#else
+#define SYS_DMAC2_BIT	(0x00080000U)
+#define DMA_BASE	(0xE6700000U)
+#endif
+
+/* DMA operation 0 */
+#define DMA_DMAOR2	(DMA_BASE + 0x0060U)
+/* DMA secure control */
+#define	DMA_DMASEC2	(DMA_BASE + 0x0030U)
+/* DMA channel clear */
+#define DMA_DMACHCLR2	(DMA_BASE + 0x0080U)
+/* DMA source address */
+#define DMA_DMASAR32	(DMA_BASE + 0x8000U)
+/* DMA destination address */
+#define DMA_DMADAR32	(DMA_BASE + 0x8004U)
+/* DMA transfer count */
+#define DMA_DMATCR32	(DMA_BASE + 0x8008U)
+/* DMA channel control */
+#define DMA_DMACHCR32	(DMA_BASE + 0x800CU)
+
+#endif	/* BL2_DMA_REGISTER_H__ */
+
diff --git a/plat/renesas/rcar/include/bl2_int_error.h b/plat/renesas/rcar/include/bl2_int_error.h
new file mode 100644
index 0000000..9de6bd1
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_int_error.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_INT_ERROR_H__
+#define BL2_INT_ERROR_H__
+
+extern void bl2_swdt_release(void);
+
+void bl2_interrupt_error_id(uint32_t wrong_id);
+
+void bl2_interrupt_error_type(uint32_t wrong_type);
+
+#endif /* BL2_INT_ERROR_H__ */
diff --git a/plat/renesas/rcar/include/bl2_lifec_register.h b/plat/renesas/rcar/include/bl2_lifec_register.h
new file mode 100644
index 0000000..5178c34
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_lifec_register.h
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_LIFEC_REGISTER_H__
+#define	BL2_LIFEC_REGISTER_H__
+
+/* LIFEC0 (SECURITY) registers */
+
+/* LIFEC0 (SECURITY) base address */
+#define	LIFEC_SEC_BASE	(0xE6110000U)
+
+/* Security attribute setting for master ports */
+#define	SEC_SRC		(LIFEC_SEC_BASE + 0x0008U)
+/* Security attribute setting for slave ports 0 */
+#define	SEC_SEL0	(LIFEC_SEC_BASE + 0x0030U)
+/* Security attribute setting for slave ports 1 */
+#define	SEC_SEL1	(LIFEC_SEC_BASE + 0x0034U)
+/* Security attribute setting for slave ports 2 */
+#define	SEC_SEL2	(LIFEC_SEC_BASE + 0x0038U)
+/* Security attribute setting for slave ports 3 */
+#define	SEC_SEL3	(LIFEC_SEC_BASE + 0x003CU)
+/* Security attribute setting for slave ports 4 */
+#define	SEC_SEL4	(LIFEC_SEC_BASE + 0x0058U)
+/* Security attribute setting for slave ports 5 */
+#define	SEC_SEL5	(LIFEC_SEC_BASE + 0x005CU)
+/* Security attribute setting for slave ports 6 */
+#define SEC_SEL6	(LIFEC_SEC_BASE + 0x0060U)
+/* Security attribute setting for slave ports 7 */
+#define	SEC_SEL7	(LIFEC_SEC_BASE + 0x0064U)
+/* Security attribute setting for slave ports 8 */
+#define	SEC_SEL8	(LIFEC_SEC_BASE + 0x0068U)
+/* Security attribute setting for slave ports 9 */
+#define	SEC_SEL9	(LIFEC_SEC_BASE + 0x006CU)
+/* Security attribute setting for slave ports 10 */
+#define	SEC_SEL10	(LIFEC_SEC_BASE + 0x0070U)
+/* Security attribute setting for slave ports 11 */
+#define	SEC_SEL11	(LIFEC_SEC_BASE + 0x0074U)
+/* Security attribute setting for slave ports 12 */
+#define	SEC_SEL12	(LIFEC_SEC_BASE + 0x0078U)
+/* Security attribute setting for slave ports 13 */
+#define	SEC_SEL13	(LIFEC_SEC_BASE + 0x007CU)
+/* Security attribute setting for slave ports 14 */
+#define	SEC_SEL14	(LIFEC_SEC_BASE + 0x0080U)
+/* Security attribute setting for slave ports 15 */
+#define	SEC_SEL15	(LIFEC_SEC_BASE + 0x0084U)
+/* Security group 0 attribute setting for master ports 0 */
+#define	SEC_GRP0CR0	(LIFEC_SEC_BASE + 0x0138U)
+/* Security group 1 attribute setting for master ports 0 */
+#define	SEC_GRP1CR0	(LIFEC_SEC_BASE + 0x013CU)
+/* Security group 0 attribute setting for master ports 1 */
+#define	SEC_GRP0CR1	(LIFEC_SEC_BASE + 0x0140U)
+/* Security group 1 attribute setting for master ports 1 */
+#define	SEC_GRP1CR1	(LIFEC_SEC_BASE + 0x0144U)
+/* Security group 0 attribute setting for master ports 2 */
+#define	SEC_GRP0CR2	(LIFEC_SEC_BASE + 0x0148U)
+/* Security group 1 attribute setting for master ports 2 */
+#define	SEC_GRP1CR2	(LIFEC_SEC_BASE + 0x014CU)
+/* Security group 0 attribute setting for master ports 3 */
+#define	SEC_GRP0CR3	(LIFEC_SEC_BASE + 0x0150U)
+/* Security group 1 attribute setting for master ports 3 */
+#define	SEC_GRP1CR3	(LIFEC_SEC_BASE + 0x0154U)
+/* Security group 0 attribute setting for slave ports 0 */
+#define	SEC_GRP0COND0	(LIFEC_SEC_BASE + 0x0158U)
+/* Security group 1 attribute setting for slave ports 0 */
+#define	SEC_GRP1COND0	(LIFEC_SEC_BASE + 0x015CU)
+/* Security group 0 attribute setting for slave ports 1 */
+#define	SEC_GRP0COND1	(LIFEC_SEC_BASE + 0x0160U)
+/* Security group 1 attribute setting for slave ports 1 */
+#define	SEC_GRP1COND1	(LIFEC_SEC_BASE + 0x0164U)
+/* Security group 0 attribute setting for slave ports 2 */
+#define	SEC_GRP0COND2	(LIFEC_SEC_BASE + 0x0168U)
+/* Security group 1 attribute setting for slave ports 2 */
+#define	SEC_GRP1COND2	(LIFEC_SEC_BASE + 0x016CU)
+/* Security group 0 attribute setting for slave ports 3 */
+#define	SEC_GRP0COND3	(LIFEC_SEC_BASE + 0x0170U)
+/* Security group 1 attribute setting for slave ports 3 */
+#define	SEC_GRP1COND3	(LIFEC_SEC_BASE + 0x0174U)
+/* Security group 0 attribute setting for slave ports 4 */
+#define	SEC_GRP0COND4	(LIFEC_SEC_BASE + 0x0178U)
+/* Security group 1 attribute setting for slave ports 4 */
+#define	SEC_GRP1COND4	(LIFEC_SEC_BASE + 0x017CU)
+/* Security group 0 attribute setting for slave ports 5 */
+#define	SEC_GRP0COND5	(LIFEC_SEC_BASE + 0x0180U)
+/* Security group 1 attribute setting for slave ports 5 */
+#define	SEC_GRP1COND5	(LIFEC_SEC_BASE + 0x0184U)
+/* Security group 0 attribute setting for slave ports 6 */
+#define	SEC_GRP0COND6	(LIFEC_SEC_BASE + 0x0188U)
+/* Security group 1 attribute setting for slave ports 6 */
+#define	SEC_GRP1COND6	(LIFEC_SEC_BASE + 0x018CU)
+/* Security group 0 attribute setting for slave ports 7 */
+#define	SEC_GRP0COND7	(LIFEC_SEC_BASE + 0x0190U)
+/* Security group 1 attribute setting for slave ports 7 */
+#define	SEC_GRP1COND7	(LIFEC_SEC_BASE + 0x0194U)
+/* Security group 0 attribute setting for slave ports 8 */
+#define	SEC_GRP0COND8	(LIFEC_SEC_BASE + 0x0198U)
+/* Security group 1 attribute setting for slave ports 8 */
+#define	SEC_GRP1COND8	(LIFEC_SEC_BASE + 0x019CU)
+/* Security group 0 attribute setting for slave ports 9 */
+#define	SEC_GRP0COND9	(LIFEC_SEC_BASE + 0x01A0U)
+/* Security group 1 attribute setting for slave ports 9 */
+#define	SEC_GRP1COND9	(LIFEC_SEC_BASE + 0x01A4U)
+/* Security group 0 attribute setting for slave ports 10 */
+#define	SEC_GRP0COND10	(LIFEC_SEC_BASE + 0x01A8U)
+/* Security group 1 attribute setting for slave ports 10 */
+#define	SEC_GRP1COND10	(LIFEC_SEC_BASE + 0x01ACU)
+/* Security group 0 attribute setting for slave ports 11 */
+#define	SEC_GRP0COND11	(LIFEC_SEC_BASE + 0x01B0U)
+/* Security group 1 attribute setting for slave ports 11 */
+#define	SEC_GRP1COND11	(LIFEC_SEC_BASE + 0x01B4U)
+/* Security group 0 attribute setting for slave ports 12 */
+#define	SEC_GRP0COND12	(LIFEC_SEC_BASE + 0x01B8U)
+/* Security group 1 attribute setting for slave ports 12 */
+#define	SEC_GRP1COND12	(LIFEC_SEC_BASE + 0x01BCU)
+/* Security group 0 attribute setting for slave ports 13 */
+#define	SEC_GRP0COND13	(LIFEC_SEC_BASE + 0x01C0U)
+/* Security group 1 attribute setting for slave ports 13 */
+#define	SEC_GRP1COND13	(LIFEC_SEC_BASE + 0x01C4U)
+/* Security group 0 attribute setting for slave ports 14 */
+#define	SEC_GRP0COND14	(LIFEC_SEC_BASE + 0x01C8U)
+/* Security group 1 attribute setting for slave ports 14 */
+#define	SEC_GRP1COND14	(LIFEC_SEC_BASE + 0x01CCU)
+/* Security group 0 attribute setting for slave ports 15 */
+#define	SEC_GRP0COND15	(LIFEC_SEC_BASE + 0x01D0U)
+/* Security group 1 attribute setting for slave ports 15 */
+#define	SEC_GRP1COND15	(LIFEC_SEC_BASE + 0x01D4U)
+/* Security write protection attribute setting for slave ports 0 */
+#define	SEC_READONLY0	(LIFEC_SEC_BASE + 0x01D8U)
+/* Security write protection attribute setting for slave ports 1 */
+#define	SEC_READONLY1	(LIFEC_SEC_BASE + 0x01DCU)
+/* Security write protection attribute setting for slave ports 2 */
+#define	SEC_READONLY2	(LIFEC_SEC_BASE + 0x01E0U)
+/* Security write protection attribute setting for slave ports 3 */
+#define	SEC_READONLY3	(LIFEC_SEC_BASE + 0x01E4U)
+/* Security write protection attribute setting for slave ports 4 */
+#define	SEC_READONLY4	(LIFEC_SEC_BASE + 0x01E8U)
+/* Security write protection attribute setting for slave ports 5 */
+#define	SEC_READONLY5	(LIFEC_SEC_BASE + 0x01ECU)
+/* Security write protection attribute setting for slave ports 6 */
+#define	SEC_READONLY6	(LIFEC_SEC_BASE + 0x01F0U)
+/* Security write protection attribute setting for slave ports 7 */
+#define	SEC_READONLY7	(LIFEC_SEC_BASE + 0x01F4U)
+/* Security write protection attribute setting for slave ports 8 */
+#define	SEC_READONLY8	(LIFEC_SEC_BASE + 0x01F8U)
+/* Security write protection attribute setting for slave ports 9 */
+#define	SEC_READONLY9	(LIFEC_SEC_BASE + 0x01FCU)
+/* Security write protection attribute setting for slave ports 10 */
+#define	SEC_READONLY10	(LIFEC_SEC_BASE + 0x0200U)
+/* Security write protection attribute setting for slave ports 11 */
+#define	SEC_READONLY11	(LIFEC_SEC_BASE + 0x0204U)
+/* Security write protection attribute setting for slave ports 12 */
+#define	SEC_READONLY12	(LIFEC_SEC_BASE + 0x0208U)
+/* Security write protection attribute setting for slave ports 13 */
+#define	SEC_READONLY13	(LIFEC_SEC_BASE + 0x020CU)
+/* Security write protection attribute setting for slave ports 14 */
+#define	SEC_READONLY14	(LIFEC_SEC_BASE + 0x0210U)
+/* Security write protection attribute setting for slave ports 15 */
+#define	SEC_READONLY15	(LIFEC_SEC_BASE + 0x0214U)
+
+/* LIFEC1 (SAFETY) registers */
+
+/* LIFEC1 (SAFETY) base address */
+#define	LIFEC_SAFE_BASE	(0xE6120000U)
+
+/* Safety group 0 attribute setting for master ports 0 */
+#define	SAFE_GRP0CR0	(LIFEC_SAFE_BASE + 0x0138U)
+/* Safety group 1 attribute setting for master ports 0 */
+#define	SAFE_GRP1CR0	(LIFEC_SAFE_BASE + 0x013CU)
+/* Safety group 0 attribute setting for master ports 1 */
+#define	SAFE_GRP0CR1	(LIFEC_SAFE_BASE + 0x0140U)
+/* Safety group 1 attribute setting for master ports 1 */
+#define	SAFE_GRP1CR1	(LIFEC_SAFE_BASE + 0x0144U)
+/* Safety group 0 attribute setting for master ports 2 */
+#define	SAFE_GRP0CR2	(LIFEC_SAFE_BASE + 0x0148U)
+/* Safety group 1 attribute setting for master ports 2 */
+#define	SAFE_GRP1CR2	(LIFEC_SAFE_BASE + 0x014CU)
+/* Safety group 0 attribute setting for master ports 3 */
+#define	SAFE_GRP0CR3	(LIFEC_SAFE_BASE + 0x0150U)
+/* Safety group 1 attribute setting for master ports 3 */
+#define	SAFE_GRP1CR3	(LIFEC_SAFE_BASE + 0x0154U)
+/* Safety group 0 attribute setting for slave ports 0 */
+#define	SAFE_GRP0COND0	(LIFEC_SAFE_BASE + 0x0158U)
+/* Safety group 1 attribute setting for slave ports 0 */
+#define	SAFE_GRP1COND0	(LIFEC_SAFE_BASE + 0x015CU)
+/* Safety group 0 attribute setting for slave ports 1 */
+#define	SAFE_GRP0COND1	(LIFEC_SAFE_BASE + 0x0160U)
+/* Safety group 1 attribute setting for slave ports 1 */
+#define	SAFE_GRP1COND1	(LIFEC_SAFE_BASE + 0x0164U)
+/* Safety group 0 attribute setting for slave ports 2 */
+#define	SAFE_GRP0COND2	(LIFEC_SAFE_BASE + 0x0168U)
+/* Safety group 1 attribute setting for slave ports 2 */
+#define	SAFE_GRP1COND2	(LIFEC_SAFE_BASE + 0x016CU)
+/* Safety group 0 attribute setting for slave ports 3 */
+#define	SAFE_GRP0COND3	(LIFEC_SAFE_BASE + 0x0170U)
+/* Safety group 1 attribute setting for slave ports 3 */
+#define	SAFE_GRP1COND3	(LIFEC_SAFE_BASE + 0x0174U)
+/* Safety group 0 attribute setting for slave ports 4 */
+#define	SAFE_GRP0COND4	(LIFEC_SAFE_BASE + 0x0178U)
+/* Safety group 1 attribute setting for slave ports 4 */
+#define	SAFE_GRP1COND4	(LIFEC_SAFE_BASE + 0x017CU)
+/* Safety group 0 attribute setting for slave ports 5 */
+#define	SAFE_GRP0COND5	(LIFEC_SAFE_BASE + 0x0180U)
+/* Safety group 1 attribute setting for slave ports 5 */
+#define	SAFE_GRP1COND5	(LIFEC_SAFE_BASE + 0x0184U)
+/* Safety group 0 attribute setting for slave ports 6 */
+#define	SAFE_GRP0COND6	(LIFEC_SAFE_BASE + 0x0188U)
+/* Safety group 1 attribute setting for slave ports 6 */
+#define	SAFE_GRP1COND6	(LIFEC_SAFE_BASE + 0x018CU)
+/* Safety group 0 attribute setting for slave ports 7 */
+#define	SAFE_GRP0COND7	(LIFEC_SAFE_BASE + 0x0190U)
+/* Safety group 1 attribute setting for slave ports 7 */
+#define	SAFE_GRP1COND7	(LIFEC_SAFE_BASE + 0x0194U)
+/* Safety group 0 attribute setting for slave ports 8 */
+#define	SAFE_GRP0COND8	(LIFEC_SAFE_BASE + 0x0198U)
+/* Safety group 1 attribute setting for slave ports 8 */
+#define	SAFE_GRP1COND8	(LIFEC_SAFE_BASE + 0x019CU)
+/* Safety group 0 attribute setting for slave ports 9 */
+#define	SAFE_GRP0COND9	(LIFEC_SAFE_BASE + 0x01A0U)
+/* Safety group 1 attribute setting for slave ports 9 */
+#define	SAFE_GRP1COND9	(LIFEC_SAFE_BASE + 0x01A4U)
+/* Safety group 0 attribute setting for slave ports 10 */
+#define	SAFE_GRP0COND10	(LIFEC_SAFE_BASE + 0x01A8U)
+/* Safety group 1 attribute setting for slave ports 10 */
+#define	SAFE_GRP1COND10	(LIFEC_SAFE_BASE + 0x01ACU)
+/* Safety group 0 attribute setting for slave ports 11 */
+#define	SAFE_GRP0COND11	(LIFEC_SAFE_BASE + 0x01B0U)
+/* Safety group 1 attribute setting for slave ports 11 */
+#define	SAFE_GRP1COND11	(LIFEC_SAFE_BASE + 0x01B4U)
+/* Safety group 0 attribute setting for slave ports 12 */
+#define	SAFE_GRP0COND12	(LIFEC_SAFE_BASE + 0x01B8U)
+/* Safety group 1 attribute setting for slave ports 12 */
+#define	SAFE_GRP1COND12	(LIFEC_SAFE_BASE + 0x01BCU)
+/* Safety group 0 attribute setting for slave ports 13 */
+#define	SAFE_GRP0COND13	(LIFEC_SAFE_BASE + 0x01C0U)
+/* Safety group 1 attribute setting for slave ports 13 */
+#define	SAFE_GRP1COND13	(LIFEC_SAFE_BASE + 0x01C4U)
+/* Safety group 0 attribute setting for slave ports 14 */
+#define	SAFE_GRP0COND14	(LIFEC_SAFE_BASE + 0x01C8U)
+/* Safety group 1 attribute setting for slave ports 14 */
+#define	SAFE_GRP1COND14	(LIFEC_SAFE_BASE + 0x01CCU)
+/* Safety group 0 attribute setting for slave ports 15 */
+#define	SAFE_GRP0COND15	(LIFEC_SAFE_BASE + 0x01D0U)
+/* Safety group 1 attribute setting for slave ports 15 */
+#define	SAFE_GRP1COND15	(LIFEC_SAFE_BASE + 0x01D4U)
+/* Safety write protection attribute setting for slave ports 0 */
+#define	SAFE_READONLY0	(LIFEC_SAFE_BASE + 0x01D8U)
+/* Safety write protection attribute setting for slave ports 1 */
+#define	SAFE_READONLY1	(LIFEC_SAFE_BASE + 0x01DCU)
+/* Safety write protection attribute setting for slave ports 2 */
+#define	SAFE_READONLY2	(LIFEC_SAFE_BASE + 0x01E0U)
+/* Safety write protection attribute setting for slave ports 3 */
+#define	SAFE_READONLY3	(LIFEC_SAFE_BASE + 0x01E4U)
+/* Safety write protection attribute setting for slave ports 4 */
+#define	SAFE_READONLY4	(LIFEC_SAFE_BASE + 0x01E8U)
+/* Safety write protection attribute setting for slave ports 5 */
+#define	SAFE_READONLY5	(LIFEC_SAFE_BASE + 0x01ECU)
+/* Safety write protection attribute setting for slave ports 6 */
+#define	SAFE_READONLY6	(LIFEC_SAFE_BASE + 0x01F0U)
+/* Safety write protection attribute setting for slave ports 7 */
+#define	SAFE_READONLY7	(LIFEC_SAFE_BASE + 0x01F4U)
+/* Safety write protection attribute setting for slave ports 8 */
+#define	SAFE_READONLY8	(LIFEC_SAFE_BASE + 0x01F8U)
+/* Safety write protection attribute setting for slave ports 9 */
+#define	SAFE_READONLY9	(LIFEC_SAFE_BASE + 0x01FCU)
+/* Safety write protection attribute setting for slave ports 10 */
+#define	SAFE_READONLY10	(LIFEC_SAFE_BASE + 0x0200U)
+/* Safety write protection attribute setting for slave ports 11 */
+#define	SAFE_READONLY11	(LIFEC_SAFE_BASE + 0x0204U)
+/* Safety write protection attribute setting for slave ports 12 */
+#define	SAFE_READONLY12	(LIFEC_SAFE_BASE + 0x0208U)
+/* Safety write protection attribute setting for slave ports 13 */
+#define	SAFE_READONLY13	(LIFEC_SAFE_BASE + 0x020CU)
+/* Safety write protection attribute setting for slave ports 14 */
+#define	SAFE_READONLY14	(LIFEC_SAFE_BASE + 0x0210U)
+/* Safety write protection attribute setting for slave ports 15 */
+#define	SAFE_READONLY15	(LIFEC_SAFE_BASE + 0x0214U)
+
+#endif	/* BL2_LIFEC_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_rpc_register.h b/plat/renesas/rcar/include/bl2_rpc_register.h
new file mode 100644
index 0000000..f9d4532
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_rpc_register.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_RPC_REGISTER_H__
+#define BL2_RPC_REGISTER_H__
+
+/* RPC base address */
+#define RPC_BASE	(0xEE200000U)
+
+/* RPC common control */
+#define RPC_CMNCR	(RPC_BASE + 0x0000U)
+/* RPC ssl delay */
+#define RPC_SSLDR	(RPC_BASE + 0x0004U)
+/* RPC data read control */
+#define RPC_DRCR	(RPC_BASE + 0x000CU)
+/* RPC data read command setting */
+#define RPC_DRCMR	(RPC_BASE + 0x0010U)
+/* RPC data read enable setting */
+#define RPC_DRENR	(RPC_BASE + 0x001CU)
+
+/* RPC manual mode control */
+#define RPC_SMCR	(RPC_BASE + 0x0020U)
+/* RPC manual mode command setting */
+#define RPC_SMCMR	(RPC_BASE + 0x0024U)
+/* RPC manual mode enable setting */
+#define RPC_SMENR	(RPC_BASE + 0x0030U)
+
+/* RPC common status */
+#define RPC_CMNSR	(RPC_BASE + 0x0048U)
+/* RPC data read dummy cycle setting */
+#define RPC_DRDMCR	(RPC_BASE + 0x0058U)
+/* RPC data read ddr enable */
+#define RPC_DRDRENR	(RPC_BASE + 0x005CU)
+
+/* RPC phy control */
+#define RPC_PHYCNT	(RPC_BASE + 0x007CU)
+/* RPC phy interrupt */
+#define RPC_PHYINT	(RPC_BASE + 0x0088U)
+
+#endif	/* BL2_RPC_REGISTER_H__ */
diff --git a/plat/renesas/rcar/include/bl2_secure_setting.h b/plat/renesas/rcar/include/bl2_secure_setting.h
new file mode 100644
index 0000000..f69d5b3
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_secure_setting.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	BL2_SECURE_SETTING_H__
+#define	BL2_SECURE_SETTING_H__
+
+void bl2_secure_setting(void);
+
+#endif	/* BL2_SECURE_SETTING_H__ */
diff --git a/plat/renesas/rcar/include/bl2_swdt.h b/plat/renesas/rcar/include/bl2_swdt.h
new file mode 100644
index 0000000..ea4aed0
--- /dev/null
+++ b/plat/renesas/rcar/include/bl2_swdt.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef BL2_SWDT_H__
+#define BL2_SWDT_H__
+
+void bl2_swdt_init(void);
+
+void bl2_swdt_enable(void);
+
+void bl2_swdt_release(void);
+
+void bl2_swdt_exec(uint64_t addr);
+
+#endif /* BL2_SWDT_H__ */
diff --git a/plat/renesas/rcar/include/dma_driver.h b/plat/renesas/rcar/include/dma_driver.h
new file mode 100644
index 0000000..85c0718
--- /dev/null
+++ b/plat/renesas/rcar/include/dma_driver.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DMA_DRIVER_H__
+#define DMA_DRIVER_H__
+
+#include <stdint.h>
+
+#if 0	/* for QAC */
+#ifndef DEBUG
+#define DEBUG 0
+#endif
+#endif	/* for QAC */
+
+void initDMA(void);
+void execDMA(uint32_t dst, uint32_t src, uint32_t len);
+#if DEBUG
+void termDMA(void);
+#endif
+
+#endif	/* DMA_DRIVER_H__ */
diff --git a/plat/renesas/rcar/include/io_common.h b/plat/renesas/rcar/include/io_common.h
new file mode 100644
index 0000000..1619ad2
--- /dev/null
+++ b/plat/renesas/rcar/include/io_common.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2014 ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_COMMON_H__
+#define IO_COMMON_H__
+
+extern void rcar_io_setup (void);
+extern int plat_get_image_source(unsigned int image_id,
+			uintptr_t *dev_handle,
+			uintptr_t *image_spec);
+
+
+#endif /* IO_COMMON_H__ */
diff --git a/plat/renesas/rcar/include/io_memdrv.h b/plat/renesas/rcar/include/io_memdrv.h
new file mode 100644
index 0000000..4eafa5e
--- /dev/null
+++ b/plat/renesas/rcar/include/io_memdrv.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_MEMDRV_H__
+#define IO_MEMDRV_H__
+
+struct io_dev_connector;
+
+int32_t register_io_dev_memdrv(const io_dev_connector_t **dev_con);
+
+#endif /* IO_MEMDRV_H__ */
diff --git a/plat/renesas/rcar/include/io_rcar.h b/plat/renesas/rcar/include/io_rcar.h
new file mode 100644
index 0000000..b176112
--- /dev/null
+++ b/plat/renesas/rcar/include/io_rcar.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2014 ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef IO_RCAR_H__
+#define IO_RCAR_H__
+
+int32_t register_io_dev_rcar(const io_dev_connector_t **dev_con);
+int32_t file_to_cert(const int32_t filename, uint32_t *cert_addr);
+void get_info_from_cert(uint64_t cert_addr, uint32_t *size, uint32_t *dest_addr);
+
+#endif /* IO_FIP_H__ */
diff --git a/plat/renesas/rcar/include/pfc_init.h b/plat/renesas/rcar/include/pfc_init.h
new file mode 100644
index 0000000..a8c982e
--- /dev/null
+++ b/plat/renesas/rcar/include/pfc_init.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PFC_INIT_H__
+#define PFC_INIT_H__
+
+void pfc_init(void);
+
+#endif	/* PFC_INIT_H__ */
diff --git a/plat/renesas/rcar/include/plat_macros.S b/plat/renesas/rcar/include/plat_macros.S
new file mode 100644
index 0000000..4db1bc3
--- /dev/null
+++ b/plat/renesas/rcar/include/plat_macros.S
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <cci.h>
+#include <gic_v2.h>
+#include "../rcar_def.h"
+
+.section .rodata.gic_reg_name, "aS"
+gicc_regs:
+	.asciz "gicc_hppir", "gicc_ahppir", "gicc_ctlr", ""
+gicd_pend_reg:
+	.asciz "gicd_ispendr regs (Offsets 0x200 - 0x278)\n Offset:\t\t\tvalue\n"
+newline:
+	.asciz "\n"
+spacer:
+	.asciz ":\t\t0x"
+
+	/* ---------------------------------------------
+	 * The below macro prints out relevant GIC
+	 * registers whenever an unhandled exception is
+	 * taken in BL3-1.
+	 * Clobbers: x0 - x10, x16, x17, sp
+	 * ---------------------------------------------
+	 */
+	.macro plat_print_gic_regs
+	mov_imm	x17, RCAR_GICC_BASE_A
+	mov_imm	x16, RCAR_GICD_BASE_A
+print_gicc_regs:
+	/* gicc base address is now in x17 */
+	adr	x6, gicc_regs	/* Load the gicc reg list to x6 */
+	/* Load the gicc regs to gp regs used by str_in_crash_buf_print */
+	ldr	w8, [x17, #GICC_HPPIR]
+	ldr	w9, [x17, #GICC_AHPPIR]
+	ldr	w10, [x17, #GICC_CTLR]
+	/* Store to the crash buf and print to console */
+	bl	str_in_crash_buf_print
+
+	/* Print the GICD_ISPENDR regs */
+	add	x7, x16, #GICD_ISPENDR
+	adr	x4, gicd_pend_reg
+	bl	asm_print_str
+gicd_ispendr_loop:
+	sub	x4, x7, x16
+	cmp	x4, #0x280
+	b.eq	exit_print_gic_regs
+	bl	asm_print_hex
+	adr	x4, spacer
+	bl	asm_print_str
+	ldr	x4, [x7], #8
+	bl	asm_print_hex
+	adr	x4, newline
+	bl	asm_print_str
+	b	gicd_ispendr_loop
+exit_print_gic_regs:
+	.endm
+
+.section .rodata.cci_reg_name, "aS"
+cci_iface_regs:
+	.asciz "cci_snoop_ctrl_cluster0", "cci_snoop_ctrl_cluster1" , ""
+
+	/* ------------------------------------------------
+	 * The below macro prints out relevant interconnect
+	 * registers whenever an unhandled exception is
+	 * taken in BL3-1.
+	 * Clobbers: x0 - x9, sp
+	 * ------------------------------------------------
+	 */
+	.macro plat_print_interconnect_regs
+	adr	x6, cci_iface_regs
+	/* Store in x7 the base address of the first interface */
+	mov_imm	x7, (CCI500_BASE + SLAVE_IFACE3_OFFSET)
+	ldr	w8, [x7, #SNOOP_CTRL_REG]
+	/* Store in x7 the base address of the second interface */
+	mov_imm	x7, (CCI500_BASE + SLAVE_IFACE4_OFFSET)
+	ldr	w9, [x7, #SNOOP_CTRL_REG]
+	/* Store to the crash buf and print to console */
+	bl	str_in_crash_buf_print
+	.endm
diff --git a/plat/renesas/rcar/include/platform.h b/plat/renesas/rcar/include/platform.h
new file mode 100644
index 0000000..8ddfaad
--- /dev/null
+++ b/plat/renesas/rcar/include/platform.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PLATFORM_H__
+#define RCAR_PLATFORM_H__
+
+#include <stdint.h>
+
+
+/*******************************************************************************
+ * Forward declarations
+ ******************************************************************************/
+struct plat_pm_ops;
+struct meminfo;
+struct image_info;
+struct entry_point_info;
+struct bl31_params;
+
+/*******************************************************************************
+ * Function declarations
+ ******************************************************************************/
+/*******************************************************************************
+ * Mandatory common functions
+ ******************************************************************************/
+uint64_t plat_get_syscnt_freq(void);
+int plat_get_image_source(const char *image_name,
+			uintptr_t *dev_handle,
+			uintptr_t *image_spec);
+unsigned long plat_get_ns_image_entrypoint(void);
+
+/*******************************************************************************
+ * Mandatory interrupt management functions
+ ******************************************************************************/
+uint32_t plat_ic_get_pending_interrupt_id(void);
+uint32_t plat_ic_get_pending_interrupt_type(void);
+uint32_t plat_ic_acknowledge_interrupt(void);
+uint32_t plat_ic_get_interrupt_type(uint32_t id);
+void plat_ic_end_of_interrupt(uint32_t id);
+uint32_t plat_interrupt_type_to_line(uint32_t type,
+				     uint32_t security_state);
+
+/*******************************************************************************
+ * Optional common functions (may be overridden)
+ ******************************************************************************/
+unsigned int platform_get_core_pos(unsigned long mpidr);
+unsigned long platform_get_stack(unsigned long mpidr);
+void plat_report_exception(unsigned long);
+int plat_crash_console_init(void);
+int plat_crash_console_putc(int c);
+
+/*******************************************************************************
+ * Mandatory BL1 functions
+ ******************************************************************************/
+void bl1_early_platform_setup(void);
+void bl1_plat_arch_setup(void);
+void bl1_platform_setup(void);
+struct meminfo *bl1_plat_sec_mem_layout(void);
+
+/*
+ * This function allows the platform to change the entrypoint information for
+ * BL2, after BL1 has loaded BL2 into memory but before BL2 is executed.
+ */
+void bl1_plat_set_bl2_ep_info(struct image_info *image,
+			      struct entry_point_info *ep);
+
+/*******************************************************************************
+ * Optional BL1 functions (may be overridden)
+ ******************************************************************************/
+void bl1_init_bl2_mem_layout(const struct meminfo *bl1_mem_layout,
+			     struct meminfo *bl2_mem_layout);
+
+/*******************************************************************************
+ * Mandatory BL2 functions
+ ******************************************************************************/
+void bl2_early_platform_setup(struct meminfo *mem_layout);
+void bl2_plat_arch_setup(void);
+void bl2_platform_setup(void);
+struct meminfo *bl2_plat_sec_mem_layout(void);
+
+/*
+ * This function returns a pointer to the shared memory that the platform has
+ * kept aside to pass trusted firmware related information that BL3-1
+ * could need
+ */
+struct bl31_params *bl2_plat_get_bl31_params(void);
+
+/*
+ * This function returns a pointer to the shared memory that the platform
+ * has kept to point to entry point information of BL31 to BL2
+ */
+struct entry_point_info *bl2_plat_get_bl31_ep_info(void);
+
+/*
+ * This function flushes to main memory all the params that are
+ * passed to BL3-1
+ */
+void bl2_plat_flush_bl31_params(void);
+
+/*
+ * The next 2 functions allow the platform to change the entrypoint information
+ * for the mandatory 3rd level BL images, BL3-1 and BL3-3. This is done after
+ * BL2 has loaded those images into memory but before BL3-1 is executed.
+ */
+void bl2_plat_set_bl31_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+void bl2_plat_set_bl33_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+/* Gets the memory layout for BL3-3 */
+void bl2_plat_get_bl33_meminfo(struct meminfo *mem_info);
+
+/*******************************************************************************
+ * Conditionally mandatory BL2 functions: must be implemented if BL3-0 image
+ * is supported
+ ******************************************************************************/
+/* Gets the memory layout for BL3-0 */
+void bl2_plat_get_bl30_meminfo(struct meminfo *mem_info);
+
+/*
+ * This function is called after loading BL3-0 image and it is used to perform
+ * any platform-specific actions required to handle the SCP firmware.
+ */
+int bl2_plat_handle_bl30(struct image_info *bl30_image_info);
+
+/*******************************************************************************
+ * Conditionally mandatory BL2 functions: must be implemented if BL3-2 image
+ * is supported
+ ******************************************************************************/
+void bl2_plat_set_bl32_ep_info(struct image_info *image,
+			       struct entry_point_info *ep);
+
+/* Gets the memory layout for BL3-2 */
+void bl2_plat_get_bl32_meminfo(struct meminfo *mem_info);
+
+/*******************************************************************************
+ * Optional BL2 functions (may be overridden)
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Mandatory BL3-1 functions
+ ******************************************************************************/
+void bl31_early_platform_setup(struct bl31_params *from_bl2,
+				void *plat_params_from_bl2);
+void bl31_plat_arch_setup(void);
+void bl31_platform_setup(void);
+struct entry_point_info *bl31_plat_get_next_image_ep_info(uint32_t type);
+
+/*******************************************************************************
+ * Mandatory PSCI functions (BL3-1)
+ ******************************************************************************/
+int platform_setup_pm(const struct plat_pm_ops **);
+unsigned int plat_get_aff_count(unsigned int, unsigned long);
+unsigned int plat_get_aff_state(unsigned int, unsigned long);
+
+/*******************************************************************************
+ * Optional BL3-1 functions (may be overridden)
+ ******************************************************************************/
+void bl31_plat_enable_mmu(uint32_t flags);
+
+/*******************************************************************************
+ * Optional BL3-2 functions (may be overridden)
+ ******************************************************************************/
+void bl32_plat_enable_mmu(uint32_t flags);
+
+/*******************************************************************************
+ * Trusted Boot functions
+ ******************************************************************************/
+int plat_match_rotpk(const unsigned char *, unsigned int);
+
+#endif /* RCAR_PLATFORM_H__ */
diff --git a/plat/renesas/rcar/include/platform_def.h b/plat/renesas/rcar/include/platform_def.h
new file mode 100644
index 0000000..1803ae7
--- /dev/null
+++ b/plat/renesas/rcar/include/platform_def.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PLATFORM_DEF_H__
+#define RCAR_PLATFORM_DEF_H__
+
+#include <arch.h>
+#ifndef __ASSEMBLY__
+#include <stdlib.h>
+#endif
+#include "../rcar_def.h"
+
+
+/*******************************************************************************
+ * Platform binary types for linking
+ ******************************************************************************/
+#define PLATFORM_LINKER_FORMAT          "elf64-littleaarch64"
+#define PLATFORM_LINKER_ARCH            aarch64
+
+/*******************************************************************************
+ * Generic platform constants
+ ******************************************************************************/
+
+/* Align the storing version code for BL2 and BL31 */
+#define	ALIGN_VERSION		(0x400)
+
+/* Size of cacheable stacks */
+#if IMAGE_BL1
+#if TRUSTED_BOARD_BOOT
+#define PLATFORM_STACK_SIZE 0x1000
+#else
+#define PLATFORM_STACK_SIZE 0x440
+#endif
+#elif IMAGE_BL2
+#if TRUSTED_BOARD_BOOT
+#define PLATFORM_STACK_SIZE 0x1000
+#else
+#define PLATFORM_STACK_SIZE 0x400
+#endif
+#elif IMAGE_BL31
+#define PLATFORM_STACK_SIZE 0x400
+#elif IMAGE_BL32
+#define PLATFORM_STACK_SIZE 0x440
+#endif
+
+#define FIRMWARE_WELCOME_STR		"Booting Trusted Firmware\n"
+
+#define BL332_IMAGE_ID			(BL33_CERT_ID + 1U)
+#define BL333_IMAGE_ID			(BL33_CERT_ID + 2U)
+#define BL334_IMAGE_ID			(BL33_CERT_ID + 3U)
+#define BL335_IMAGE_ID			(BL33_CERT_ID + 4U)
+#define BL336_IMAGE_ID			(BL33_CERT_ID + 5U)
+#define BL337_IMAGE_ID			(BL33_CERT_ID + 6U)
+#define BL338_IMAGE_ID			(BL33_CERT_ID + 7U)
+
+#define BL332_KEY_CERT_ID		(BL33_CERT_ID + 8U)
+#define BL333_KEY_CERT_ID		(BL33_CERT_ID + 9U)
+#define BL334_KEY_CERT_ID		(BL33_CERT_ID + 10U)
+#define BL335_KEY_CERT_ID		(BL33_CERT_ID + 11U)
+#define BL336_KEY_CERT_ID		(BL33_CERT_ID + 12U)
+#define BL337_KEY_CERT_ID		(BL33_CERT_ID + 13U)
+#define BL338_KEY_CERT_ID		(BL33_CERT_ID + 14U)
+
+#define BL332_CERT_ID			(BL33_CERT_ID + 15U)
+#define BL333_CERT_ID			(BL33_CERT_ID + 16U)
+#define BL334_CERT_ID			(BL33_CERT_ID + 17U)
+#define BL335_CERT_ID			(BL33_CERT_ID + 18U)
+#define BL336_CERT_ID			(BL33_CERT_ID + 19U)
+#define BL337_CERT_ID			(BL33_CERT_ID + 20U)
+#define BL338_CERT_ID			(BL33_CERT_ID + 21U)
+
+/*
+ * R-Car H3 Cortex-A57
+ * L1:I/48KB(16KBx3way) D/32KB(16KBx2way) L2:2MB(128KBx16way)
+ *          Cortex-A53
+ * L1:I/32KB(16KBx2way) D/32KB(8KBx4way) L2:512KB(32KBx16way)
+ */
+#define PLATFORM_CACHE_LINE_SIZE	128
+#define PLATFORM_CLUSTER_COUNT		2ull
+#define PLATFORM_CLUSTER0_CORE_COUNT	4
+#define PLATFORM_CLUSTER1_CORE_COUNT	4
+#define PLATFORM_CORE_COUNT		(PLATFORM_CLUSTER1_CORE_COUNT + \
+						PLATFORM_CLUSTER0_CORE_COUNT)
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	4
+#define PLATFORM_NUM_AFFS		(PLATFORM_CLUSTER_COUNT + \
+					 PLATFORM_CORE_COUNT)
+#define PLATFORM_MAX_AFFLVL		MPIDR_AFFLVL1
+#define MAX_IO_DEVICES			3
+#define MAX_IO_HANDLES			4
+
+/*******************************************************************************
+ * BL1 specific defines.
+ * BL1 RW data is relocated from ROM to RAM at runtime so we need 2 sets of
+ * addresses.
+ ******************************************************************************/
+#define BL1_RO_BASE			RCAR_TRUSTED_ROM_BASE
+#define BL1_RO_LIMIT			(RCAR_TRUSTED_ROM_BASE \
+					+ RCAR_TRUSTED_ROM_SIZE)
+/*
+ * Put BL1 RW at the top of the Trusted SRAM. BL1_RW_BASE is calculated using
+ * the current BL1 RW debug size plus a little space for growth.
+ */
+#if TRUSTED_BOARD_BOOT
+#define BL1_RW_BASE			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE - 0x8000)
+#else
+#define BL1_RW_BASE			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE - 0x6000)
+#endif
+#define BL1_RW_LIMIT			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE)
+
+/*******************************************************************************
+ * BL2 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL2 just below BL3-1. BL2_BASE is calculated using the current BL2 debug
+ * size plus a little space for growth.
+ */
+#define	RCAR_SECRAM_BASE		(0xE6300000)
+#if RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CA5X
+#define BL2_BASE			(0xE6302000)
+#define BL2_LIMIT			(0xE632E800)
+#elif RCAR_MASTER_BOOT_CPU == RCAR_BOOT_CR7
+#define BL2_BASE			(0x43F20000)
+#define BL2_LIMIT			(0x43F4C800)
+#endif
+
+/*******************************************************************************
+ * BL31 specific defines.
+ ******************************************************************************/
+/*
+ * Put BL3-1 at the top of the Trusted SRAM. BL31_BASE is calculated using the
+ * current BL3-1 debug size plus a little space for growth.
+ */
+#define BL31_BASE			(RCAR_TRUSTED_SRAM_BASE)
+#define BL31_LIMIT			(RCAR_TRUSTED_SRAM_BASE \
+					+ RCAR_TRUSTED_SRAM_SIZE)
+#define	RCAR_BL31_LOG_BASE		(0x44040000)
+#define	RCAR_BL31_SDRAM_BTM		(RCAR_BL31_LOG_BASE + 0x14000)
+#define	RCAR_BL31_LOG_SIZE		(RCAR_BL31_SDRAM_BTM \
+					- RCAR_BL31_LOG_BASE)
+
+/*******************************************************************************
+ * BL32 specific defines.
+ ******************************************************************************/
+
+# define BL32_BASE			(0x44100000)
+# define BL32_LIMIT			(BL32_BASE + 0x100000)
+/*
+ * ID of the secure physical generic timer interrupt used by the TSP.
+ */
+
+
+/*******************************************************************************
+ * Platform specific page table and MMU setup constants
+ ******************************************************************************/
+#define ADDR_SPACE_SIZE			(1ull << 32)
+
+#if IMAGE_BL1
+# define MAX_XLAT_TABLES		2
+#elif IMAGE_BL2
+# define MAX_XLAT_TABLES		3
+#elif IMAGE_BL31
+# define MAX_XLAT_TABLES		4
+#elif IMAGE_BL32
+#  define MAX_XLAT_TABLES		3
+#endif
+
+#define MAX_MMAP_REGIONS		(RCAR_MMAP_ENTRIES + RCAR_BL_REGIONS)
+
+/*******************************************************************************
+ * Declarations and constants to access the mailboxes safely. Each mailbox is
+ * aligned on the biggest cache line size in the platform. This is known only
+ * to the platform as it might have a combination of integrated and external
+ * caches. Such alignment ensures that two maiboxes do not sit on the same cache
+ * line at any cache level. They could belong to different cpus/clusters &
+ * get written while being protected by different locks causing corruption of
+ * a valid mailbox address.
+ ******************************************************************************/
+#define CACHE_WRITEBACK_SHIFT   6
+#define CACHE_WRITEBACK_GRANULE (1 << CACHE_WRITEBACK_SHIFT)
+
+#if !USE_COHERENT_MEM
+/*******************************************************************************
+ * Size of the per-cpu data in bytes that should be reserved in the generic
+ * per-cpu data structure for the RCAR port.
+ ******************************************************************************/
+#define PLAT_PCPU_DATA_SIZE	2
+#endif
+
+#endif /* RCAR_PLATFORM_DEF_H__ */
diff --git a/plat/renesas/rcar/include/rpc_driver.h b/plat/renesas/rcar/include/rpc_driver.h
new file mode 100644
index 0000000..0089504
--- /dev/null
+++ b/plat/renesas/rcar/include/rpc_driver.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RPC_DRIVER_H__
+#define RPC_DRIVER_H__
+
+#if 0	/* for QAC */
+#ifndef DEBUG
+#define DEBUG 0
+#endif
+#endif	/* for QAC */
+
+void initRPC(void);
+#if DEBUG
+void termRPC(void);
+#endif
+
+#endif	/* RPC_DRIVER_H__ */
diff --git a/plat/renesas/rcar/include/scif.h b/plat/renesas/rcar/include/scif.h
new file mode 100644
index 0000000..fe1fb25
--- /dev/null
+++ b/plat/renesas/rcar/include/scif.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SCIF_H__
+#define SCIF_H__
+
+
+#define	SCIF_INTERNAL_CLK	0	/* Internal clock(S3D4:66.66MHz) */
+#define	SCIF_EXTARNAL_CLK	1	/* External clock(SCK2:14.7456MHz) */
+#define	SCIF_CLK		SCIF_INTERNAL_CLK
+
+
+#ifndef __ASSEMBLY__
+
+void console_finalize(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif	/* SCIF_H__ */
diff --git a/plat/renesas/rcar/pfc/H3/pfc_init_h3.c b/plat/renesas/rcar/pfc/H3/pfc_init_h3.c
new file mode 100644
index 0000000..fc3160c
--- /dev/null
+++ b/plat/renesas/rcar/pfc/H3/pfc_init_h3.c
@@ -0,0 +1,1352 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>		/* for uint32_t */
+#include <mmio.h>
+#include "pfc_init_h3.h"
+
+
+/* GPIO base address */
+#define	GPIO_BASE		(0xE6050000U)
+
+/* GPIO registers */
+#define	GPIO_IOINTSEL0		(GPIO_BASE + 0x0000U)
+#define	GPIO_INOUTSEL0		(GPIO_BASE + 0x0004U)
+#define	GPIO_OUTDT0		(GPIO_BASE + 0x0008U)
+#define	GPIO_INDT0		(GPIO_BASE + 0x000CU)
+#define	GPIO_INTDT0		(GPIO_BASE + 0x0010U)
+#define	GPIO_INTCLR0		(GPIO_BASE + 0x0014U)
+#define	GPIO_INTMSK0		(GPIO_BASE + 0x0018U)
+#define	GPIO_MSKCLR0		(GPIO_BASE + 0x001CU)
+#define	GPIO_POSNEG0		(GPIO_BASE + 0x0020U)
+#define	GPIO_EDGLEVEL0		(GPIO_BASE + 0x0024U)
+#define	GPIO_FILONOFF0		(GPIO_BASE + 0x0028U)
+#define	GPIO_INTMSKS0		(GPIO_BASE + 0x0038U)
+#define	GPIO_MSKCLRS0		(GPIO_BASE + 0x003CU)
+#define	GPIO_OUTDTSEL0		(GPIO_BASE + 0x0040U)
+#define	GPIO_OUTDTH0		(GPIO_BASE + 0x0044U)
+#define	GPIO_OUTDTL0		(GPIO_BASE + 0x0048U)
+#define	GPIO_BOTHEDGE0		(GPIO_BASE + 0x004CU)
+#define	GPIO_IOINTSEL1		(GPIO_BASE + 0x1000U)
+#define	GPIO_INOUTSEL1		(GPIO_BASE + 0x1004U)
+#define	GPIO_OUTDT1		(GPIO_BASE + 0x1008U)
+#define	GPIO_INDT1		(GPIO_BASE + 0x100CU)
+#define	GPIO_INTDT1		(GPIO_BASE + 0x1010U)
+#define	GPIO_INTCLR1		(GPIO_BASE + 0x1014U)
+#define	GPIO_INTMSK1		(GPIO_BASE + 0x1018U)
+#define	GPIO_MSKCLR1		(GPIO_BASE + 0x101CU)
+#define	GPIO_POSNEG1		(GPIO_BASE + 0x1020U)
+#define	GPIO_EDGLEVEL1		(GPIO_BASE + 0x1024U)
+#define	GPIO_FILONOFF1		(GPIO_BASE + 0x1028U)
+#define	GPIO_INTMSKS1		(GPIO_BASE + 0x1038U)
+#define	GPIO_MSKCLRS1		(GPIO_BASE + 0x103CU)
+#define	GPIO_OUTDTSEL1		(GPIO_BASE + 0x1040U)
+#define	GPIO_OUTDTH1		(GPIO_BASE + 0x1044U)
+#define	GPIO_OUTDTL1		(GPIO_BASE + 0x1048U)
+#define	GPIO_BOTHEDGE1		(GPIO_BASE + 0x104CU)
+#define	GPIO_IOINTSEL2		(GPIO_BASE + 0x2000U)
+#define	GPIO_INOUTSEL2		(GPIO_BASE + 0x2004U)
+#define	GPIO_OUTDT2		(GPIO_BASE + 0x2008U)
+#define	GPIO_INDT2		(GPIO_BASE + 0x200CU)
+#define	GPIO_INTDT2		(GPIO_BASE + 0x2010U)
+#define	GPIO_INTCLR2		(GPIO_BASE + 0x2014U)
+#define	GPIO_INTMSK2		(GPIO_BASE + 0x2018U)
+#define	GPIO_MSKCLR2		(GPIO_BASE + 0x201CU)
+#define	GPIO_POSNEG2		(GPIO_BASE + 0x2020U)
+#define	GPIO_EDGLEVEL2		(GPIO_BASE + 0x2024U)
+#define	GPIO_FILONOFF2		(GPIO_BASE + 0x2028U)
+#define	GPIO_INTMSKS2		(GPIO_BASE + 0x2038U)
+#define	GPIO_MSKCLRS2		(GPIO_BASE + 0x203CU)
+#define	GPIO_OUTDTSEL2		(GPIO_BASE + 0x2040U)
+#define	GPIO_OUTDTH2		(GPIO_BASE + 0x2044U)
+#define	GPIO_OUTDTL2		(GPIO_BASE + 0x2048U)
+#define	GPIO_BOTHEDGE2		(GPIO_BASE + 0x204CU)
+#define	GPIO_IOINTSEL3		(GPIO_BASE + 0x3000U)
+#define	GPIO_INOUTSEL3		(GPIO_BASE + 0x3004U)
+#define	GPIO_OUTDT3		(GPIO_BASE + 0x3008U)
+#define	GPIO_INDT3		(GPIO_BASE + 0x300CU)
+#define	GPIO_INTDT3		(GPIO_BASE + 0x3010U)
+#define	GPIO_INTCLR3		(GPIO_BASE + 0x3014U)
+#define	GPIO_INTMSK3		(GPIO_BASE + 0x3018U)
+#define	GPIO_MSKCLR3		(GPIO_BASE + 0x301CU)
+#define	GPIO_POSNEG3		(GPIO_BASE + 0x3020U)
+#define	GPIO_EDGLEVEL3		(GPIO_BASE + 0x3024U)
+#define	GPIO_FILONOFF3		(GPIO_BASE + 0x3028U)
+#define	GPIO_INTMSKS3		(GPIO_BASE + 0x3038U)
+#define	GPIO_MSKCLRS3		(GPIO_BASE + 0x303CU)
+#define	GPIO_OUTDTSEL3		(GPIO_BASE + 0x3040U)
+#define	GPIO_OUTDTH3		(GPIO_BASE + 0x3044U)
+#define	GPIO_OUTDTL3		(GPIO_BASE + 0x3048U)
+#define	GPIO_BOTHEDGE3		(GPIO_BASE + 0x304CU)
+#define	GPIO_IOINTSEL4		(GPIO_BASE + 0x4000U)
+#define	GPIO_INOUTSEL4		(GPIO_BASE + 0x4004U)
+#define	GPIO_OUTDT4		(GPIO_BASE + 0x4008U)
+#define	GPIO_INDT4		(GPIO_BASE + 0x400CU)
+#define	GPIO_INTDT4		(GPIO_BASE + 0x4010U)
+#define	GPIO_INTCLR4		(GPIO_BASE + 0x4014U)
+#define	GPIO_INTMSK4		(GPIO_BASE + 0x4018U)
+#define	GPIO_MSKCLR4		(GPIO_BASE + 0x401CU)
+#define	GPIO_POSNEG4		(GPIO_BASE + 0x4020U)
+#define	GPIO_EDGLEVEL4		(GPIO_BASE + 0x4024U)
+#define	GPIO_FILONOFF4		(GPIO_BASE + 0x4028U)
+#define	GPIO_INTMSKS4		(GPIO_BASE + 0x4038U)
+#define	GPIO_MSKCLRS4		(GPIO_BASE + 0x403CU)
+#define	GPIO_OUTDTSEL4		(GPIO_BASE + 0x4040U)
+#define	GPIO_OUTDTH4		(GPIO_BASE + 0x4044U)
+#define	GPIO_OUTDTL4		(GPIO_BASE + 0x4048U)
+#define	GPIO_BOTHEDGE4		(GPIO_BASE + 0x404CU)
+#define	GPIO_IOINTSEL5		(GPIO_BASE + 0x5000U)
+#define	GPIO_INOUTSEL5		(GPIO_BASE + 0x5004U)
+#define	GPIO_OUTDT5		(GPIO_BASE + 0x5008U)
+#define	GPIO_INDT5		(GPIO_BASE + 0x500CU)
+#define	GPIO_INTDT5		(GPIO_BASE + 0x5010U)
+#define	GPIO_INTCLR5		(GPIO_BASE + 0x5014U)
+#define	GPIO_INTMSK5		(GPIO_BASE + 0x5018U)
+#define	GPIO_MSKCLR5		(GPIO_BASE + 0x501CU)
+#define	GPIO_POSNEG5		(GPIO_BASE + 0x5020U)
+#define	GPIO_EDGLEVEL5		(GPIO_BASE + 0x5024U)
+#define	GPIO_FILONOFF5		(GPIO_BASE + 0x5028U)
+#define	GPIO_INTMSKS5		(GPIO_BASE + 0x5038U)
+#define	GPIO_MSKCLRS5		(GPIO_BASE + 0x503CU)
+#define	GPIO_OUTDTSEL5		(GPIO_BASE + 0x5040U)
+#define	GPIO_OUTDTH5		(GPIO_BASE + 0x5044U)
+#define	GPIO_OUTDTL5		(GPIO_BASE + 0x5048U)
+#define	GPIO_BOTHEDGE5		(GPIO_BASE + 0x504CU)
+#define	GPIO_IOINTSEL6		(GPIO_BASE + 0x5400U)
+#define	GPIO_INOUTSEL6		(GPIO_BASE + 0x5404U)
+#define	GPIO_OUTDT6		(GPIO_BASE + 0x5408U)
+#define	GPIO_INDT6		(GPIO_BASE + 0x540CU)
+#define	GPIO_INTDT6		(GPIO_BASE + 0x5410U)
+#define	GPIO_INTCLR6		(GPIO_BASE + 0x5414U)
+#define	GPIO_INTMSK6		(GPIO_BASE + 0x5418U)
+#define	GPIO_MSKCLR6		(GPIO_BASE + 0x541CU)
+#define	GPIO_POSNEG6		(GPIO_BASE + 0x5420U)
+#define	GPIO_EDGLEVEL6		(GPIO_BASE + 0x5424U)
+#define	GPIO_FILONOFF6		(GPIO_BASE + 0x5428U)
+#define	GPIO_INTMSKS6		(GPIO_BASE + 0x5438U)
+#define	GPIO_MSKCLRS6		(GPIO_BASE + 0x543CU)
+#define	GPIO_OUTDTSEL6		(GPIO_BASE + 0x5440U)
+#define	GPIO_OUTDTH6		(GPIO_BASE + 0x5444U)
+#define	GPIO_OUTDTL6		(GPIO_BASE + 0x5448U)
+#define	GPIO_BOTHEDGE6		(GPIO_BASE + 0x544CU)
+#define	GPIO_IOINTSEL7		(GPIO_BASE + 0x5800U)
+#define	GPIO_INOUTSEL7		(GPIO_BASE + 0x5804U)
+#define	GPIO_OUTDT7		(GPIO_BASE + 0x5808U)
+#define	GPIO_INDT7		(GPIO_BASE + 0x580CU)
+#define	GPIO_INTDT7		(GPIO_BASE + 0x5810U)
+#define	GPIO_INTCLR7		(GPIO_BASE + 0x5814U)
+#define	GPIO_INTMSK7		(GPIO_BASE + 0x5818U)
+#define	GPIO_MSKCLR7		(GPIO_BASE + 0x581CU)
+#define	GPIO_POSNEG7		(GPIO_BASE + 0x5820U)
+#define	GPIO_EDGLEVEL7		(GPIO_BASE + 0x5824U)
+#define	GPIO_FILONOFF7		(GPIO_BASE + 0x5828U)
+#define	GPIO_INTMSKS7		(GPIO_BASE + 0x5838U)
+#define	GPIO_MSKCLRS7		(GPIO_BASE + 0x583CU)
+#define	GPIO_OUTDTSEL7		(GPIO_BASE + 0x5840U)
+#define	GPIO_OUTDTH7		(GPIO_BASE + 0x5844U)
+#define	GPIO_OUTDTL7		(GPIO_BASE + 0x5848U)
+#define	GPIO_BOTHEDGE7		(GPIO_BASE + 0x584CU)
+
+
+/* Pin functon base address */
+#define	PFC_BASE		(0xE6060000U)
+
+/* Pin functon registers */
+#define	PFC_PMMR		(PFC_BASE + 0x0000U)
+#define PFC_GPSR0		(PFC_BASE + 0x0100U)
+#define PFC_GPSR1		(PFC_BASE + 0x0104U)
+#define PFC_GPSR2		(PFC_BASE + 0x0108U)
+#define PFC_GPSR3		(PFC_BASE + 0x010CU)
+#define PFC_GPSR4		(PFC_BASE + 0x0110U)
+#define	PFC_GPSR5		(PFC_BASE + 0x0114U)
+#define	PFC_GPSR6		(PFC_BASE + 0x0118U)
+#define	PFC_GPSR7		(PFC_BASE + 0x011CU)
+#define	PFC_IPSR0		(PFC_BASE + 0x0200U)
+#define	PFC_IPSR1		(PFC_BASE + 0x0204U)
+#define	PFC_IPSR2		(PFC_BASE + 0x0208U)
+#define	PFC_IPSR3		(PFC_BASE + 0x020CU)
+#define	PFC_IPSR4		(PFC_BASE + 0x0210U)
+#define	PFC_IPSR5		(PFC_BASE + 0x0214U)
+#define	PFC_IPSR6		(PFC_BASE + 0x0218U)
+#define	PFC_IPSR7		(PFC_BASE + 0x021CU)
+#define	PFC_IPSR8		(PFC_BASE + 0x0220U)
+#define	PFC_IPSR9		(PFC_BASE + 0x0224U)
+#define	PFC_IPSR10		(PFC_BASE + 0x0228U)
+#define	PFC_IPSR11		(PFC_BASE + 0x022CU)
+#define	PFC_IPSR12		(PFC_BASE + 0x0230U)
+#define	PFC_IPSR13		(PFC_BASE + 0x0234U)
+#define	PFC_IPSR14		(PFC_BASE + 0x0238U)
+#define	PFC_IPSR15		(PFC_BASE + 0x023CU)
+#define	PFC_IPSR16		(PFC_BASE + 0x0240U)
+#define	PFC_IPSR17		(PFC_BASE + 0x0244U)
+#define PFC_DRVCTRL0		(PFC_BASE + 0x0300U)
+#define PFC_DRVCTRL1		(PFC_BASE + 0x0304U)
+#define PFC_DRVCTRL2		(PFC_BASE + 0x0308U)
+#define PFC_DRVCTRL3		(PFC_BASE + 0x030CU)
+#define PFC_DRVCTRL4		(PFC_BASE + 0x0310U)
+#define PFC_DRVCTRL5		(PFC_BASE + 0x0314U)
+#define PFC_DRVCTRL6		(PFC_BASE + 0x0318U)
+#define PFC_DRVCTRL7		(PFC_BASE + 0x031CU)
+#define PFC_DRVCTRL8		(PFC_BASE + 0x0320U)
+#define PFC_DRVCTRL9		(PFC_BASE + 0x0324U)
+#define PFC_DRVCTRL10		(PFC_BASE + 0x0328U)
+#define PFC_DRVCTRL11		(PFC_BASE + 0x032CU)
+#define PFC_DRVCTRL12		(PFC_BASE + 0x0330U)
+#define PFC_DRVCTRL13		(PFC_BASE + 0x0334U)
+#define PFC_DRVCTRL14		(PFC_BASE + 0x0338U)
+#define PFC_DRVCTRL15		(PFC_BASE + 0x033CU)
+#define PFC_DRVCTRL16		(PFC_BASE + 0x0340U)
+#define PFC_DRVCTRL17		(PFC_BASE + 0x0344U)
+#define PFC_DRVCTRL18		(PFC_BASE + 0x0348U)
+#define PFC_DRVCTRL19		(PFC_BASE + 0x034CU)
+#define PFC_DRVCTRL20		(PFC_BASE + 0x0350U)
+#define PFC_DRVCTRL21		(PFC_BASE + 0x0354U)
+#define PFC_DRVCTRL22		(PFC_BASE + 0x0358U)
+#define PFC_DRVCTRL23		(PFC_BASE + 0x035CU)
+#define PFC_DRVCTRL24		(PFC_BASE + 0x0360U)
+#define PFC_POCCTRL0		(PFC_BASE + 0x0380U)
+#define	PFC_TDSELCTRL0		(PFC_BASE + 0x03C0U)
+#define	PFC_IOCTRL		(PFC_BASE + 0x03E0U)
+#define	PFC_TSREG		(PFC_BASE + 0x03E4U)
+#define	PFC_PUEN0		(PFC_BASE + 0x0400U)
+#define	PFC_PUEN1		(PFC_BASE + 0x0404U)
+#define	PFC_PUEN2		(PFC_BASE + 0x0408U)
+#define	PFC_PUEN3		(PFC_BASE + 0x040CU)
+#define	PFC_PUEN4		(PFC_BASE + 0x0410U)
+#define	PFC_PUEN5		(PFC_BASE + 0x0414U)
+#define	PFC_PUEN6		(PFC_BASE + 0x0418U)
+#define	PFC_PUD0		(PFC_BASE + 0x0440U)
+#define	PFC_PUD1		(PFC_BASE + 0x0444U)
+#define	PFC_PUD2		(PFC_BASE + 0x0448U)
+#define	PFC_PUD3		(PFC_BASE + 0x044CU)
+#define	PFC_PUD4		(PFC_BASE + 0x0450U)
+#define	PFC_PUD5		(PFC_BASE + 0x0454U)
+#define	PFC_PUD6		(PFC_BASE + 0x0458U)
+#define	PFC_MOD_SEL0		(PFC_BASE + 0x0500U)
+#define	PFC_MOD_SEL1		(PFC_BASE + 0x0504U)
+#define	PFC_MOD_SEL2		(PFC_BASE + 0x0508U)
+
+#define	GPSR0_D15		((uint32_t)1U << 15U)
+#define	GPSR0_D14		((uint32_t)1U << 14U)
+#define	GPSR0_D13		((uint32_t)1U << 13U)
+#define	GPSR0_D12		((uint32_t)1U << 12U)
+#define	GPSR0_D11		((uint32_t)1U << 11U)
+#define	GPSR0_D10		((uint32_t)1U << 10U)
+#define	GPSR0_D9		((uint32_t)1U << 9U)
+#define	GPSR0_D8		((uint32_t)1U << 8U)
+#define	GPSR0_D7		((uint32_t)1U << 7U)
+#define	GPSR0_D6		((uint32_t)1U << 6U)
+#define	GPSR0_D5		((uint32_t)1U << 5U)
+#define	GPSR0_D4		((uint32_t)1U << 4U)
+#define	GPSR0_D3		((uint32_t)1U << 3U)
+#define	GPSR0_D2		((uint32_t)1U << 2U)
+#define	GPSR0_D1		((uint32_t)1U << 1U)
+#define	GPSR0_D0		((uint32_t)1U << 0U)
+#define	GPSR1_EX_WAIT0_A	((uint32_t)1U << 27U)
+#define	GPSR1_WE1		((uint32_t)1U << 26U)
+#define	GPSR1_WE0		((uint32_t)1U << 25U)
+#define	GPSR1_RD_WR		((uint32_t)1U << 24U)
+#define	GPSR1_RD		((uint32_t)1U << 23U)
+#define	GPSR1_BS		((uint32_t)1U << 22U)
+#define	GPSR1_CS1_A26		((uint32_t)1U << 21U)
+#define	GPSR1_CS0		((uint32_t)1U << 20U)
+#define	GPSR1_A19		((uint32_t)1U << 19U)
+#define	GPSR1_A18		((uint32_t)1U << 18U)
+#define	GPSR1_A17		((uint32_t)1U << 17U)
+#define	GPSR1_A16		((uint32_t)1U << 16U)
+#define	GPSR1_A15		((uint32_t)1U << 15U)
+#define	GPSR1_A14		((uint32_t)1U << 14U)
+#define	GPSR1_A13		((uint32_t)1U << 13U)
+#define	GPSR1_A12		((uint32_t)1U << 12U)
+#define	GPSR1_A11		((uint32_t)1U << 11U)
+#define	GPSR1_A10		((uint32_t)1U << 10U)
+#define	GPSR1_A9		((uint32_t)1U << 9U)
+#define	GPSR1_A8		((uint32_t)1U << 8U)
+#define	GPSR1_A7		((uint32_t)1U << 7U)
+#define	GPSR1_A6		((uint32_t)1U << 6U)
+#define	GPSR1_A5		((uint32_t)1U << 5U)
+#define	GPSR1_A4		((uint32_t)1U << 4U)
+#define	GPSR1_A3		((uint32_t)1U << 3U)
+#define	GPSR1_A2		((uint32_t)1U << 2U)
+#define	GPSR1_A1		((uint32_t)1U << 1U)
+#define	GPSR1_A0		((uint32_t)1U << 0U)
+#define	GPSR2_AVB_AVTP_CAPTURE_A	((uint32_t)1U << 14U)
+#define	GPSR2_AVB_AVTP_MATCH_A	((uint32_t)1U << 13U)
+#define	GPSR2_AVB_LINK		((uint32_t)1U << 12U)
+#define	GPSR2_AVB_PHY_INT	((uint32_t)1U << 11U)
+#define	GPSR2_AVB_MAGIC		((uint32_t)1U << 10U)
+#define	GPSR2_AVB_MDC		((uint32_t)1U << 9U)
+#define	GPSR2_PWM2_A		((uint32_t)1U << 8U)
+#define	GPSR2_PWM1_A		((uint32_t)1U << 7U)
+#define	GPSR2_PWM0		((uint32_t)1U << 6U)
+#define	GPSR2_IRQ5		((uint32_t)1U << 5U)
+#define	GPSR2_IRQ4		((uint32_t)1U << 4U)
+#define	GPSR2_IRQ3		((uint32_t)1U << 3U)
+#define	GPSR2_IRQ2		((uint32_t)1U << 2U)
+#define	GPSR2_IRQ1		((uint32_t)1U << 1U)
+#define	GPSR2_IRQ0		((uint32_t)1U << 0U)
+#define	GPSR3_SD1_WP		((uint32_t)1U << 15U)
+#define	GPSR3_SD1_CD		((uint32_t)1U << 14U)
+#define	GPSR3_SD0_WP		((uint32_t)1U << 13U)
+#define	GPSR3_SD0_CD		((uint32_t)1U << 12U)
+#define	GPSR3_SD1_DAT3		((uint32_t)1U << 11U)
+#define	GPSR3_SD1_DAT2		((uint32_t)1U << 10U)
+#define	GPSR3_SD1_DAT1		((uint32_t)1U << 9U)
+#define	GPSR3_SD1_DAT0		((uint32_t)1U << 8U)
+#define	GPSR3_SD1_CMD		((uint32_t)1U << 7U)
+#define	GPSR3_SD1_CLK		((uint32_t)1U << 6U)
+#define	GPSR3_SD0_DAT3		((uint32_t)1U << 5U)
+#define	GPSR3_SD0_DAT2		((uint32_t)1U << 4U)
+#define	GPSR3_SD0_DAT1		((uint32_t)1U << 3U)
+#define	GPSR3_SD0_DAT0		((uint32_t)1U << 2U)
+#define	GPSR3_SD0_CMD		((uint32_t)1U << 1U)
+#define	GPSR3_SD0_CLK		((uint32_t)1U << 0U)
+#define	GPSR4_SD3_DS		((uint32_t)1U << 17U)
+#define	GPSR4_SD3_DAT7		((uint32_t)1U << 16U)
+#define	GPSR4_SD3_DAT6		((uint32_t)1U << 15U)
+#define	GPSR4_SD3_DAT5		((uint32_t)1U << 14U)
+#define	GPSR4_SD3_DAT4		((uint32_t)1U << 13U)
+#define	GPSR4_SD3_DAT3		((uint32_t)1U << 12U)
+#define	GPSR4_SD3_DAT2		((uint32_t)1U << 11U)
+#define	GPSR4_SD3_DAT1		((uint32_t)1U << 10U)
+#define	GPSR4_SD3_DAT0		((uint32_t)1U << 9U)
+#define	GPSR4_SD3_CMD		((uint32_t)1U << 8U)
+#define	GPSR4_SD3_CLK		((uint32_t)1U << 7U)
+#define	GPSR4_SD2_DS		((uint32_t)1U << 6U)
+#define	GPSR4_SD2_DAT3		((uint32_t)1U << 5U)
+#define	GPSR4_SD2_DAT2		((uint32_t)1U << 4U)
+#define	GPSR4_SD2_DAT1		((uint32_t)1U << 3U)
+#define	GPSR4_SD2_DAT0		((uint32_t)1U << 2U)
+#define	GPSR4_SD2_CMD		((uint32_t)1U << 1U)
+#define	GPSR4_SD2_CLK		((uint32_t)1U << 0U)
+#define	GPSR5_MLB_DAT		((uint32_t)1U << 25U)
+#define	GPSR5_MLB_SIG		((uint32_t)1U << 24U)
+#define	GPSR5_MLB_CLK		((uint32_t)1U << 23U)
+#define	GPSR5_MSIOF0_RXD	((uint32_t)1U << 22U)
+#define	GPSR5_MSIOF0_SS2	((uint32_t)1U << 21U)
+#define	GPSR5_MSIOF0_TXD	((uint32_t)1U << 20U)
+#define	GPSR5_MSIOF0_SS1	((uint32_t)1U << 19U)
+#define	GPSR5_MSIOF0_SYNC	((uint32_t)1U << 18U)
+#define	GPSR5_MSIOF0_SCK	((uint32_t)1U << 17U)
+#define	GPSR5_HRTS0		((uint32_t)1U << 16U)
+#define	GPSR5_HCTS0		((uint32_t)1U << 15U)
+#define	GPSR5_HTX0		((uint32_t)1U << 14U)
+#define	GPSR5_HRX0		((uint32_t)1U << 13U)
+#define	GPSR5_HSCK0		((uint32_t)1U << 12U)
+#define	GPSR5_RX2_A		((uint32_t)1U << 11U)
+#define	GPSR5_TX2_A		((uint32_t)1U << 10U)
+#define	GPSR5_SCK2		((uint32_t)1U << 9U)
+#define	GPSR5_RTS1_TANS		((uint32_t)1U << 8U)
+#define	GPSR5_CTS1		((uint32_t)1U << 7U)
+#define	GPSR5_TX1_A		((uint32_t)1U << 6U)
+#define	GPSR5_RX1_A		((uint32_t)1U << 5U)
+#define	GPSR5_RTS0_TANS		((uint32_t)1U << 4U)
+#define	GPSR5_CTS0		((uint32_t)1U << 3U)
+#define	GPSR5_TX0		((uint32_t)1U << 2U)
+#define	GPSR5_RX0		((uint32_t)1U << 1U)
+#define	GPSR5_SCK0		((uint32_t)1U << 0U)
+#define	GPSR6_USB31_OVC		((uint32_t)1U << 31U)
+#define	GPSR6_USB31_PWEN	((uint32_t)1U << 30U)
+#define	GPSR6_USB30_OVC		((uint32_t)1U << 29U)
+#define	GPSR6_USB30_PWEN	((uint32_t)1U << 28U)
+#define	GPSR6_USB1_OVC		((uint32_t)1U << 27U)
+#define	GPSR6_USB1_PWEN		((uint32_t)1U << 26U)
+#define	GPSR6_USB0_OVC		((uint32_t)1U << 25U)
+#define	GPSR6_USB0_PWEN		((uint32_t)1U << 24U)
+#define	GPSR6_AUDIO_CLKB_B	((uint32_t)1U << 23U)
+#define	GPSR6_AUDIO_CLKA_A	((uint32_t)1U << 22U)
+#define	GPSR6_SSI_SDATA9_A	((uint32_t)1U << 21U)
+#define	GPSR6_SSI_SDATA8	((uint32_t)1U << 20U)
+#define	GPSR6_SSI_SDATA7	((uint32_t)1U << 19U)
+#define	GPSR6_SSI_WS78		((uint32_t)1U << 18U)
+#define	GPSR6_SSI_SCK78		((uint32_t)1U << 17U)
+#define	GPSR6_SSI_SDATA6	((uint32_t)1U << 16U)
+#define	GPSR6_SSI_WS6		((uint32_t)1U << 15U)
+#define	GPSR6_SSI_SCK6		((uint32_t)1U << 14U)
+#define	GPSR6_SSI_SDATA5	((uint32_t)1U << 13U)
+#define	GPSR6_SSI_WS5		((uint32_t)1U << 12U)
+#define	GPSR6_SSI_SCK5		((uint32_t)1U << 11U)
+#define	GPSR6_SSI_SDATA4	((uint32_t)1U << 10U)
+#define	GPSR6_SSI_WS4		((uint32_t)1U << 9U)
+#define	GPSR6_SSI_SCK4		((uint32_t)1U << 8U)
+#define	GPSR6_SSI_SDATA3	((uint32_t)1U << 7U)
+#define	GPSR6_SSI_WS34		((uint32_t)1U << 6U)
+#define	GPSR6_SSI_SCK34		((uint32_t)1U << 5U)
+#define	GPSR6_SSI_SDATA2_A	((uint32_t)1U << 4U)
+#define	GPSR6_SSI_SDATA1_A	((uint32_t)1U << 3U)
+#define	GPSR6_SSI_SDATA0	((uint32_t)1U << 2U)
+#define	GPSR6_SSI_WS0129	((uint32_t)1U << 1U)
+#define	GPSR6_SSI_SCK0129	((uint32_t)1U << 0U)
+#define	GPSR7_HDMI1_CEC		((uint32_t)1U << 3U)
+#define	GPSR7_HDMI0_CEC		((uint32_t)1U << 2U)
+#define	GPSR7_AVS2		((uint32_t)1U << 1U)
+#define	GPSR7_AVS1		((uint32_t)1U << 0U)
+
+#define	IPSR_28_FUNC(x)		((uint32_t)(x) << 28U)
+#define	IPSR_24_FUNC(x)		((uint32_t)(x) << 24U)
+#define	IPSR_20_FUNC(x)		((uint32_t)(x) << 20U)
+#define	IPSR_16_FUNC(x)		((uint32_t)(x) << 16U)
+#define	IPSR_12_FUNC(x)		((uint32_t)(x) << 12U)
+#define	IPSR_8_FUNC(x)		((uint32_t)(x) << 8U)
+#define	IPSR_4_FUNC(x)		((uint32_t)(x) << 4U)
+#define	IPSR_0_FUNC(x)		((uint32_t)(x) << 0U)
+
+#define	POC_SD3_DS_33V		((uint32_t)1U << 29U)
+#define	POC_SD3_DAT7_33V	((uint32_t)1U << 28U)
+#define	POC_SD3_DAT6_33V	((uint32_t)1U << 27U)
+#define	POC_SD3_DAT5_33V	((uint32_t)1U << 26U)
+#define	POC_SD3_DAT4_33V	((uint32_t)1U << 25U)
+#define	POC_SD3_DAT3_33V	((uint32_t)1U << 24U)
+#define	POC_SD3_DAT2_33V	((uint32_t)1U << 23U)
+#define	POC_SD3_DAT1_33V	((uint32_t)1U << 22U)
+#define	POC_SD3_DAT0_33V	((uint32_t)1U << 21U)
+#define	POC_SD3_CMD_33V		((uint32_t)1U << 20U)
+#define	POC_SD3_CLK_33V		((uint32_t)1U << 19U)
+#define	POC_SD2_DS_33V		((uint32_t)1U << 18U)
+#define	POC_SD2_DAT3_33V	((uint32_t)1U << 17U)
+#define	POC_SD2_DAT2_33V	((uint32_t)1U << 16U)
+#define	POC_SD2_DAT1_33V	((uint32_t)1U << 15U)
+#define	POC_SD2_DAT0_33V	((uint32_t)1U << 14U)
+#define	POC_SD2_CMD_33V		((uint32_t)1U << 13U)
+#define	POC_SD2_CLK_33V		((uint32_t)1U << 12U)
+#define	POC_SD1_DAT3_33V	((uint32_t)1U << 11U)
+#define	POC_SD1_DAT2_33V	((uint32_t)1U << 10U)
+#define	POC_SD1_DAT1_33V	((uint32_t)1U << 9U)
+#define	POC_SD1_DAT0_33V	((uint32_t)1U << 8U)
+#define	POC_SD1_CMD_33V		((uint32_t)1U << 7U)
+#define	POC_SD1_CLK_33V		((uint32_t)1U << 6U)
+#define	POC_SD0_DAT3_33V	((uint32_t)1U << 5U)
+#define	POC_SD0_DAT2_33V	((uint32_t)1U << 4U)
+#define	POC_SD0_DAT1_33V	((uint32_t)1U << 3U)
+#define	POC_SD0_DAT0_33V	((uint32_t)1U << 2U)
+#define	POC_SD0_CMD_33V		((uint32_t)1U << 1U)
+#define	POC_SD0_CLK_33V		((uint32_t)1U << 0U)
+
+#define	DRVCTRL0_QSPI0_SPCLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL0_QSPI0_MOSI_IO0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL0_QSPI0_MISO_IO1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL0_QSPI0_IO2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL0_QSPI0_IO3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL0_QSPI0_SSL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL0_QSPI1_SPCLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL0_QSPI1_MOSI_IO0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL1_QSPI1_MISO_IO1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL1_QSPI1_IO2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL1_QSPI1_IO3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL1_QSPI1_SS(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL1_RPC_INT(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL1_RPC_WP(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL1_RPC_RESET(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL1_AVB_RX_CTL(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL2_AVB_RXC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL2_AVB_RD0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL2_AVB_RD1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL2_AVB_RD2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL2_AVB_RD3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL2_AVB_TX_CTL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL2_AVB_TXC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL2_AVB_TD0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL3_AVB_TD1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL3_AVB_TD2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL3_AVB_TD3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL3_AVB_TXCREFCLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL3_AVB_MDIO(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL3_AVB_MDC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL3_AVB_MAGIC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL3_AVB_PHY_INT(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL4_AVB_LINK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL4_AVB_AVTP_MATCH(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL4_AVB_AVTP_CAPTURE(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL4_IRQ0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL4_IRQ1(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL4_IRQ2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL4_IRQ3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL4_IRQ4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL5_IRQ5(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL5_PWM0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL5_PWM1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL5_PWM2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL5_A0(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL5_A1(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL5_A2(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL5_A3(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL6_A4(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL6_A5(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL6_A6(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL6_A7(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL6_A8(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL6_A9(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL6_A10(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL6_A11(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL7_A12(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL7_A13(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL7_A14(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL7_A15(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL7_A16(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL7_A17(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL7_A18(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL7_A19(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL8_CLKOUT(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL8_CS0(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL8_CS1_A2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL8_BS(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL8_RD(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL8_RD_W(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL8_WE0(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL8_WE1(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL9_EX_WAIT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL9_PRESETOU(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL9_D0(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL9_D1(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL9_D2(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL9_D3(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL9_D4(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL9_D5(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL10_D6(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL10_D7(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL10_D8(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL10_D9(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL10_D10(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL10_D11(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL10_D12(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL10_D13(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL11_D14(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL11_D15(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL11_AVS1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL11_AVS2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL11_HDMI0_CEC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL11_HDMI1_CEC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL11_DU_DOTCLKIN0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL11_DU_DOTCLKIN1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL12_DU_DOTCLKIN2(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL12_DU_DOTCLKIN3(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL12_DU_FSCLKST(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL12_DU_TMS(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_TDO(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL13_ASEBRK(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL13_SD0_CLK(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL13_SD0_CMD(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL13_SD0_DAT0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL13_SD0_DAT1(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL13_SD0_DAT2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_SD0_DAT3(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL14_SD1_CLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL14_SD1_CMD(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL14_SD1_DAT0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL14_SD1_DAT1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL14_SD1_DAT2(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL14_SD1_DAT3(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL14_SD2_CLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL14_SD2_CMD(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL15_SD2_DAT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL15_SD2_DAT1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL15_SD2_DAT2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL15_SD2_DAT3(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL15_SD2_DS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL15_SD3_CLK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL15_SD3_CMD(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL15_SD3_DAT0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL16_SD3_DAT1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL16_SD3_DAT2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL16_SD3_DAT3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL16_SD3_DAT4(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL16_SD3_DAT5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL16_SD3_DAT6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL16_SD3_DAT7(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL16_SD3_DS(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL17_SD0_CD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL17_SD0_WP(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL17_SD1_CD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL17_SD1_WP(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL17_SCK0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL17_RX0(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL17_TX0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL17_CTS0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL18_RTS0_TANS(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL18_RX1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL18_TX1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL18_CTS1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL18_RTS1_TANS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL18_SCK2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL18_TX2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL18_RX2(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL19_HSCK0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL19_HRX0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL19_HTX0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL19_HCTS0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL19_HRTS0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL19_MSIOF0_SCK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL19_MSIOF0_SYNC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL19_MSIOF0_SS1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL20_MSIOF0_TXD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL20_MSIOF0_SS2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL20_MSIOF0_RXD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL20_MLB_CLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL20_MLB_SIG(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL20_MLB_DAT(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL20_MLB_REF(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL20_SSI_SCK0129(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL21_SSI_WS0129(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL21_SSI_SDATA0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL21_SSI_SDATA1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL21_SSI_SDATA2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL21_SSI_SCK34(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL21_SSI_WS34(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL21_SSI_SDATA3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL21_SSI_SCK4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL22_SSI_WS4(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL22_SSI_SDATA4(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL22_SSI_SCK5(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL22_SSI_WS5(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL22_SSI_SDATA5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL22_SSI_SCK6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL22_SSI_WS6(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL22_SSI_SDATA6(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL23_SSI_SCK78(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL23_SSI_WS78(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL23_SSI_SDATA7(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL23_SSI_SDATA8(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL23_SSI_SDATA9(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL23_AUDIO_CLKA(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL23_AUDIO_CLKB(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL23_USB0_PWEN(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL24_USB0_OVC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL24_USB1_PWEN(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL24_USB1_OVC(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL24_USB30_PWEN(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL24_USB30_OVC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL24_USB31_PWEN(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL24_USB31_OVC(x)	((uint32_t)(x) << 4U)
+
+#define	MOD_SEL0_MSIOF3_A	((uint32_t)0U << 29U)
+#define	MOD_SEL0_MSIOF3_B	((uint32_t)1U << 29U)
+#define	MOD_SEL0_MSIOF3_C	((uint32_t)2U << 29U)
+#define	MOD_SEL0_MSIOF3_D	((uint32_t)3U << 29U)
+#define	MOD_SEL0_MSIOF2_A	((uint32_t)0U << 27U)
+#define	MOD_SEL0_MSIOF2_B	((uint32_t)1U << 27U)
+#define	MOD_SEL0_MSIOF2_C	((uint32_t)2U << 27U)
+#define	MOD_SEL0_MSIOF2_D	((uint32_t)3U << 27U)
+#define	MOD_SEL0_MSIOF1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL0_MSIOF1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL0_MSIOF1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL0_MSIOF1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL0_MSIOF1_E	((uint32_t)4U << 24U)
+#define	MOD_SEL0_MSIOF1_F	((uint32_t)5U << 24U)
+#define	MOD_SEL0_MSIOF1_G	((uint32_t)6U << 24U)
+#define	MOD_SEL0_LBSC_A		((uint32_t)0U << 23U)
+#define	MOD_SEL0_LBSC_B		((uint32_t)1U << 23U)
+#define	MOD_SEL0_IEBUS_A	((uint32_t)0U << 22U)
+#define	MOD_SEL0_IEBUS_B	((uint32_t)1U << 22U)
+#define	MOD_SEL0_I2C6_A		((uint32_t)0U << 20U)
+#define	MOD_SEL0_I2C6_B		((uint32_t)1U << 20U)
+#define	MOD_SEL0_I2C6_C		((uint32_t)2U << 20U)
+#define	MOD_SEL0_I2C2_A		((uint32_t)0U << 19U)
+#define	MOD_SEL0_I2C2_B		((uint32_t)1U << 19U)
+#define	MOD_SEL0_I2C1_A		((uint32_t)0U << 18U)
+#define	MOD_SEL0_I2C1_B		((uint32_t)1U << 18U)
+#define	MOD_SEL0_HSCIF4_A	((uint32_t)0U << 17U)
+#define	MOD_SEL0_HSCIF4_B	((uint32_t)1U << 17U)
+#define	MOD_SEL0_HSCIF3_A	((uint32_t)0U << 15U)
+#define	MOD_SEL0_HSCIF3_B	((uint32_t)1U << 15U)
+#define	MOD_SEL0_HSCIF3_C	((uint32_t)2U << 15U)
+#define	MOD_SEL0_HSCIF3_D	((uint32_t)3U << 15U)
+#define	MOD_SEL0_HSCIF2_A	((uint32_t)0U << 14U)
+#define	MOD_SEL0_HSCIF2_B	((uint32_t)1U << 14U)
+#define	MOD_SEL0_HSCIF1_A	((uint32_t)0U << 13U)
+#define	MOD_SEL0_HSCIF1_B	((uint32_t)1U << 13U)
+#define	MOD_SEL0_FSO_A		((uint32_t)0U << 12U)
+#define	MOD_SEL0_FSO_B		((uint32_t)1U << 12U)
+#define	MOD_SEL0_FM_A		((uint32_t)0U << 11U)
+#define	MOD_SEL0_FM_B		((uint32_t)1U << 11U)
+#define	MOD_SEL0_ETHERAVB_A	((uint32_t)0U << 10U)
+#define	MOD_SEL0_ETHERAVB_B	((uint32_t)1U << 10U)
+#define	MOD_SEL0_DRIF3_A	((uint32_t)0U << 9U)
+#define	MOD_SEL0_DRIF3_B	((uint32_t)1U << 9U)
+#define	MOD_SEL0_DRIF2_A	((uint32_t)0U << 8U)
+#define	MOD_SEL0_DRIF2_B	((uint32_t)1U << 8U)
+#define	MOD_SEL0_DRIF1_A	((uint32_t)0U << 6U)
+#define	MOD_SEL0_DRIF1_B	((uint32_t)1U << 6U)
+#define	MOD_SEL0_DRIF1_C	((uint32_t)2U << 6U)
+#define	MOD_SEL0_DRIF0_A	((uint32_t)0U << 4U)
+#define	MOD_SEL0_DRIF0_B	((uint32_t)1U << 4U)
+#define	MOD_SEL0_DRIF0_C	((uint32_t)2U << 4U)
+#define	MOD_SEL0_CANFD0_A	((uint32_t)0U << 3U)
+#define	MOD_SEL0_CANFD0_B	((uint32_t)1U << 3U)
+#define	MOD_SEL0_ADG_A		((uint32_t)0U << 1U)
+#define	MOD_SEL0_ADG_B		((uint32_t)1U << 1U)
+#define	MOD_SEL0_ADG_C		((uint32_t)2U << 1U)
+#define	MOD_SEL0_ADG_D		((uint32_t)3U << 1U)
+#define	MOD_SEL0_5LINE_A	((uint32_t)0U << 0U)
+#define	MOD_SEL0_5LINE_B	((uint32_t)1U << 0U)
+#define	MOD_SEL1_TSIF1_A	((uint32_t)0U << 30U)
+#define	MOD_SEL1_TSIF1_B	((uint32_t)1U << 30U)
+#define	MOD_SEL1_TSIF1_C	((uint32_t)2U << 30U)
+#define	MOD_SEL1_TSIF1_D	((uint32_t)3U << 30U)
+#define	MOD_SEL1_TSIF0_A	((uint32_t)0U << 27U)
+#define	MOD_SEL1_TSIF0_B	((uint32_t)1U << 27U)
+#define	MOD_SEL1_TSIF0_C	((uint32_t)2U << 27U)
+#define	MOD_SEL1_TSIF0_D	((uint32_t)3U << 27U)
+#define	MOD_SEL1_TSIF0_E	((uint32_t)4U << 27U)
+#define	MOD_SEL1_TIMER_TMU_A	((uint32_t)0U << 26U)
+#define	MOD_SEL1_TIMER_TMU_B	((uint32_t)1U << 26U)
+#define	MOD_SEL1_SSP1_1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL1_SSP1_1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL1_SSP1_1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL1_SSP1_1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL1_SSP1_0_A	((uint32_t)0U << 21U)
+#define	MOD_SEL1_SSP1_0_B	((uint32_t)1U << 21U)
+#define	MOD_SEL1_SSP1_0_C	((uint32_t)2U << 21U)
+#define	MOD_SEL1_SSP1_0_D	((uint32_t)3U << 21U)
+#define	MOD_SEL1_SSP1_0_E	((uint32_t)4U << 21U)
+#define	MOD_SEL1_SSI_A		((uint32_t)0U << 20U)
+#define	MOD_SEL1_SSI_B		((uint32_t)1U << 20U)
+#define	MOD_SEL1_SPEED_PULSE_IF_A	((uint32_t)0U << 19U)
+#define	MOD_SEL1_SPEED_PULSE_IF_B	((uint32_t)1U << 19U)
+#define	MOD_SEL1_SIMCARD_A	((uint32_t)0U << 17U)
+#define	MOD_SEL1_SIMCARD_B	((uint32_t)1U << 17U)
+#define	MOD_SEL1_SIMCARD_C	((uint32_t)2U << 17U)
+#define	MOD_SEL1_SIMCARD_D	((uint32_t)3U << 17U)
+#define	MOD_SEL1_SDHI2_A	((uint32_t)0U << 16U)
+#define	MOD_SEL1_SDHI2_B	((uint32_t)1U << 16U)
+#define	MOD_SEL1_SCIF4_A	((uint32_t)0U << 14U)
+#define	MOD_SEL1_SCIF4_B	((uint32_t)1U << 14U)
+#define	MOD_SEL1_SCIF4_C	((uint32_t)2U << 14U)
+#define	MOD_SEL1_SCIF3_A	((uint32_t)0U << 13U)
+#define	MOD_SEL1_SCIF3_B	((uint32_t)1U << 13U)
+#define	MOD_SEL1_SCIF2_A	((uint32_t)0U << 12U)
+#define	MOD_SEL1_SCIF2_B	((uint32_t)1U << 12U)
+#define	MOD_SEL1_SCIF1_A	((uint32_t)0U << 11U)
+#define	MOD_SEL1_SCIF1_B	((uint32_t)1U << 11U)
+#define	MOD_SEL1_SCIF_A		((uint32_t)0U << 10U)
+#define	MOD_SEL1_SCIF_B		((uint32_t)1U << 10U)
+#define	MOD_SEL1_REMOCON_A	((uint32_t)0U << 9U)
+#define	MOD_SEL1_REMOCON_B	((uint32_t)1U << 9U)
+#define	MOD_SEL1_RCAN0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL1_RCAN0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL1_PWM6_A		((uint32_t)0U << 5U)
+#define	MOD_SEL1_PWM6_B		((uint32_t)1U << 5U)
+#define	MOD_SEL1_PWM5_A		((uint32_t)0U << 4U)
+#define	MOD_SEL1_PWM5_B		((uint32_t)1U << 4U)
+#define	MOD_SEL1_PWM4_A		((uint32_t)0U << 3U)
+#define	MOD_SEL1_PWM4_B		((uint32_t)1U << 3U)
+#define	MOD_SEL1_PWM3_A		((uint32_t)0U << 2U)
+#define	MOD_SEL1_PWM3_B		((uint32_t)1U << 2U)
+#define	MOD_SEL1_PWM2_A		((uint32_t)0U << 1U)
+#define	MOD_SEL1_PWM2_B		((uint32_t)1U << 1U)
+#define	MOD_SEL1_PWM1_A		((uint32_t)0U << 0U)
+#define	MOD_SEL1_PWM1_B		((uint32_t)1U << 0U)
+#define	MOD_SEL2_I2C_5_A	((uint32_t)0U << 31U)
+#define	MOD_SEL2_I2C_5_B	((uint32_t)1U << 31U)
+#define	MOD_SEL2_I2C_3_A	((uint32_t)0U << 30U)
+#define	MOD_SEL2_I2C_3_B	((uint32_t)1U << 30U)
+#define	MOD_SEL2_I2C_0_A	((uint32_t)0U << 29U)
+#define	MOD_SEL2_I2C_0_B	((uint32_t)1U << 29U)
+#define	MOD_SEL2_VIN4_A		((uint32_t)0U << 0U)
+#define	MOD_SEL2_VIN4_B		((uint32_t)1U << 0U)
+
+
+static void pfc_reg_write(uint32_t addr, uint32_t data);
+
+static void pfc_reg_write(uint32_t addr, uint32_t data)
+{
+	mmio_write_32(PFC_PMMR, ~data);
+	mmio_write_32((uintptr_t)addr, data);
+}
+
+
+void pfc_init_h3(void)
+{
+	/* initialize module select */
+	pfc_reg_write(PFC_MOD_SEL0, MOD_SEL0_MSIOF3_A
+				  | MOD_SEL0_MSIOF2_A
+				  | MOD_SEL0_MSIOF1_A
+				  | MOD_SEL0_LBSC_A
+				  | MOD_SEL0_IEBUS_A
+				  | MOD_SEL0_I2C6_A
+				  | MOD_SEL0_I2C2_A
+				  | MOD_SEL0_I2C1_A
+				  | MOD_SEL0_HSCIF4_A
+				  | MOD_SEL0_HSCIF3_A
+				  | MOD_SEL0_HSCIF2_A
+				  | MOD_SEL0_HSCIF1_A
+				  | MOD_SEL0_FM_A
+				  | MOD_SEL0_ETHERAVB_A
+				  | MOD_SEL0_DRIF3_A
+				  | MOD_SEL0_DRIF2_A
+				  | MOD_SEL0_DRIF1_A
+				  | MOD_SEL0_DRIF0_A
+				  | MOD_SEL0_CANFD0_A
+				  | MOD_SEL0_ADG_A
+				  | MOD_SEL0_5LINE_A);
+	pfc_reg_write(PFC_MOD_SEL1, MOD_SEL1_TSIF1_A
+				  | MOD_SEL1_TSIF0_A
+				  | MOD_SEL1_TIMER_TMU_A
+				  | MOD_SEL1_SSP1_1_A
+				  | MOD_SEL1_SSP1_0_A
+				  | MOD_SEL1_SSI_A
+				  | MOD_SEL1_SPEED_PULSE_IF_A
+				  | MOD_SEL1_SIMCARD_A
+				  | MOD_SEL1_SDHI2_A
+				  | MOD_SEL1_SCIF4_A
+				  | MOD_SEL1_SCIF3_A
+				  | MOD_SEL1_SCIF2_A
+				  | MOD_SEL1_SCIF1_A
+				  | MOD_SEL1_SCIF_A
+				  | MOD_SEL1_REMOCON_A
+				  | MOD_SEL1_RCAN0_A
+				  | MOD_SEL1_PWM6_A
+				  | MOD_SEL1_PWM5_A
+				  | MOD_SEL1_PWM4_A
+				  | MOD_SEL1_PWM3_A
+				  | MOD_SEL1_PWM2_A
+				  | MOD_SEL1_PWM1_A);
+	pfc_reg_write(PFC_MOD_SEL2, MOD_SEL2_I2C_5_A
+				  | MOD_SEL2_I2C_3_A
+				  | MOD_SEL2_I2C_0_A
+				  | MOD_SEL2_VIN4_A);
+
+	/* initialize peripheral function select */
+	pfc_reg_write(PFC_IPSR0, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR1, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(3)
+			       | IPSR_8_FUNC(3)
+			       | IPSR_4_FUNC(3)
+			       | IPSR_0_FUNC(3));
+	pfc_reg_write(PFC_IPSR2, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR3, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR4, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR5, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR6, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR7, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR8, IPSR_28_FUNC(1)
+			       | IPSR_24_FUNC(1)
+			       | IPSR_20_FUNC(1)
+			       | IPSR_16_FUNC(1)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR9, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR10, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(4)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(1));
+	pfc_reg_write(PFC_IPSR11, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(4)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR12, IPSR_28_FUNC(8)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(3)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR13, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(3)
+				| IPSR_0_FUNC(8));
+	pfc_reg_write(PFC_IPSR14, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR15, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(1));
+	pfc_reg_write(PFC_IPSR16, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR17, IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+
+	/* initialize GPIO/perihperal function select */
+	pfc_reg_write(PFC_GPSR0, GPSR0_D15
+			       | GPSR0_D14
+			       | GPSR0_D13
+			       | GPSR0_D12
+			       | GPSR0_D11
+			       | GPSR0_D10
+			       | GPSR0_D9
+			       | GPSR0_D8);
+	pfc_reg_write(PFC_GPSR1, GPSR1_EX_WAIT0_A
+			       | GPSR1_A19
+			       | GPSR1_A18
+			       | GPSR1_A17
+			       | GPSR1_A16
+			       | GPSR1_A15
+			       | GPSR1_A14
+			       | GPSR1_A13
+			       | GPSR1_A12
+			       | GPSR1_A7
+			       | GPSR1_A6
+			       | GPSR1_A5
+			       | GPSR1_A4
+			       | GPSR1_A3
+			       | GPSR1_A2
+			       | GPSR1_A1
+			       | GPSR1_A0);
+	pfc_reg_write(PFC_GPSR2, GPSR2_AVB_AVTP_CAPTURE_A
+			       | GPSR2_AVB_AVTP_MATCH_A
+			       | GPSR2_AVB_LINK
+			       | GPSR2_AVB_PHY_INT
+			       | GPSR2_AVB_MDC
+			       | GPSR2_PWM2_A
+			       | GPSR2_PWM1_A
+			       | GPSR2_IRQ5
+			       | GPSR2_IRQ4
+			       | GPSR2_IRQ3
+			       | GPSR2_IRQ2
+			       | GPSR2_IRQ1
+			       | GPSR2_IRQ0);
+	pfc_reg_write(PFC_GPSR3, GPSR3_SD0_WP
+			       | GPSR3_SD0_CD
+			       | GPSR3_SD1_DAT3
+			       | GPSR3_SD1_DAT2
+			       | GPSR3_SD1_DAT1
+			       | GPSR3_SD1_DAT0
+			       | GPSR3_SD0_DAT3
+			       | GPSR3_SD0_DAT2
+			       | GPSR3_SD0_DAT1
+			       | GPSR3_SD0_DAT0
+			       | GPSR3_SD0_CMD
+			       | GPSR3_SD0_CLK);
+	pfc_reg_write(PFC_GPSR4, GPSR4_SD3_DAT7
+			       | GPSR4_SD3_DAT6
+			       | GPSR4_SD3_DAT3
+			       | GPSR4_SD3_DAT2
+			       | GPSR4_SD3_DAT1
+			       | GPSR4_SD3_DAT0
+			       | GPSR4_SD3_CMD
+			       | GPSR4_SD3_CLK
+			       | GPSR4_SD2_DS
+			       | GPSR4_SD2_DAT3
+			       | GPSR4_SD2_DAT2
+			       | GPSR4_SD2_DAT1
+			       | GPSR4_SD2_DAT0
+			       | GPSR4_SD2_CMD
+			       | GPSR4_SD2_CLK);
+	pfc_reg_write(PFC_GPSR5, GPSR5_MSIOF0_SS2
+			       | GPSR5_MSIOF0_SS1
+			       | GPSR5_MSIOF0_SYNC
+			       | GPSR5_HRTS0
+			       | GPSR5_HCTS0
+			       | GPSR5_HTX0
+			       | GPSR5_HRX0
+			       | GPSR5_HSCK0
+			       | GPSR5_RX2_A
+			       | GPSR5_TX2_A
+			       | GPSR5_SCK2
+			       | GPSR5_RTS1_TANS
+			       | GPSR5_CTS1
+			       | GPSR5_TX1_A
+			       | GPSR5_RX1_A
+			       | GPSR5_RTS0_TANS
+			       | GPSR5_SCK0);
+	pfc_reg_write(PFC_GPSR6, GPSR6_USB30_OVC
+			       | GPSR6_USB30_PWEN
+			       | GPSR6_USB1_OVC
+			       | GPSR6_USB1_PWEN
+			       | GPSR6_USB0_OVC
+			       | GPSR6_USB0_PWEN
+			       | GPSR6_AUDIO_CLKB_B
+			       | GPSR6_AUDIO_CLKA_A
+			       | GPSR6_SSI_SDATA8
+			       | GPSR6_SSI_SDATA7
+			       | GPSR6_SSI_WS78
+			       | GPSR6_SSI_SCK78
+			       | GPSR6_SSI_WS6
+			       | GPSR6_SSI_SCK6
+			       | GPSR6_SSI_SDATA4
+			       | GPSR6_SSI_WS4
+			       | GPSR6_SSI_SCK4
+			       | GPSR6_SSI_SDATA1_A
+			       | GPSR6_SSI_SDATA0
+			       | GPSR6_SSI_WS0129
+			       | GPSR6_SSI_SCK0129);
+	pfc_reg_write(PFC_GPSR7, GPSR7_HDMI1_CEC
+			       | GPSR7_HDMI0_CEC
+			       | GPSR7_AVS2
+			       | GPSR7_AVS1);
+
+	/* initialize POC control register */
+	pfc_reg_write(PFC_POCCTRL0, POC_SD3_DS_33V
+				  | POC_SD3_DAT7_33V
+				  | POC_SD3_DAT6_33V
+				  | POC_SD3_DAT5_33V
+				  | POC_SD3_DAT4_33V
+				  | POC_SD3_DAT3_33V
+				  | POC_SD3_DAT2_33V
+				  | POC_SD3_DAT1_33V
+				  | POC_SD3_DAT0_33V
+				  | POC_SD3_CMD_33V
+				  | POC_SD3_CLK_33V
+				  | POC_SD0_DAT3_33V
+				  | POC_SD0_DAT2_33V
+				  | POC_SD0_DAT1_33V
+				  | POC_SD0_DAT0_33V
+				  | POC_SD0_CMD_33V
+				  | POC_SD0_CLK_33V);
+
+	/* initialize DRV control register */
+	pfc_reg_write(PFC_DRVCTRL0, DRVCTRL0_QSPI0_SPCLK(3)
+				  | DRVCTRL0_QSPI0_MOSI_IO0(3)
+				  | DRVCTRL0_QSPI0_MISO_IO1(3)
+				  | DRVCTRL0_QSPI0_IO2(3)
+				  | DRVCTRL0_QSPI0_IO3(3)
+				  | DRVCTRL0_QSPI0_SSL(3)
+				  | DRVCTRL0_QSPI1_SPCLK(3)
+				  | DRVCTRL0_QSPI1_MOSI_IO0(3));
+	pfc_reg_write(PFC_DRVCTRL1, DRVCTRL1_QSPI1_MISO_IO1(3)
+				  | DRVCTRL1_QSPI1_IO2(3)
+				  | DRVCTRL1_QSPI1_IO3(3)
+				  | DRVCTRL1_QSPI1_SS(3)
+				  | DRVCTRL1_RPC_INT(3)
+				  | DRVCTRL1_RPC_WP(3)
+				  | DRVCTRL1_RPC_RESET(3)
+				  | DRVCTRL1_AVB_RX_CTL(7));
+	pfc_reg_write(PFC_DRVCTRL2, DRVCTRL2_AVB_RXC(7)
+				  | DRVCTRL2_AVB_RD0(7)
+				  | DRVCTRL2_AVB_RD1(7)
+				  | DRVCTRL2_AVB_RD2(7)
+				  | DRVCTRL2_AVB_RD3(7)
+				  | DRVCTRL2_AVB_TX_CTL(7)
+				  | DRVCTRL2_AVB_TXC(7)
+				  | DRVCTRL2_AVB_TD0(7));
+	pfc_reg_write(PFC_DRVCTRL3, DRVCTRL3_AVB_TD1(7)
+				  | DRVCTRL3_AVB_TD2(7)
+				  | DRVCTRL3_AVB_TD3(7)
+				  | DRVCTRL3_AVB_TXCREFCLK(7)
+				  | DRVCTRL3_AVB_MDIO(7)
+				  | DRVCTRL3_AVB_MDC(7)
+				  | DRVCTRL3_AVB_MAGIC(7)
+				  | DRVCTRL3_AVB_PHY_INT(7));
+	pfc_reg_write(PFC_DRVCTRL4, DRVCTRL4_AVB_LINK(7)
+				  | DRVCTRL4_AVB_AVTP_MATCH(7)
+				  | DRVCTRL4_AVB_AVTP_CAPTURE(7)
+				  | DRVCTRL4_IRQ0(7)
+				  | DRVCTRL4_IRQ1(7)
+				  | DRVCTRL4_IRQ2(7)
+				  | DRVCTRL4_IRQ3(7)
+				  | DRVCTRL4_IRQ4(7));
+	pfc_reg_write(PFC_DRVCTRL5, DRVCTRL5_IRQ5(7)
+				  | DRVCTRL5_PWM0(7)
+				  | DRVCTRL5_PWM1(7)
+				  | DRVCTRL5_PWM2(7)
+				  | DRVCTRL5_A0(7)
+				  | DRVCTRL5_A1(7)
+				  | DRVCTRL5_A2(7)
+				  | DRVCTRL5_A3(7));
+	pfc_reg_write(PFC_DRVCTRL6, DRVCTRL6_A4(7)
+				  | DRVCTRL6_A5(7)
+				  | DRVCTRL6_A6(7)
+				  | DRVCTRL6_A7(7)
+				  | DRVCTRL6_A8(7)
+				  | DRVCTRL6_A9(7)
+				  | DRVCTRL6_A10(7)
+				  | DRVCTRL6_A11(7));
+	pfc_reg_write(PFC_DRVCTRL7, DRVCTRL7_A12(7)
+				  | DRVCTRL7_A13(7)
+				  | DRVCTRL7_A14(7)
+				  | DRVCTRL7_A15(7)
+				  | DRVCTRL7_A16(7)
+				  | DRVCTRL7_A17(7)
+				  | DRVCTRL7_A18(7)
+				  | DRVCTRL7_A19(7));
+	pfc_reg_write(PFC_DRVCTRL8, DRVCTRL8_CLKOUT(7)
+				  | DRVCTRL8_CS0(7)
+				  | DRVCTRL8_CS1_A2(7)
+				  | DRVCTRL8_BS(7)
+				  | DRVCTRL8_RD(7)
+				  | DRVCTRL8_RD_W(7)
+				  | DRVCTRL8_WE0(7)
+				  | DRVCTRL8_WE1(7));
+	pfc_reg_write(PFC_DRVCTRL9, DRVCTRL9_EX_WAIT0(7)
+				  | DRVCTRL9_PRESETOU(7)
+				  | DRVCTRL9_D0(7)
+				  | DRVCTRL9_D1(7)
+				  | DRVCTRL9_D2(7)
+				  | DRVCTRL9_D3(7)
+				  | DRVCTRL9_D4(7)
+				  | DRVCTRL9_D5(7));
+	pfc_reg_write(PFC_DRVCTRL10, DRVCTRL10_D6(7)
+				   | DRVCTRL10_D7(7)
+				   | DRVCTRL10_D8(7)
+				   | DRVCTRL10_D9(7)
+				   | DRVCTRL10_D10(7)
+				   | DRVCTRL10_D11(7)
+				   | DRVCTRL10_D12(7)
+				   | DRVCTRL10_D13(7));
+	pfc_reg_write(PFC_DRVCTRL11, DRVCTRL11_D14(7)
+				   | DRVCTRL11_D15(7)
+				   | DRVCTRL11_AVS1(7)
+				   | DRVCTRL11_AVS2(7)
+				   | DRVCTRL11_HDMI0_CEC(7)
+				   | DRVCTRL11_HDMI1_CEC(7)
+				   | DRVCTRL11_DU_DOTCLKIN0(3)
+				   | DRVCTRL11_DU_DOTCLKIN1(3));
+	pfc_reg_write(PFC_DRVCTRL12, DRVCTRL12_DU_DOTCLKIN2(3)
+				   | DRVCTRL12_DU_DOTCLKIN3(3)
+				   | DRVCTRL12_DU_FSCLKST(3)
+				   | DRVCTRL12_DU_TMS(3));
+	pfc_reg_write(PFC_DRVCTRL13, DRVCTRL13_TDO(3)
+				   | DRVCTRL13_ASEBRK(3)
+				   | DRVCTRL13_SD0_CLK(7)
+				   | DRVCTRL13_SD0_CMD(7)
+				   | DRVCTRL13_SD0_DAT0(7)
+				   | DRVCTRL13_SD0_DAT1(7)
+				   | DRVCTRL13_SD0_DAT2(7)
+				   | DRVCTRL13_SD0_DAT3(7));
+	pfc_reg_write(PFC_DRVCTRL14, DRVCTRL14_SD1_CLK(7)
+				   | DRVCTRL14_SD1_CMD(7)
+				   | DRVCTRL14_SD1_DAT0(7)
+				   | DRVCTRL14_SD1_DAT1(7)
+				   | DRVCTRL14_SD1_DAT2(7)
+				   | DRVCTRL14_SD1_DAT3(7)
+				   | DRVCTRL14_SD2_CLK(7)
+				   | DRVCTRL14_SD2_CMD(7));
+	pfc_reg_write(PFC_DRVCTRL15, DRVCTRL15_SD2_DAT0(7)
+				   | DRVCTRL15_SD2_DAT1(7)
+				   | DRVCTRL15_SD2_DAT2(7)
+				   | DRVCTRL15_SD2_DAT3(7)
+				   | DRVCTRL15_SD2_DS(7)
+				   | DRVCTRL15_SD3_CLK(7)
+				   | DRVCTRL15_SD3_CMD(7)
+				   | DRVCTRL15_SD3_DAT0(7));
+	pfc_reg_write(PFC_DRVCTRL16, DRVCTRL16_SD3_DAT1(7)
+				   | DRVCTRL16_SD3_DAT2(7)
+				   | DRVCTRL16_SD3_DAT3(7)
+				   | DRVCTRL16_SD3_DAT4(7)
+				   | DRVCTRL16_SD3_DAT5(7)
+				   | DRVCTRL16_SD3_DAT6(7)
+				   | DRVCTRL16_SD3_DAT7(7)
+				   | DRVCTRL16_SD3_DS(7));
+	pfc_reg_write(PFC_DRVCTRL17,DRVCTRL17_SD0_CD(7)
+				   | DRVCTRL17_SD0_WP(7)
+				   | DRVCTRL17_SD1_CD(7)
+				   | DRVCTRL17_SD1_WP(7)
+				   | DRVCTRL17_SCK0(7)
+				   | DRVCTRL17_RX0(7)
+				   | DRVCTRL17_TX0(7)
+				   | DRVCTRL17_CTS0(7));
+	pfc_reg_write(PFC_DRVCTRL18, DRVCTRL18_RTS0_TANS(7)
+				   | DRVCTRL18_RX1(7)
+				   | DRVCTRL18_TX1(7)
+				   | DRVCTRL18_CTS1(7)
+				   | DRVCTRL18_RTS1_TANS(7)
+				   | DRVCTRL18_SCK2(7)
+				   | DRVCTRL18_TX2(7)
+				   | DRVCTRL18_RX2(7));
+	pfc_reg_write(PFC_DRVCTRL19, DRVCTRL19_HSCK0(7)
+				   | DRVCTRL19_HRX0(7)
+				   | DRVCTRL19_HTX0(7)
+				   | DRVCTRL19_HCTS0(7)
+				   | DRVCTRL19_HRTS0(7)
+				   | DRVCTRL19_MSIOF0_SCK(7)
+				   | DRVCTRL19_MSIOF0_SYNC(7)
+				   | DRVCTRL19_MSIOF0_SS1(7));
+	pfc_reg_write(PFC_DRVCTRL20, DRVCTRL20_MSIOF0_TXD(7)
+				   | DRVCTRL20_MSIOF0_SS2(7)
+				   | DRVCTRL20_MSIOF0_RXD(7)
+				   | DRVCTRL20_MLB_CLK(7)
+				   | DRVCTRL20_MLB_SIG(7)
+				   | DRVCTRL20_MLB_DAT(7)
+				   | DRVCTRL20_MLB_REF(7)
+				   | DRVCTRL20_SSI_SCK0129(7));
+	pfc_reg_write(PFC_DRVCTRL21, DRVCTRL21_SSI_WS0129(7)
+				   | DRVCTRL21_SSI_SDATA0(7)
+				   | DRVCTRL21_SSI_SDATA1(7)
+				   | DRVCTRL21_SSI_SDATA2(7)
+				   | DRVCTRL21_SSI_SCK34(7)
+				   | DRVCTRL21_SSI_WS34(7)
+				   | DRVCTRL21_SSI_SDATA3(7)
+				   | DRVCTRL21_SSI_SCK4(7));
+	pfc_reg_write(PFC_DRVCTRL22, DRVCTRL22_SSI_WS4(7)
+				   | DRVCTRL22_SSI_SDATA4(7)
+				   | DRVCTRL22_SSI_SCK5(7)
+				   | DRVCTRL22_SSI_WS5(7)
+				   | DRVCTRL22_SSI_SDATA5(7)
+				   | DRVCTRL22_SSI_SCK6(7)
+				   | DRVCTRL22_SSI_WS6(7)
+				   | DRVCTRL22_SSI_SDATA6(7));
+	pfc_reg_write(PFC_DRVCTRL23, DRVCTRL23_SSI_SCK78(7)
+				   | DRVCTRL23_SSI_WS78(7)
+				   | DRVCTRL23_SSI_SDATA7(7)
+				   | DRVCTRL23_SSI_SDATA8(7)
+				   | DRVCTRL23_SSI_SDATA9(7)
+				   | DRVCTRL23_AUDIO_CLKA(7)
+				   | DRVCTRL23_AUDIO_CLKB(7)
+				   | DRVCTRL23_USB0_PWEN(7));
+	pfc_reg_write(PFC_DRVCTRL24, DRVCTRL24_USB0_OVC(7)
+				   | DRVCTRL24_USB1_PWEN(7)
+				   | DRVCTRL24_USB1_OVC(7)
+				   | DRVCTRL24_USB30_PWEN(7)
+				   | DRVCTRL24_USB30_OVC(7)
+				   | DRVCTRL24_USB31_PWEN(7)
+				   | DRVCTRL24_USB31_OVC(7));
+
+	/* initialize LSI pin pull-up/down control */
+	pfc_reg_write(PFC_PUD0,0x00005FBFU);
+	pfc_reg_write(PFC_PUD1,0x00300FFEU);
+	pfc_reg_write(PFC_PUD2,0x330001E6U);
+	pfc_reg_write(PFC_PUD3,0x000002E0U);
+	pfc_reg_write(PFC_PUD4,0xFFFFFF00U);
+	pfc_reg_write(PFC_PUD5,0x7F5FFF87U);
+	pfc_reg_write(PFC_PUD6,0x00000055U);
+
+	/* initialize LSI pin pull-enable register */
+	pfc_reg_write(PFC_PUEN0,0x00000FFFU);
+	pfc_reg_write(PFC_PUEN1,0x00100234U);
+	pfc_reg_write(PFC_PUEN2,0x000004C4U);
+	pfc_reg_write(PFC_PUEN3,0x00000200U);
+	pfc_reg_write(PFC_PUEN4,0x3E000000U);
+	pfc_reg_write(PFC_PUEN5,0x1F000805U);
+	pfc_reg_write(PFC_PUEN6,0x00000006U);
+
+	/* initialize positive/negative logic select */
+	mmio_write_32(GPIO_POSNEG0, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG1, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG2, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG3, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG4, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG5, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG6, 0x00000000U);
+
+	/* initialize general IO/interrupt switching */
+	mmio_write_32(GPIO_IOINTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL1, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL2, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL3, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL5, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL6, 0x00000000U);
+
+	/* initialize general output register */
+	mmio_write_32(GPIO_OUTDT1, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT2, 0x00000400U);
+	mmio_write_32(GPIO_OUTDT3, 0x0000C000U);
+	mmio_write_32(GPIO_OUTDT5, 0x00000006U);
+	mmio_write_32(GPIO_OUTDT6, 0x00003880U);
+
+	/* initialize general input/output switching */
+	mmio_write_32(GPIO_INOUTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL1, 0x01000A00U);
+	mmio_write_32(GPIO_INOUTSEL2, 0x00000400U);
+	mmio_write_32(GPIO_INOUTSEL3, 0x0000C000U);
+	mmio_write_32(GPIO_INOUTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL5, 0x0000020EU);
+	mmio_write_32(GPIO_INOUTSEL6, 0x00013880U);
+}
diff --git a/plat/renesas/rcar/pfc/H3/pfc_init_h3.h b/plat/renesas/rcar/pfc/H3/pfc_init_h3.h
new file mode 100644
index 0000000..31fde81
--- /dev/null
+++ b/plat/renesas/rcar/pfc/H3/pfc_init_h3.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PFC_INIT_H3_H__
+#define PFC_INIT_H3_H__
+
+void pfc_init_h3(void);
+
+#endif	/* PFC_INIT_H3_H__ */
diff --git a/plat/renesas/rcar/pfc/M3/pfc_init_m3.c b/plat/renesas/rcar/pfc/M3/pfc_init_m3.c
new file mode 100644
index 0000000..a711740
--- /dev/null
+++ b/plat/renesas/rcar/pfc/M3/pfc_init_m3.c
@@ -0,0 +1,1562 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>		/* for uint32_t */
+#include <mmio.h>
+#include "bl2_cpg_init.h"
+#include "pfc_init_m3.h"
+#include "../../rcar_def.h"
+
+
+/* GPIO base address */
+#define	GPIO_BASE		(0xE6050000U)
+
+/* GPIO registers */
+#define	GPIO_IOINTSEL0		(GPIO_BASE + 0x0000U)
+#define	GPIO_INOUTSEL0		(GPIO_BASE + 0x0004U)
+#define	GPIO_OUTDT0		(GPIO_BASE + 0x0008U)
+#define	GPIO_INDT0		(GPIO_BASE + 0x000CU)
+#define	GPIO_INTDT0		(GPIO_BASE + 0x0010U)
+#define	GPIO_INTCLR0		(GPIO_BASE + 0x0014U)
+#define	GPIO_INTMSK0		(GPIO_BASE + 0x0018U)
+#define	GPIO_MSKCLR0		(GPIO_BASE + 0x001CU)
+#define	GPIO_POSNEG0		(GPIO_BASE + 0x0020U)
+#define	GPIO_EDGLEVEL0		(GPIO_BASE + 0x0024U)
+#define	GPIO_FILONOFF0		(GPIO_BASE + 0x0028U)
+#define	GPIO_INTMSKS0		(GPIO_BASE + 0x0038U)
+#define	GPIO_MSKCLRS0		(GPIO_BASE + 0x003CU)
+#define	GPIO_OUTDTSEL0		(GPIO_BASE + 0x0040U)
+#define	GPIO_OUTDTH0		(GPIO_BASE + 0x0044U)
+#define	GPIO_OUTDTL0		(GPIO_BASE + 0x0048U)
+#define	GPIO_BOTHEDGE0		(GPIO_BASE + 0x004CU)
+#define	GPIO_IOINTSEL1		(GPIO_BASE + 0x1000U)
+#define	GPIO_INOUTSEL1		(GPIO_BASE + 0x1004U)
+#define	GPIO_OUTDT1		(GPIO_BASE + 0x1008U)
+#define	GPIO_INDT1		(GPIO_BASE + 0x100CU)
+#define	GPIO_INTDT1		(GPIO_BASE + 0x1010U)
+#define	GPIO_INTCLR1		(GPIO_BASE + 0x1014U)
+#define	GPIO_INTMSK1		(GPIO_BASE + 0x1018U)
+#define	GPIO_MSKCLR1		(GPIO_BASE + 0x101CU)
+#define	GPIO_POSNEG1		(GPIO_BASE + 0x1020U)
+#define	GPIO_EDGLEVEL1		(GPIO_BASE + 0x1024U)
+#define	GPIO_FILONOFF1		(GPIO_BASE + 0x1028U)
+#define	GPIO_INTMSKS1		(GPIO_BASE + 0x1038U)
+#define	GPIO_MSKCLRS1		(GPIO_BASE + 0x103CU)
+#define	GPIO_OUTDTSEL1		(GPIO_BASE + 0x1040U)
+#define	GPIO_OUTDTH1		(GPIO_BASE + 0x1044U)
+#define	GPIO_OUTDTL1		(GPIO_BASE + 0x1048U)
+#define	GPIO_BOTHEDGE1		(GPIO_BASE + 0x104CU)
+#define	GPIO_IOINTSEL2		(GPIO_BASE + 0x2000U)
+#define	GPIO_INOUTSEL2		(GPIO_BASE + 0x2004U)
+#define	GPIO_OUTDT2		(GPIO_BASE + 0x2008U)
+#define	GPIO_INDT2		(GPIO_BASE + 0x200CU)
+#define	GPIO_INTDT2		(GPIO_BASE + 0x2010U)
+#define	GPIO_INTCLR2		(GPIO_BASE + 0x2014U)
+#define	GPIO_INTMSK2		(GPIO_BASE + 0x2018U)
+#define	GPIO_MSKCLR2		(GPIO_BASE + 0x201CU)
+#define	GPIO_POSNEG2		(GPIO_BASE + 0x2020U)
+#define	GPIO_EDGLEVEL2		(GPIO_BASE + 0x2024U)
+#define	GPIO_FILONOFF2		(GPIO_BASE + 0x2028U)
+#define	GPIO_INTMSKS2		(GPIO_BASE + 0x2038U)
+#define	GPIO_MSKCLRS2		(GPIO_BASE + 0x203CU)
+#define	GPIO_OUTDTSEL2		(GPIO_BASE + 0x2040U)
+#define	GPIO_OUTDTH2		(GPIO_BASE + 0x2044U)
+#define	GPIO_OUTDTL2		(GPIO_BASE + 0x2048U)
+#define	GPIO_BOTHEDGE2		(GPIO_BASE + 0x204CU)
+#define	GPIO_IOINTSEL3		(GPIO_BASE + 0x3000U)
+#define	GPIO_INOUTSEL3		(GPIO_BASE + 0x3004U)
+#define	GPIO_OUTDT3		(GPIO_BASE + 0x3008U)
+#define	GPIO_INDT3		(GPIO_BASE + 0x300CU)
+#define	GPIO_INTDT3		(GPIO_BASE + 0x3010U)
+#define	GPIO_INTCLR3		(GPIO_BASE + 0x3014U)
+#define	GPIO_INTMSK3		(GPIO_BASE + 0x3018U)
+#define	GPIO_MSKCLR3		(GPIO_BASE + 0x301CU)
+#define	GPIO_POSNEG3		(GPIO_BASE + 0x3020U)
+#define	GPIO_EDGLEVEL3		(GPIO_BASE + 0x3024U)
+#define	GPIO_FILONOFF3		(GPIO_BASE + 0x3028U)
+#define	GPIO_INTMSKS3		(GPIO_BASE + 0x3038U)
+#define	GPIO_MSKCLRS3		(GPIO_BASE + 0x303CU)
+#define	GPIO_OUTDTSEL3		(GPIO_BASE + 0x3040U)
+#define	GPIO_OUTDTH3		(GPIO_BASE + 0x3044U)
+#define	GPIO_OUTDTL3		(GPIO_BASE + 0x3048U)
+#define	GPIO_BOTHEDGE3		(GPIO_BASE + 0x304CU)
+#define	GPIO_IOINTSEL4		(GPIO_BASE + 0x4000U)
+#define	GPIO_INOUTSEL4		(GPIO_BASE + 0x4004U)
+#define	GPIO_OUTDT4		(GPIO_BASE + 0x4008U)
+#define	GPIO_INDT4		(GPIO_BASE + 0x400CU)
+#define	GPIO_INTDT4		(GPIO_BASE + 0x4010U)
+#define	GPIO_INTCLR4		(GPIO_BASE + 0x4014U)
+#define	GPIO_INTMSK4		(GPIO_BASE + 0x4018U)
+#define	GPIO_MSKCLR4		(GPIO_BASE + 0x401CU)
+#define	GPIO_POSNEG4		(GPIO_BASE + 0x4020U)
+#define	GPIO_EDGLEVEL4		(GPIO_BASE + 0x4024U)
+#define	GPIO_FILONOFF4		(GPIO_BASE + 0x4028U)
+#define	GPIO_INTMSKS4		(GPIO_BASE + 0x4038U)
+#define	GPIO_MSKCLRS4		(GPIO_BASE + 0x403CU)
+#define	GPIO_OUTDTSEL4		(GPIO_BASE + 0x4040U)
+#define	GPIO_OUTDTH4		(GPIO_BASE + 0x4044U)
+#define	GPIO_OUTDTL4		(GPIO_BASE + 0x4048U)
+#define	GPIO_BOTHEDGE4		(GPIO_BASE + 0x404CU)
+#define	GPIO_IOINTSEL5		(GPIO_BASE + 0x5000U)
+#define	GPIO_INOUTSEL5		(GPIO_BASE + 0x5004U)
+#define	GPIO_OUTDT5		(GPIO_BASE + 0x5008U)
+#define	GPIO_INDT5		(GPIO_BASE + 0x500CU)
+#define	GPIO_INTDT5		(GPIO_BASE + 0x5010U)
+#define	GPIO_INTCLR5		(GPIO_BASE + 0x5014U)
+#define	GPIO_INTMSK5		(GPIO_BASE + 0x5018U)
+#define	GPIO_MSKCLR5		(GPIO_BASE + 0x501CU)
+#define	GPIO_POSNEG5		(GPIO_BASE + 0x5020U)
+#define	GPIO_EDGLEVEL5		(GPIO_BASE + 0x5024U)
+#define	GPIO_FILONOFF5		(GPIO_BASE + 0x5028U)
+#define	GPIO_INTMSKS5		(GPIO_BASE + 0x5038U)
+#define	GPIO_MSKCLRS5		(GPIO_BASE + 0x503CU)
+#define	GPIO_OUTDTSEL5		(GPIO_BASE + 0x5040U)
+#define	GPIO_OUTDTH5		(GPIO_BASE + 0x5044U)
+#define	GPIO_OUTDTL5		(GPIO_BASE + 0x5048U)
+#define	GPIO_BOTHEDGE5		(GPIO_BASE + 0x504CU)
+#define	GPIO_IOINTSEL6		(GPIO_BASE + 0x5400U)
+#define	GPIO_INOUTSEL6		(GPIO_BASE + 0x5404U)
+#define	GPIO_OUTDT6		(GPIO_BASE + 0x5408U)
+#define	GPIO_INDT6		(GPIO_BASE + 0x540CU)
+#define	GPIO_INTDT6		(GPIO_BASE + 0x5410U)
+#define	GPIO_INTCLR6		(GPIO_BASE + 0x5414U)
+#define	GPIO_INTMSK6		(GPIO_BASE + 0x5418U)
+#define	GPIO_MSKCLR6		(GPIO_BASE + 0x541CU)
+#define	GPIO_POSNEG6		(GPIO_BASE + 0x5420U)
+#define	GPIO_EDGLEVEL6		(GPIO_BASE + 0x5424U)
+#define	GPIO_FILONOFF6		(GPIO_BASE + 0x5428U)
+#define	GPIO_INTMSKS6		(GPIO_BASE + 0x5438U)
+#define	GPIO_MSKCLRS6		(GPIO_BASE + 0x543CU)
+#define	GPIO_OUTDTSEL6		(GPIO_BASE + 0x5440U)
+#define	GPIO_OUTDTH6		(GPIO_BASE + 0x5444U)
+#define	GPIO_OUTDTL6		(GPIO_BASE + 0x5448U)
+#define	GPIO_BOTHEDGE6		(GPIO_BASE + 0x544CU)
+#define	GPIO_IOINTSEL7		(GPIO_BASE + 0x5800U)
+#define	GPIO_INOUTSEL7		(GPIO_BASE + 0x5804U)
+#define	GPIO_OUTDT7		(GPIO_BASE + 0x5808U)
+#define	GPIO_INDT7		(GPIO_BASE + 0x580CU)
+#define	GPIO_INTDT7		(GPIO_BASE + 0x5810U)
+#define	GPIO_INTCLR7		(GPIO_BASE + 0x5814U)
+#define	GPIO_INTMSK7		(GPIO_BASE + 0x5818U)
+#define	GPIO_MSKCLR7		(GPIO_BASE + 0x581CU)
+#define	GPIO_POSNEG7		(GPIO_BASE + 0x5820U)
+#define	GPIO_EDGLEVEL7		(GPIO_BASE + 0x5824U)
+#define	GPIO_FILONOFF7		(GPIO_BASE + 0x5828U)
+#define	GPIO_INTMSKS7		(GPIO_BASE + 0x5838U)
+#define	GPIO_MSKCLRS7		(GPIO_BASE + 0x583CU)
+#define	GPIO_OUTDTSEL7		(GPIO_BASE + 0x5840U)
+#define	GPIO_OUTDTH7		(GPIO_BASE + 0x5844U)
+#define	GPIO_OUTDTL7		(GPIO_BASE + 0x5848U)
+#define	GPIO_BOTHEDGE7		(GPIO_BASE + 0x584CU)
+
+
+/* Pin functon base address */
+#define	PFC_BASE		(0xE6060000U)
+
+/* Pin functon registers */
+#define	PFC_PMMR		(PFC_BASE + 0x0000U)
+#define PFC_GPSR0		(PFC_BASE + 0x0100U)
+#define PFC_GPSR1		(PFC_BASE + 0x0104U)
+#define PFC_GPSR2		(PFC_BASE + 0x0108U)
+#define PFC_GPSR3		(PFC_BASE + 0x010CU)
+#define PFC_GPSR4		(PFC_BASE + 0x0110U)
+#define	PFC_GPSR5		(PFC_BASE + 0x0114U)
+#define	PFC_GPSR6		(PFC_BASE + 0x0118U)
+#define	PFC_GPSR7		(PFC_BASE + 0x011CU)
+#define	PFC_IPSR0		(PFC_BASE + 0x0200U)
+#define	PFC_IPSR1		(PFC_BASE + 0x0204U)
+#define	PFC_IPSR2		(PFC_BASE + 0x0208U)
+#define	PFC_IPSR3		(PFC_BASE + 0x020CU)
+#define	PFC_IPSR4		(PFC_BASE + 0x0210U)
+#define	PFC_IPSR5		(PFC_BASE + 0x0214U)
+#define	PFC_IPSR6		(PFC_BASE + 0x0218U)
+#define	PFC_IPSR7		(PFC_BASE + 0x021CU)
+#define	PFC_IPSR8		(PFC_BASE + 0x0220U)
+#define	PFC_IPSR9		(PFC_BASE + 0x0224U)
+#define	PFC_IPSR10		(PFC_BASE + 0x0228U)
+#define	PFC_IPSR11		(PFC_BASE + 0x022CU)
+#define	PFC_IPSR12		(PFC_BASE + 0x0230U)
+#define	PFC_IPSR13		(PFC_BASE + 0x0234U)
+#define	PFC_IPSR14		(PFC_BASE + 0x0238U)
+#define	PFC_IPSR15		(PFC_BASE + 0x023CU)
+#define	PFC_IPSR16		(PFC_BASE + 0x0240U)
+#define	PFC_IPSR17		(PFC_BASE + 0x0244U)
+#define	PFC_IPSR18		(PFC_BASE + 0x0248U)
+#define PFC_DRVCTRL0		(PFC_BASE + 0x0300U)
+#define PFC_DRVCTRL1		(PFC_BASE + 0x0304U)
+#define PFC_DRVCTRL2		(PFC_BASE + 0x0308U)
+#define PFC_DRVCTRL3		(PFC_BASE + 0x030CU)
+#define PFC_DRVCTRL4		(PFC_BASE + 0x0310U)
+#define PFC_DRVCTRL5		(PFC_BASE + 0x0314U)
+#define PFC_DRVCTRL6		(PFC_BASE + 0x0318U)
+#define PFC_DRVCTRL7		(PFC_BASE + 0x031CU)
+#define PFC_DRVCTRL8		(PFC_BASE + 0x0320U)
+#define PFC_DRVCTRL9		(PFC_BASE + 0x0324U)
+#define PFC_DRVCTRL10		(PFC_BASE + 0x0328U)
+#define PFC_DRVCTRL11		(PFC_BASE + 0x032CU)
+#define PFC_DRVCTRL12		(PFC_BASE + 0x0330U)
+#define PFC_DRVCTRL13		(PFC_BASE + 0x0334U)
+#define PFC_DRVCTRL14		(PFC_BASE + 0x0338U)
+#define PFC_DRVCTRL15		(PFC_BASE + 0x033CU)
+#define PFC_DRVCTRL16		(PFC_BASE + 0x0340U)
+#define PFC_DRVCTRL17		(PFC_BASE + 0x0344U)
+#define PFC_DRVCTRL18		(PFC_BASE + 0x0348U)
+#define PFC_DRVCTRL19		(PFC_BASE + 0x034CU)
+#define PFC_DRVCTRL20		(PFC_BASE + 0x0350U)
+#define PFC_DRVCTRL21		(PFC_BASE + 0x0354U)
+#define PFC_DRVCTRL22		(PFC_BASE + 0x0358U)
+#define PFC_DRVCTRL23		(PFC_BASE + 0x035CU)
+#define PFC_DRVCTRL24		(PFC_BASE + 0x0360U)
+#define PFC_POCCTRL0		(PFC_BASE + 0x0380U)
+#define	PFC_TDSELCTRL0		(PFC_BASE + 0x03C0U)
+#define	PFC_IOCTRL		(PFC_BASE + 0x03E0U)
+#define	PFC_TSREG		(PFC_BASE + 0x03E4U)
+#define	PFC_PUEN0		(PFC_BASE + 0x0400U)
+#define	PFC_PUEN1		(PFC_BASE + 0x0404U)
+#define	PFC_PUEN2		(PFC_BASE + 0x0408U)
+#define	PFC_PUEN3		(PFC_BASE + 0x040CU)
+#define	PFC_PUEN4		(PFC_BASE + 0x0410U)
+#define	PFC_PUEN5		(PFC_BASE + 0x0414U)
+#define	PFC_PUEN6		(PFC_BASE + 0x0418U)
+#define	PFC_PUD0		(PFC_BASE + 0x0440U)
+#define	PFC_PUD1		(PFC_BASE + 0x0444U)
+#define	PFC_PUD2		(PFC_BASE + 0x0448U)
+#define	PFC_PUD3		(PFC_BASE + 0x044CU)
+#define	PFC_PUD4		(PFC_BASE + 0x0450U)
+#define	PFC_PUD5		(PFC_BASE + 0x0454U)
+#define	PFC_PUD6		(PFC_BASE + 0x0458U)
+#define	PFC_MOD_SEL0		(PFC_BASE + 0x0500U)
+#define	PFC_MOD_SEL1		(PFC_BASE + 0x0504U)
+#define	PFC_MOD_SEL2		(PFC_BASE + 0x0508U)
+
+#define	GPSR0_D15		((uint32_t)1U << 15U)
+#define	GPSR0_D14		((uint32_t)1U << 14U)
+#define	GPSR0_D13		((uint32_t)1U << 13U)
+#define	GPSR0_D12		((uint32_t)1U << 12U)
+#define	GPSR0_D11		((uint32_t)1U << 11U)
+#define	GPSR0_D10		((uint32_t)1U << 10U)
+#define	GPSR0_D9		((uint32_t)1U << 9U)
+#define	GPSR0_D8		((uint32_t)1U << 8U)
+#define	GPSR0_D7		((uint32_t)1U << 7U)
+#define	GPSR0_D6		((uint32_t)1U << 6U)
+#define	GPSR0_D5		((uint32_t)1U << 5U)
+#define	GPSR0_D4		((uint32_t)1U << 4U)
+#define	GPSR0_D3		((uint32_t)1U << 3U)
+#define	GPSR0_D2		((uint32_t)1U << 2U)
+#define	GPSR0_D1		((uint32_t)1U << 1U)
+#define	GPSR0_D0		((uint32_t)1U << 0U)
+#define	GPSR1_CLKOUT		((uint32_t)1U << 28U)
+#define	GPSR1_EX_WAIT0_A	((uint32_t)1U << 27U)
+#define	GPSR1_WE1		((uint32_t)1U << 26U)
+#define	GPSR1_WE0		((uint32_t)1U << 25U)
+#define	GPSR1_RD_WR		((uint32_t)1U << 24U)
+#define	GPSR1_RD		((uint32_t)1U << 23U)
+#define	GPSR1_BS		((uint32_t)1U << 22U)
+#define	GPSR1_CS1_A26		((uint32_t)1U << 21U)
+#define	GPSR1_CS0		((uint32_t)1U << 20U)
+#define	GPSR1_A19		((uint32_t)1U << 19U)
+#define	GPSR1_A18		((uint32_t)1U << 18U)
+#define	GPSR1_A17		((uint32_t)1U << 17U)
+#define	GPSR1_A16		((uint32_t)1U << 16U)
+#define	GPSR1_A15		((uint32_t)1U << 15U)
+#define	GPSR1_A14		((uint32_t)1U << 14U)
+#define	GPSR1_A13		((uint32_t)1U << 13U)
+#define	GPSR1_A12		((uint32_t)1U << 12U)
+#define	GPSR1_A11		((uint32_t)1U << 11U)
+#define	GPSR1_A10		((uint32_t)1U << 10U)
+#define	GPSR1_A9		((uint32_t)1U << 9U)
+#define	GPSR1_A8		((uint32_t)1U << 8U)
+#define	GPSR1_A7		((uint32_t)1U << 7U)
+#define	GPSR1_A6		((uint32_t)1U << 6U)
+#define	GPSR1_A5		((uint32_t)1U << 5U)
+#define	GPSR1_A4		((uint32_t)1U << 4U)
+#define	GPSR1_A3		((uint32_t)1U << 3U)
+#define	GPSR1_A2		((uint32_t)1U << 2U)
+#define	GPSR1_A1		((uint32_t)1U << 1U)
+#define	GPSR1_A0		((uint32_t)1U << 0U)
+#define	GPSR2_AVB_AVTP_CAPTURE_A	((uint32_t)1U << 14U)
+#define	GPSR2_AVB_AVTP_MATCH_A	((uint32_t)1U << 13U)
+#define	GPSR2_AVB_LINK		((uint32_t)1U << 12U)
+#define	GPSR2_AVB_PHY_INT	((uint32_t)1U << 11U)
+#define	GPSR2_AVB_MAGIC		((uint32_t)1U << 10U)
+#define	GPSR2_AVB_MDC		((uint32_t)1U << 9U)
+#define	GPSR2_PWM2_A		((uint32_t)1U << 8U)
+#define	GPSR2_PWM1_A		((uint32_t)1U << 7U)
+#define	GPSR2_PWM0		((uint32_t)1U << 6U)
+#define	GPSR2_IRQ5		((uint32_t)1U << 5U)
+#define	GPSR2_IRQ4		((uint32_t)1U << 4U)
+#define	GPSR2_IRQ3		((uint32_t)1U << 3U)
+#define	GPSR2_IRQ2		((uint32_t)1U << 2U)
+#define	GPSR2_IRQ1		((uint32_t)1U << 1U)
+#define	GPSR2_IRQ0		((uint32_t)1U << 0U)
+#define	GPSR3_SD1_WP		((uint32_t)1U << 15U)
+#define	GPSR3_SD1_CD		((uint32_t)1U << 14U)
+#define	GPSR3_SD0_WP		((uint32_t)1U << 13U)
+#define	GPSR3_SD0_CD		((uint32_t)1U << 12U)
+#define	GPSR3_SD1_DAT3		((uint32_t)1U << 11U)
+#define	GPSR3_SD1_DAT2		((uint32_t)1U << 10U)
+#define	GPSR3_SD1_DAT1		((uint32_t)1U << 9U)
+#define	GPSR3_SD1_DAT0		((uint32_t)1U << 8U)
+#define	GPSR3_SD1_CMD		((uint32_t)1U << 7U)
+#define	GPSR3_SD1_CLK		((uint32_t)1U << 6U)
+#define	GPSR3_SD0_DAT3		((uint32_t)1U << 5U)
+#define	GPSR3_SD0_DAT2		((uint32_t)1U << 4U)
+#define	GPSR3_SD0_DAT1		((uint32_t)1U << 3U)
+#define	GPSR3_SD0_DAT0		((uint32_t)1U << 2U)
+#define	GPSR3_SD0_CMD		((uint32_t)1U << 1U)
+#define	GPSR3_SD0_CLK		((uint32_t)1U << 0U)
+#define	GPSR4_SD3_DS		((uint32_t)1U << 17U)
+#define	GPSR4_SD3_DAT7		((uint32_t)1U << 16U)
+#define	GPSR4_SD3_DAT6		((uint32_t)1U << 15U)
+#define	GPSR4_SD3_DAT5		((uint32_t)1U << 14U)
+#define	GPSR4_SD3_DAT4		((uint32_t)1U << 13U)
+#define	GPSR4_SD3_DAT3		((uint32_t)1U << 12U)
+#define	GPSR4_SD3_DAT2		((uint32_t)1U << 11U)
+#define	GPSR4_SD3_DAT1		((uint32_t)1U << 10U)
+#define	GPSR4_SD3_DAT0		((uint32_t)1U << 9U)
+#define	GPSR4_SD3_CMD		((uint32_t)1U << 8U)
+#define	GPSR4_SD3_CLK		((uint32_t)1U << 7U)
+#define	GPSR4_SD2_DS		((uint32_t)1U << 6U)
+#define	GPSR4_SD2_DAT3		((uint32_t)1U << 5U)
+#define	GPSR4_SD2_DAT2		((uint32_t)1U << 4U)
+#define	GPSR4_SD2_DAT1		((uint32_t)1U << 3U)
+#define	GPSR4_SD2_DAT0		((uint32_t)1U << 2U)
+#define	GPSR4_SD2_CMD		((uint32_t)1U << 1U)
+#define	GPSR4_SD2_CLK		((uint32_t)1U << 0U)
+#define	GPSR5_MLB_DAT		((uint32_t)1U << 25U)
+#define	GPSR5_MLB_SIG		((uint32_t)1U << 24U)
+#define	GPSR5_MLB_CLK		((uint32_t)1U << 23U)
+#define	GPSR5_MSIOF0_RXD	((uint32_t)1U << 22U)
+#define	GPSR5_MSIOF0_SS2	((uint32_t)1U << 21U)
+#define	GPSR5_MSIOF0_TXD	((uint32_t)1U << 20U)
+#define	GPSR5_MSIOF0_SS1	((uint32_t)1U << 19U)
+#define	GPSR5_MSIOF0_SYNC	((uint32_t)1U << 18U)
+#define	GPSR5_MSIOF0_SCK	((uint32_t)1U << 17U)
+#define	GPSR5_HRTS0		((uint32_t)1U << 16U)
+#define	GPSR5_HCTS0		((uint32_t)1U << 15U)
+#define	GPSR5_HTX0		((uint32_t)1U << 14U)
+#define	GPSR5_HRX0		((uint32_t)1U << 13U)
+#define	GPSR5_HSCK0		((uint32_t)1U << 12U)
+#define	GPSR5_RX2_A		((uint32_t)1U << 11U)
+#define	GPSR5_TX2_A		((uint32_t)1U << 10U)
+#define	GPSR5_SCK2		((uint32_t)1U << 9U)
+#define	GPSR5_RTS1_TANS		((uint32_t)1U << 8U)
+#define	GPSR5_CTS1		((uint32_t)1U << 7U)
+#define	GPSR5_TX1_A		((uint32_t)1U << 6U)
+#define	GPSR5_RX1_A		((uint32_t)1U << 5U)
+#define	GPSR5_RTS0_TANS		((uint32_t)1U << 4U)
+#define	GPSR5_CTS0		((uint32_t)1U << 3U)
+#define	GPSR5_TX0		((uint32_t)1U << 2U)
+#define	GPSR5_RX0		((uint32_t)1U << 1U)
+#define	GPSR5_SCK0		((uint32_t)1U << 0U)
+#define	GPSR6_USB31_OVC		((uint32_t)1U << 31U)
+#define	GPSR6_USB31_PWEN	((uint32_t)1U << 30U)
+#define	GPSR6_USB30_OVC		((uint32_t)1U << 29U)
+#define	GPSR6_USB30_PWEN	((uint32_t)1U << 28U)
+#define	GPSR6_USB1_OVC		((uint32_t)1U << 27U)
+#define	GPSR6_USB1_PWEN		((uint32_t)1U << 26U)
+#define	GPSR6_USB0_OVC		((uint32_t)1U << 25U)
+#define	GPSR6_USB0_PWEN		((uint32_t)1U << 24U)
+#define	GPSR6_AUDIO_CLKB_B	((uint32_t)1U << 23U)
+#define	GPSR6_AUDIO_CLKA_A	((uint32_t)1U << 22U)
+#define	GPSR6_SSI_SDATA9_A	((uint32_t)1U << 21U)
+#define	GPSR6_SSI_SDATA8	((uint32_t)1U << 20U)
+#define	GPSR6_SSI_SDATA7	((uint32_t)1U << 19U)
+#define	GPSR6_SSI_WS78		((uint32_t)1U << 18U)
+#define	GPSR6_SSI_SCK78		((uint32_t)1U << 17U)
+#define	GPSR6_SSI_SDATA6	((uint32_t)1U << 16U)
+#define	GPSR6_SSI_WS6		((uint32_t)1U << 15U)
+#define	GPSR6_SSI_SCK6		((uint32_t)1U << 14U)
+#define	GPSR6_SSI_SDATA5	((uint32_t)1U << 13U)
+#define	GPSR6_SSI_WS5		((uint32_t)1U << 12U)
+#define	GPSR6_SSI_SCK5		((uint32_t)1U << 11U)
+#define	GPSR6_SSI_SDATA4	((uint32_t)1U << 10U)
+#define	GPSR6_SSI_WS4		((uint32_t)1U << 9U)
+#define	GPSR6_SSI_SCK4		((uint32_t)1U << 8U)
+#define	GPSR6_SSI_SDATA3	((uint32_t)1U << 7U)
+#define	GPSR6_SSI_WS34		((uint32_t)1U << 6U)
+#define	GPSR6_SSI_SCK34		((uint32_t)1U << 5U)
+#define	GPSR6_SSI_SDATA2_A	((uint32_t)1U << 4U)
+#define	GPSR6_SSI_SDATA1_A	((uint32_t)1U << 3U)
+#define	GPSR6_SSI_SDATA0	((uint32_t)1U << 2U)
+#define	GPSR6_SSI_WS0129	((uint32_t)1U << 1U)
+#define	GPSR6_SSI_SCK0129	((uint32_t)1U << 0U)
+#define	GPSR7_HDMI1_CEC		((uint32_t)1U << 3U)
+#define	GPSR7_HDMI0_CEC		((uint32_t)1U << 2U)
+#define	GPSR7_AVS2		((uint32_t)1U << 1U)
+#define	GPSR7_AVS1		((uint32_t)1U << 0U)
+
+#define	IPSR_28_FUNC(x)		((uint32_t)(x) << 28U)
+#define	IPSR_24_FUNC(x)		((uint32_t)(x) << 24U)
+#define	IPSR_20_FUNC(x)		((uint32_t)(x) << 20U)
+#define	IPSR_16_FUNC(x)		((uint32_t)(x) << 16U)
+#define	IPSR_12_FUNC(x)		((uint32_t)(x) << 12U)
+#define	IPSR_8_FUNC(x)		((uint32_t)(x) << 8U)
+#define	IPSR_4_FUNC(x)		((uint32_t)(x) << 4U)
+#define	IPSR_0_FUNC(x)		((uint32_t)(x) << 0U)
+
+#define	POC_SD3_DS_33V		((uint32_t)1U << 29U)
+#define	POC_SD3_DAT7_33V	((uint32_t)1U << 28U)
+#define	POC_SD3_DAT6_33V	((uint32_t)1U << 27U)
+#define	POC_SD3_DAT5_33V	((uint32_t)1U << 26U)
+#define	POC_SD3_DAT4_33V	((uint32_t)1U << 25U)
+#define	POC_SD3_DAT3_33V	((uint32_t)1U << 24U)
+#define	POC_SD3_DAT2_33V	((uint32_t)1U << 23U)
+#define	POC_SD3_DAT1_33V	((uint32_t)1U << 22U)
+#define	POC_SD3_DAT0_33V	((uint32_t)1U << 21U)
+#define	POC_SD3_CMD_33V		((uint32_t)1U << 20U)
+#define	POC_SD3_CLK_33V		((uint32_t)1U << 19U)
+#define	POC_SD2_DS_33V		((uint32_t)1U << 18U)
+#define	POC_SD2_DAT3_33V	((uint32_t)1U << 17U)
+#define	POC_SD2_DAT2_33V	((uint32_t)1U << 16U)
+#define	POC_SD2_DAT1_33V	((uint32_t)1U << 15U)
+#define	POC_SD2_DAT0_33V	((uint32_t)1U << 14U)
+#define	POC_SD2_CMD_33V		((uint32_t)1U << 13U)
+#define	POC_SD2_CLK_33V		((uint32_t)1U << 12U)
+#define	POC_SD1_DAT3_33V	((uint32_t)1U << 11U)
+#define	POC_SD1_DAT2_33V	((uint32_t)1U << 10U)
+#define	POC_SD1_DAT1_33V	((uint32_t)1U << 9U)
+#define	POC_SD1_DAT0_33V	((uint32_t)1U << 8U)
+#define	POC_SD1_CMD_33V		((uint32_t)1U << 7U)
+#define	POC_SD1_CLK_33V		((uint32_t)1U << 6U)
+#define	POC_SD0_DAT3_33V	((uint32_t)1U << 5U)
+#define	POC_SD0_DAT2_33V	((uint32_t)1U << 4U)
+#define	POC_SD0_DAT1_33V	((uint32_t)1U << 3U)
+#define	POC_SD0_DAT0_33V	((uint32_t)1U << 2U)
+#define	POC_SD0_CMD_33V		((uint32_t)1U << 1U)
+#define	POC_SD0_CLK_33V		((uint32_t)1U << 0U)
+
+#define	DRVCTRL0_MASK		(0xCCCCCCCCU)
+#define	DRVCTRL1_MASK		(0xCCCCCCC8U)
+#define	DRVCTRL2_MASK		(0x88888888U)
+#define	DRVCTRL3_MASK		(0x88888888U)
+#define	DRVCTRL4_MASK		(0x88888888U)
+#define	DRVCTRL5_MASK		(0x88888888U)
+#define	DRVCTRL6_MASK		(0x88888888U)
+#define	DRVCTRL7_MASK		(0x88888888U)
+#define	DRVCTRL8_MASK		(0x88888888U)
+#define	DRVCTRL9_MASK		(0x88888888U)
+#define	DRVCTRL10_MASK		(0x88888888U)
+#define	DRVCTRL11_MASK		(0x888888CCU)
+#define	DRVCTRL12_MASK		(0xCCCFFFCFU)
+#define	DRVCTRL13_MASK		(0xCC888888U)
+#define	DRVCTRL14_MASK		(0x88888888U)
+#define	DRVCTRL15_MASK		(0x88888888U)
+#define	DRVCTRL16_MASK		(0x88888888U)
+#define	DRVCTRL17_MASK		(0x88888888U)
+#define	DRVCTRL18_MASK		(0x88888888U)
+#define	DRVCTRL19_MASK		(0x88888888U)
+#define	DRVCTRL20_MASK		(0x88888888U)
+#define	DRVCTRL21_MASK		(0x88888888U)
+#define	DRVCTRL22_MASK		(0x88888888U)
+#define	DRVCTRL23_MASK		(0x88888888U)
+#define	DRVCTRL24_MASK		(0x8888888FU)
+
+#define	DRVCTRL0_QSPI0_SPCLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL0_QSPI0_MOSI_IO0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL0_QSPI0_MISO_IO1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL0_QSPI0_IO2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL0_QSPI0_IO3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL0_QSPI0_SSL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL0_QSPI1_SPCLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL0_QSPI1_MOSI_IO0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL1_QSPI1_MISO_IO1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL1_QSPI1_IO2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL1_QSPI1_IO3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL1_QSPI1_SS(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL1_RPC_INT(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL1_RPC_WP(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL1_RPC_RESET(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL1_AVB_RX_CTL(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL2_AVB_RXC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL2_AVB_RD0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL2_AVB_RD1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL2_AVB_RD2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL2_AVB_RD3(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL2_AVB_TX_CTL(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL2_AVB_TXC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL2_AVB_TD0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL3_AVB_TD1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL3_AVB_TD2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL3_AVB_TD3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL3_AVB_TXCREFCLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL3_AVB_MDIO(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL3_AVB_MDC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL3_AVB_MAGIC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL3_AVB_PHY_INT(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL4_AVB_LINK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL4_AVB_AVTP_MATCH(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL4_AVB_AVTP_CAPTURE(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL4_IRQ0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL4_IRQ1(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL4_IRQ2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL4_IRQ3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL4_IRQ4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL5_IRQ5(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL5_PWM0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL5_PWM1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL5_PWM2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL5_A0(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL5_A1(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL5_A2(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL5_A3(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL6_A4(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL6_A5(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL6_A6(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL6_A7(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL6_A8(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL6_A9(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL6_A10(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL6_A11(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL7_A12(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL7_A13(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL7_A14(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL7_A15(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL7_A16(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL7_A17(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL7_A18(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL7_A19(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL8_CLKOUT(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL8_CS0(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL8_CS1_A2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL8_BS(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL8_RD(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL8_RD_W(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL8_WE0(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL8_WE1(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL9_EX_WAIT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL9_PRESETOU(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL9_D0(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL9_D1(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL9_D2(x)		((uint32_t)(x) << 12U)
+#define	DRVCTRL9_D3(x)		((uint32_t)(x) << 8U)
+#define	DRVCTRL9_D4(x)		((uint32_t)(x) << 4U)
+#define	DRVCTRL9_D5(x)		((uint32_t)(x) << 0U)
+#define	DRVCTRL10_D6(x)		((uint32_t)(x) << 28U)
+#define	DRVCTRL10_D7(x)		((uint32_t)(x) << 24U)
+#define	DRVCTRL10_D8(x)		((uint32_t)(x) << 20U)
+#define	DRVCTRL10_D9(x)		((uint32_t)(x) << 16U)
+#define	DRVCTRL10_D10(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL10_D11(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL10_D12(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL10_D13(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL11_D14(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL11_D15(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL11_AVS1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL11_AVS2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL11_HDMI0_CEC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL11_HDMI1_CEC(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL11_DU_DOTCLKIN0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL11_DU_DOTCLKIN1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL12_DU_DOTCLKIN2(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL12_DU_DOTCLKIN3(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL12_DU_FSCLKST(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL12_DU_TMS(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_TDO(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL13_ASEBRK(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL13_SD0_CLK(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL13_SD0_CMD(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL13_SD0_DAT0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL13_SD0_DAT1(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL13_SD0_DAT2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL13_SD0_DAT3(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL14_SD1_CLK(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL14_SD1_CMD(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL14_SD1_DAT0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL14_SD1_DAT1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL14_SD1_DAT2(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL14_SD1_DAT3(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL14_SD2_CLK(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL14_SD2_CMD(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL15_SD2_DAT0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL15_SD2_DAT1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL15_SD2_DAT2(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL15_SD2_DAT3(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL15_SD2_DS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL15_SD3_CLK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL15_SD3_CMD(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL15_SD3_DAT0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL16_SD3_DAT1(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL16_SD3_DAT2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL16_SD3_DAT3(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL16_SD3_DAT4(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL16_SD3_DAT5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL16_SD3_DAT6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL16_SD3_DAT7(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL16_SD3_DS(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL17_SD0_CD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL17_SD0_WP(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL17_SD1_CD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL17_SD1_WP(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL17_SCK0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL17_RX0(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL17_TX0(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL17_CTS0(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL18_RTS0_TANS(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL18_RX1(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL18_TX1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL18_CTS1(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL18_RTS1_TANS(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL18_SCK2(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL18_TX2(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL18_RX2(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL19_HSCK0(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL19_HRX0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL19_HTX0(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL19_HCTS0(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL19_HRTS0(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL19_MSIOF0_SCK(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL19_MSIOF0_SYNC(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL19_MSIOF0_SS1(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL20_MSIOF0_TXD(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL20_MSIOF0_SS2(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL20_MSIOF0_RXD(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL20_MLB_CLK(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL20_MLB_SIG(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL20_MLB_DAT(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL20_MLB_REF(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL20_SSI_SCK0129(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL21_SSI_WS0129(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL21_SSI_SDATA0(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL21_SSI_SDATA1(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL21_SSI_SDATA2(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL21_SSI_SCK34(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL21_SSI_WS34(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL21_SSI_SDATA3(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL21_SSI_SCK4(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL22_SSI_WS4(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL22_SSI_SDATA4(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL22_SSI_SCK5(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL22_SSI_WS5(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL22_SSI_SDATA5(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL22_SSI_SCK6(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL22_SSI_WS6(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL22_SSI_SDATA6(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL23_SSI_SCK78(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL23_SSI_WS78(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL23_SSI_SDATA7(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL23_SSI_SDATA8(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL23_SSI_SDATA9(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL23_AUDIO_CLKA(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL23_AUDIO_CLKB(x)	((uint32_t)(x) << 4U)
+#define	DRVCTRL23_USB0_PWEN(x)	((uint32_t)(x) << 0U)
+#define	DRVCTRL24_USB0_OVC(x)	((uint32_t)(x) << 28U)
+#define	DRVCTRL24_USB1_PWEN(x)	((uint32_t)(x) << 24U)
+#define	DRVCTRL24_USB1_OVC(x)	((uint32_t)(x) << 20U)
+#define	DRVCTRL24_USB30_PWEN(x)	((uint32_t)(x) << 16U)
+#define	DRVCTRL24_USB30_OVC(x)	((uint32_t)(x) << 12U)
+#define	DRVCTRL24_USB31_PWEN(x)	((uint32_t)(x) << 8U)
+#define	DRVCTRL24_USB31_OVC(x)	((uint32_t)(x) << 4U)
+
+#define	MOD_SEL0_MSIOF3_A	((uint32_t)0U << 29U)
+#define	MOD_SEL0_MSIOF3_B	((uint32_t)1U << 29U)
+#define	MOD_SEL0_MSIOF3_C	((uint32_t)2U << 29U)
+#define	MOD_SEL0_MSIOF3_D	((uint32_t)3U << 29U)
+#define	MOD_SEL0_MSIOF3_E	((uint32_t)4U << 29U)
+#define	MOD_SEL0_MSIOF2_A	((uint32_t)0U << 27U)
+#define	MOD_SEL0_MSIOF2_B	((uint32_t)1U << 27U)
+#define	MOD_SEL0_MSIOF2_C	((uint32_t)2U << 27U)
+#define	MOD_SEL0_MSIOF2_D	((uint32_t)3U << 27U)
+#define	MOD_SEL0_MSIOF1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL0_MSIOF1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL0_MSIOF1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL0_MSIOF1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL0_MSIOF1_E	((uint32_t)4U << 24U)
+#define	MOD_SEL0_MSIOF1_F	((uint32_t)5U << 24U)
+#define	MOD_SEL0_MSIOF1_G	((uint32_t)6U << 24U)
+#define	MOD_SEL0_LBSC_A		((uint32_t)0U << 23U)
+#define	MOD_SEL0_LBSC_B		((uint32_t)1U << 23U)
+#define	MOD_SEL0_IEBUS_A	((uint32_t)0U << 22U)
+#define	MOD_SEL0_IEBUS_B	((uint32_t)1U << 22U)
+#define	MOD_SEL0_I2C2_A		((uint32_t)0U << 21U)
+#define	MOD_SEL0_I2C2_B		((uint32_t)1U << 21U)
+#define	MOD_SEL0_I2C1_A		((uint32_t)0U << 20U)
+#define	MOD_SEL0_I2C1_B		((uint32_t)1U << 20U)
+#define	MOD_SEL0_HSCIF4_A	((uint32_t)0U << 19U)
+#define	MOD_SEL0_HSCIF4_B	((uint32_t)1U << 19U)
+#define	MOD_SEL0_HSCIF3_A	((uint32_t)0U << 17U)
+#define	MOD_SEL0_HSCIF3_B	((uint32_t)1U << 17U)
+#define	MOD_SEL0_HSCIF3_C	((uint32_t)2U << 17U)
+#define	MOD_SEL0_HSCIF3_D	((uint32_t)3U << 17U)
+#define	MOD_SEL0_HSCIF1_A	((uint32_t)0U << 16U)
+#define	MOD_SEL0_HSCIF1_B	((uint32_t)1U << 16U)
+#define	MOD_SEL0_FSO_A		((uint32_t)0U << 15U)
+#define	MOD_SEL0_FSO_B		((uint32_t)1U << 15U)
+#define	MOD_SEL0_HSCIF2_A	((uint32_t)0U << 13U)
+#define	MOD_SEL0_HSCIF2_B	((uint32_t)1U << 13U)
+#define	MOD_SEL0_HSCIF2_C	((uint32_t)2U << 13U)
+#define	MOD_SEL0_ETHERAVB_A	((uint32_t)0U << 12U)
+#define	MOD_SEL0_ETHERAVB_B	((uint32_t)1U << 12U)
+#define	MOD_SEL0_DRIF3_A	((uint32_t)0U << 11U)
+#define	MOD_SEL0_DRIF3_B	((uint32_t)1U << 11U)
+#define	MOD_SEL0_DRIF2_A	((uint32_t)0U << 10U)
+#define	MOD_SEL0_DRIF2_B	((uint32_t)1U << 10U)
+#define	MOD_SEL0_DRIF1_A	((uint32_t)0U << 8U)
+#define	MOD_SEL0_DRIF1_B	((uint32_t)1U << 8U)
+#define	MOD_SEL0_DRIF1_C	((uint32_t)2U << 8U)
+#define	MOD_SEL0_DRIF0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL0_DRIF0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL0_DRIF0_C	((uint32_t)2U << 6U)
+#define	MOD_SEL0_CANFD0_A	((uint32_t)0U << 5U)
+#define	MOD_SEL0_CANFD0_B	((uint32_t)1U << 5U)
+#define	MOD_SEL0_ADG_A_A	((uint32_t)0U << 3U)
+#define	MOD_SEL0_ADG_A_B	((uint32_t)1U << 3U)
+#define	MOD_SEL0_ADG_A_C	((uint32_t)2U << 3U)
+#define	MOD_SEL1_TSIF1_A	((uint32_t)0U << 30U)
+#define	MOD_SEL1_TSIF1_B	((uint32_t)1U << 30U)
+#define	MOD_SEL1_TSIF1_C	((uint32_t)2U << 30U)
+#define	MOD_SEL1_TSIF1_D	((uint32_t)3U << 30U)
+#define	MOD_SEL1_TSIF0_A	((uint32_t)0U << 27U)
+#define	MOD_SEL1_TSIF0_B	((uint32_t)1U << 27U)
+#define	MOD_SEL1_TSIF0_C	((uint32_t)2U << 27U)
+#define	MOD_SEL1_TSIF0_D	((uint32_t)3U << 27U)
+#define	MOD_SEL1_TSIF0_E	((uint32_t)4U << 27U)
+#define	MOD_SEL1_TIMER_TMU_A	((uint32_t)0U << 26U)
+#define	MOD_SEL1_TIMER_TMU_B	((uint32_t)1U << 26U)
+#define	MOD_SEL1_SSP1_1_A	((uint32_t)0U << 24U)
+#define	MOD_SEL1_SSP1_1_B	((uint32_t)1U << 24U)
+#define	MOD_SEL1_SSP1_1_C	((uint32_t)2U << 24U)
+#define	MOD_SEL1_SSP1_1_D	((uint32_t)3U << 24U)
+#define	MOD_SEL1_SSP1_0_A	((uint32_t)0U << 21U)
+#define	MOD_SEL1_SSP1_0_B	((uint32_t)1U << 21U)
+#define	MOD_SEL1_SSP1_0_C	((uint32_t)2U << 21U)
+#define	MOD_SEL1_SSP1_0_D	((uint32_t)3U << 21U)
+#define	MOD_SEL1_SSP1_0_E	((uint32_t)4U << 21U)
+#define	MOD_SEL1_SSI_A		((uint32_t)0U << 20U)
+#define	MOD_SEL1_SSI_B		((uint32_t)1U << 20U)
+#define	MOD_SEL1_SPEED_PULSE_IF_A	((uint32_t)0U << 19U)
+#define	MOD_SEL1_SPEED_PULSE_IF_B	((uint32_t)1U << 19U)
+#define	MOD_SEL1_SIMCARD_A	((uint32_t)0U << 17U)
+#define	MOD_SEL1_SIMCARD_B	((uint32_t)1U << 17U)
+#define	MOD_SEL1_SIMCARD_C	((uint32_t)2U << 17U)
+#define	MOD_SEL1_SIMCARD_D	((uint32_t)3U << 17U)
+#define	MOD_SEL1_SDHI2_A	((uint32_t)0U << 16U)
+#define	MOD_SEL1_SDHI2_B	((uint32_t)1U << 16U)
+#define	MOD_SEL1_SCIF4_A	((uint32_t)0U << 14U)
+#define	MOD_SEL1_SCIF4_B	((uint32_t)1U << 14U)
+#define	MOD_SEL1_SCIF4_C	((uint32_t)2U << 14U)
+#define	MOD_SEL1_SCIF3_A	((uint32_t)0U << 13U)
+#define	MOD_SEL1_SCIF3_B	((uint32_t)1U << 13U)
+#define	MOD_SEL1_SCIF2_A	((uint32_t)0U << 12U)
+#define	MOD_SEL1_SCIF2_B	((uint32_t)1U << 12U)
+#define	MOD_SEL1_SCIF1_A	((uint32_t)0U << 11U)
+#define	MOD_SEL1_SCIF1_B	((uint32_t)1U << 11U)
+#define	MOD_SEL1_SCIF_A		((uint32_t)0U << 10U)
+#define	MOD_SEL1_SCIF_B		((uint32_t)1U << 10U)
+#define	MOD_SEL1_REMOCON_A	((uint32_t)0U << 9U)
+#define	MOD_SEL1_REMOCON_B	((uint32_t)1U << 9U)
+#define	MOD_SEL1_RCAN0_A	((uint32_t)0U << 6U)
+#define	MOD_SEL1_RCAN0_B	((uint32_t)1U << 6U)
+#define	MOD_SEL1_PWM6_A		((uint32_t)0U << 5U)
+#define	MOD_SEL1_PWM6_B		((uint32_t)1U << 5U)
+#define	MOD_SEL1_PWM5_A		((uint32_t)0U << 4U)
+#define	MOD_SEL1_PWM5_B		((uint32_t)1U << 4U)
+#define	MOD_SEL1_PWM4_A		((uint32_t)0U << 3U)
+#define	MOD_SEL1_PWM4_B		((uint32_t)1U << 3U)
+#define	MOD_SEL1_PWM3_A		((uint32_t)0U << 2U)
+#define	MOD_SEL1_PWM3_B		((uint32_t)1U << 2U)
+#define	MOD_SEL1_PWM2_A		((uint32_t)0U << 1U)
+#define	MOD_SEL1_PWM2_B		((uint32_t)1U << 1U)
+#define	MOD_SEL1_PWM1_A		((uint32_t)0U << 0U)
+#define	MOD_SEL1_PWM1_B		((uint32_t)1U << 0U)
+#define	MOD_SEL2_I2C_5_A	((uint32_t)0U << 31U)
+#define	MOD_SEL2_I2C_5_B	((uint32_t)1U << 31U)
+#define	MOD_SEL2_I2C_3_A	((uint32_t)0U << 30U)
+#define	MOD_SEL2_I2C_3_B	((uint32_t)1U << 30U)
+#define	MOD_SEL2_I2C_0_A	((uint32_t)0U << 29U)
+#define	MOD_SEL2_I2C_0_B	((uint32_t)1U << 29U)
+#define	MOD_SEL2_FM_A		((uint32_t)0U << 27U)
+#define	MOD_SEL2_FM_B		((uint32_t)1U << 27U)
+#define	MOD_SEL2_FM_C		((uint32_t)2U << 27U)
+#define	MOD_SEL2_FM_D		((uint32_t)3U << 27U)
+#define	MOD_SEL2_SCIF5_A	((uint32_t)0U << 26U)
+#define	MOD_SEL2_SCIF5_B	((uint32_t)1U << 26U)
+#define	MOD_SEL2_I2C6_A		((uint32_t)0U << 23U)
+#define	MOD_SEL2_I2C6_B		((uint32_t)1U << 23U)
+#define	MOD_SEL2_I2C6_C		((uint32_t)2U << 23U)
+#define	MOD_SEL2_NDF_A		((uint32_t)0U << 22U)
+#define	MOD_SEL2_NDF_B		((uint32_t)1U << 22U)
+#define	MOD_SEL2_SSI2_A		((uint32_t)0U << 21U)
+#define	MOD_SEL2_SSI2_B		((uint32_t)1U << 21U)
+#define	MOD_SEL2_SSI9_A		((uint32_t)0U << 20U)
+#define	MOD_SEL2_SSI9_B		((uint32_t)1U << 20U)
+#define	MOD_SEL2_TIMER_TMU2_A	((uint32_t)0U << 19U)
+#define	MOD_SEL2_TIMER_TMU2_B	((uint32_t)1U << 19U)
+#define	MOD_SEL2_ADG_B_A	((uint32_t)0U << 18U)
+#define	MOD_SEL2_ADG_B_B	((uint32_t)1U << 18U)
+#define	MOD_SEL2_ADG_C_A	((uint32_t)0U << 17U)
+#define	MOD_SEL2_ADG_C_B	((uint32_t)1U << 17U)
+#define	MOD_SEL2_VIN4_A		((uint32_t)0U << 0U)
+#define	MOD_SEL2_VIN4_B		((uint32_t)1U << 0U)
+
+
+/* SCIF3 Registers for Dummy write */
+#define SCIF3_BASE		(0xE6C50000U)
+#define SCIF3_SCFCR		(SCIF3_BASE + 0x0018U)
+#define SCIF3_SCFDR		(SCIF3_BASE + 0x001CU)
+#define SCFCR_DATA		(0x0000U)
+
+/* Realtime module stop control */
+#define	CPG_BASE		(0xE6150000U)
+#define CPG_MSTPSR0		(CPG_BASE + 0x0030U)
+#define CPG_RMSTPCR0		(CPG_BASE + 0x0110U)
+#define RMSTPCR0_RTDMAC		(0x00200000U)
+
+/* RT-DMAC Registers */
+#define RTDMAC_CH		(0U)		/* choose 0 to 15 */
+
+#define RTDMAC_BASE		(0xFFC10000U)
+#define RTDMAC_RDMOR		(RTDMAC_BASE + 0x0060U)
+#define RTDMAC_RDMCHCLR		(RTDMAC_BASE + 0x0080U)
+#define RTDMAC_RDMSAR(x)	(RTDMAC_BASE + 0x8000U + (0x80U * (x)))
+#define RTDMAC_RDMDAR(x)	(RTDMAC_BASE + 0x8004U + (0x80U * (x)))
+#define RTDMAC_RDMTCR(x)	(RTDMAC_BASE + 0x8008U + (0x80U * (x)))
+#define RTDMAC_RDMCHCR(x)	(RTDMAC_BASE + 0x800CU + (0x80U * (x)))
+#define RTDMAC_RDMCHCRB(x)	(RTDMAC_BASE + 0x801CU + (0x80U * (x)))
+#define RTDMAC_RDMDPBASE(x)	(RTDMAC_BASE + 0x8050U + (0x80U * (x)))
+#define RTDMAC_DESC_BASE	(RTDMAC_BASE + 0xA000U)
+#define RTDMAC_DESC_RDMSAR	(RTDMAC_DESC_BASE + 0x0000U)
+#define RTDMAC_DESC_RDMDAR	(RTDMAC_DESC_BASE + 0x0004U)
+#define RTDMAC_DESC_RDMTCR	(RTDMAC_DESC_BASE + 0x0008U)
+
+#define RDMOR_DME		(0x0001U)
+#define RDMCHCR_DPM_INFINITE	(0x30000000U)
+#define RDMCHCR_RPT_TCR		(0x02000000U)
+#define RDMCHCR_TS_2		(0x00000010U)
+#define RDMCHCR_RS_AUTO		(0x00000400U)
+#define RDMCHCR_DE		(0x00000001U)
+#define RDMCHCRB_DRST		(0x00008000U)
+#define RDMDPBASE_SEL_EXT	(0x00000001U)
+
+
+static void StartRtDma0_Descriptor(void);
+static void pfc_reg_write(uint32_t addr, uint32_t data);
+
+
+static void StartRtDma0_Descriptor(void)
+{
+	uint32_t reg;
+
+	reg = mmio_read_32(RCAR_PRR);
+	reg &= (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+	if (reg == (RCAR_PRODUCT_M3_CUT10)) {
+		/* Module stop clear */
+		while((mmio_read_32(CPG_MSTPSR0) & RMSTPCR0_RTDMAC) != 0U) {
+			reg = mmio_read_32(CPG_RMSTPCR0);
+			reg &= ~RMSTPCR0_RTDMAC;
+			cpg_write(CPG_RMSTPCR0, reg);
+		}
+
+		/* Initialize ch0, Reset Descriptor */
+		mmio_write_32(RTDMAC_RDMCHCLR, ((uint32_t)1U << RTDMAC_CH));
+		mmio_write_32(RTDMAC_RDMCHCRB(RTDMAC_CH), RDMCHCRB_DRST);
+
+		/* Enable DMA */
+		mmio_write_16(RTDMAC_RDMOR, RDMOR_DME);
+
+		/* Set first transfer */
+		mmio_write_32(RTDMAC_RDMSAR(RTDMAC_CH), RCAR_PRR);
+		mmio_write_32(RTDMAC_RDMDAR(RTDMAC_CH), SCIF3_SCFDR);
+		mmio_write_32(RTDMAC_RDMTCR(RTDMAC_CH), 0x00000001U);
+
+		/* Set descriptor */
+		mmio_write_32(RTDMAC_DESC_RDMSAR, 0x00000000U);
+		mmio_write_32(RTDMAC_DESC_RDMDAR, 0x00000000U);
+		mmio_write_32(RTDMAC_DESC_RDMTCR, 0x00200000U);
+		mmio_write_32(RTDMAC_RDMCHCRB(RTDMAC_CH),  RDMCHCRB_DRST);
+		mmio_write_32(RTDMAC_RDMDPBASE(RTDMAC_CH), RDMDPBASE_SEL_EXT);
+
+		/* Set transfer parameter, Start transfer */
+		mmio_write_32(RTDMAC_RDMCHCR(RTDMAC_CH), RDMCHCR_DPM_INFINITE
+						       | RDMCHCR_RPT_TCR
+						       | RDMCHCR_TS_2
+						       | RDMCHCR_RS_AUTO
+						       | RDMCHCR_DE);
+	}
+}
+
+static void pfc_reg_write(uint32_t addr, uint32_t data)
+{
+	uint32_t prr;
+
+	prr = mmio_read_32(RCAR_PRR);
+	prr &= (RCAR_PRODUCT_MASK | RCAR_CUT_MASK);
+
+	mmio_write_32(PFC_PMMR, ~data);
+	if (prr == (RCAR_PRODUCT_M3_CUT10)) {
+		mmio_write_16(SCIF3_SCFCR, SCFCR_DATA);	/* Dummy write */
+	}
+	mmio_write_32((uintptr_t)addr, data);
+	if (prr == (RCAR_PRODUCT_M3_CUT10)) {
+		mmio_write_16(SCIF3_SCFCR, SCFCR_DATA);	/* Dummy write */
+	}
+}
+
+
+void pfc_init_m3(void)
+{
+	uint32_t reg;
+
+	/* Work around for PFC eratta */
+	StartRtDma0_Descriptor();
+
+	/* initialize module select */
+	pfc_reg_write(PFC_MOD_SEL0, MOD_SEL0_MSIOF3_A
+				  | MOD_SEL0_MSIOF2_A
+				  | MOD_SEL0_MSIOF1_A
+				  | MOD_SEL0_LBSC_A
+				  | MOD_SEL0_IEBUS_A
+				  | MOD_SEL0_I2C2_A
+				  | MOD_SEL0_I2C1_A
+				  | MOD_SEL0_HSCIF4_A
+				  | MOD_SEL0_HSCIF3_A
+				  | MOD_SEL0_HSCIF1_A
+				  | MOD_SEL0_FSO_A
+				  | MOD_SEL0_HSCIF2_A
+				  | MOD_SEL0_ETHERAVB_A
+				  | MOD_SEL0_DRIF3_A
+				  | MOD_SEL0_DRIF2_A
+				  | MOD_SEL0_DRIF1_A
+				  | MOD_SEL0_DRIF0_A
+				  | MOD_SEL0_CANFD0_A
+				  | MOD_SEL0_ADG_A_A);
+	pfc_reg_write(PFC_MOD_SEL1, MOD_SEL1_TSIF1_A
+				  | MOD_SEL1_TSIF0_A
+				  | MOD_SEL1_TIMER_TMU_A
+				  | MOD_SEL1_SSP1_1_A
+				  | MOD_SEL1_SSP1_0_A
+				  | MOD_SEL1_SSI_A
+				  | MOD_SEL1_SPEED_PULSE_IF_A
+				  | MOD_SEL1_SIMCARD_A
+				  | MOD_SEL1_SDHI2_A
+				  | MOD_SEL1_SCIF4_A
+				  | MOD_SEL1_SCIF3_A
+				  | MOD_SEL1_SCIF2_A
+				  | MOD_SEL1_SCIF1_A
+				  | MOD_SEL1_SCIF_A
+				  | MOD_SEL1_REMOCON_A
+				  | MOD_SEL1_RCAN0_A
+				  | MOD_SEL1_PWM6_A
+				  | MOD_SEL1_PWM5_A
+				  | MOD_SEL1_PWM4_A
+				  | MOD_SEL1_PWM3_A
+				  | MOD_SEL1_PWM2_A
+				  | MOD_SEL1_PWM1_A);
+	pfc_reg_write(PFC_MOD_SEL2, MOD_SEL2_I2C_5_A
+				  | MOD_SEL2_I2C_3_A
+				  | MOD_SEL2_I2C_0_A
+				  | MOD_SEL2_FM_A
+				  | MOD_SEL2_SCIF5_A
+				  | MOD_SEL2_I2C6_A
+				  | MOD_SEL2_NDF_A
+				  | MOD_SEL2_SSI2_A
+				  | MOD_SEL2_SSI9_A
+				  | MOD_SEL2_TIMER_TMU2_A
+				  | MOD_SEL2_ADG_B_A
+				  | MOD_SEL2_ADG_C_A
+				  | MOD_SEL2_VIN4_A);
+
+	/* initialize peripheral function select */
+	pfc_reg_write(PFC_IPSR0, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR1, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(3)
+			       | IPSR_8_FUNC(3)
+			       | IPSR_4_FUNC(3)
+			       | IPSR_0_FUNC(3));
+	pfc_reg_write(PFC_IPSR2, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR3, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR4, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR5, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR6, IPSR_28_FUNC(6)
+			       | IPSR_24_FUNC(6)
+			       | IPSR_20_FUNC(6)
+			       | IPSR_16_FUNC(6)
+			       | IPSR_12_FUNC(6)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR7, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(6)
+			       | IPSR_4_FUNC(6)
+			       | IPSR_0_FUNC(6));
+	pfc_reg_write(PFC_IPSR8, IPSR_28_FUNC(1)
+			       | IPSR_24_FUNC(1)
+			       | IPSR_20_FUNC(1)
+			       | IPSR_16_FUNC(1)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR9, IPSR_28_FUNC(0)
+			       | IPSR_24_FUNC(0)
+			       | IPSR_20_FUNC(0)
+			       | IPSR_16_FUNC(0)
+			       | IPSR_12_FUNC(0)
+			       | IPSR_8_FUNC(0)
+			       | IPSR_4_FUNC(0)
+			       | IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR10, IPSR_28_FUNC(1)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR11, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(4)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(1));
+	pfc_reg_write(PFC_IPSR12, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(4)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR13, IPSR_28_FUNC(8)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(3)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR14, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(3)
+				| IPSR_0_FUNC(8));
+	pfc_reg_write(PFC_IPSR15, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR16, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR17, IPSR_28_FUNC(0)
+				| IPSR_24_FUNC(0)
+				| IPSR_20_FUNC(0)
+				| IPSR_16_FUNC(0)
+				| IPSR_12_FUNC(0)
+				| IPSR_8_FUNC(0)
+				| IPSR_4_FUNC(1)
+				| IPSR_0_FUNC(0));
+	pfc_reg_write(PFC_IPSR18, IPSR_4_FUNC(0)
+				| IPSR_0_FUNC(0));
+
+	/* initialize GPIO/perihperal function select */
+	pfc_reg_write(PFC_GPSR0, GPSR0_D15
+			       | GPSR0_D14
+			       | GPSR0_D13
+			       | GPSR0_D12
+			       | GPSR0_D11
+			       | GPSR0_D10
+			       | GPSR0_D9
+			       | GPSR0_D8);
+	pfc_reg_write(PFC_GPSR1, GPSR1_CLKOUT
+			       | GPSR1_EX_WAIT0_A
+			       | GPSR1_A19
+			       | GPSR1_A18
+			       | GPSR1_A17
+			       | GPSR1_A16
+			       | GPSR1_A15
+			       | GPSR1_A14
+			       | GPSR1_A13
+			       | GPSR1_A12
+			       | GPSR1_A7
+			       | GPSR1_A6
+			       | GPSR1_A5
+			       | GPSR1_A4
+			       | GPSR1_A3
+			       | GPSR1_A2
+			       | GPSR1_A1
+			       | GPSR1_A0);
+	pfc_reg_write(PFC_GPSR2, GPSR2_AVB_AVTP_CAPTURE_A
+			       | GPSR2_AVB_AVTP_MATCH_A
+			       | GPSR2_AVB_LINK
+			       | GPSR2_AVB_PHY_INT
+			       | GPSR2_AVB_MDC
+			       | GPSR2_PWM2_A
+			       | GPSR2_PWM1_A
+			       | GPSR2_IRQ5
+			       | GPSR2_IRQ4
+			       | GPSR2_IRQ3
+			       | GPSR2_IRQ2
+			       | GPSR2_IRQ1
+			       | GPSR2_IRQ0);
+	pfc_reg_write(PFC_GPSR3, GPSR3_SD0_WP
+			       | GPSR3_SD0_CD
+			       | GPSR3_SD1_DAT3
+			       | GPSR3_SD1_DAT2
+			       | GPSR3_SD1_DAT1
+			       | GPSR3_SD1_DAT0
+			       | GPSR3_SD0_DAT3
+			       | GPSR3_SD0_DAT2
+			       | GPSR3_SD0_DAT1
+			       | GPSR3_SD0_DAT0
+			       | GPSR3_SD0_CMD
+			       | GPSR3_SD0_CLK);
+	pfc_reg_write(PFC_GPSR4, GPSR4_SD3_DAT7
+			       | GPSR4_SD3_DAT6
+			       | GPSR4_SD3_DAT3
+			       | GPSR4_SD3_DAT2
+			       | GPSR4_SD3_DAT1
+			       | GPSR4_SD3_DAT0
+			       | GPSR4_SD3_CMD
+			       | GPSR4_SD3_CLK
+			       | GPSR4_SD2_DS
+			       | GPSR4_SD2_DAT3
+			       | GPSR4_SD2_DAT2
+			       | GPSR4_SD2_DAT1
+			       | GPSR4_SD2_DAT0
+			       | GPSR4_SD2_CMD
+			       | GPSR4_SD2_CLK);
+	pfc_reg_write(PFC_GPSR5, GPSR5_MSIOF0_SS2
+			       | GPSR5_MSIOF0_SS1
+			       | GPSR5_MSIOF0_SYNC
+			       | GPSR5_HRTS0
+			       | GPSR5_HCTS0
+			       | GPSR5_HTX0
+			       | GPSR5_HRX0
+			       | GPSR5_HSCK0
+			       | GPSR5_RX2_A
+			       | GPSR5_TX2_A
+			       | GPSR5_SCK2
+			       | GPSR5_RTS1_TANS
+			       | GPSR5_CTS1
+			       | GPSR5_TX1_A
+			       | GPSR5_RX1_A
+			       | GPSR5_RTS0_TANS
+			       | GPSR5_SCK0);
+	pfc_reg_write(PFC_GPSR6, GPSR6_USB30_OVC
+			       | GPSR6_USB30_PWEN
+			       | GPSR6_USB1_OVC
+			       | GPSR6_USB1_PWEN
+			       | GPSR6_USB0_OVC
+			       | GPSR6_USB0_PWEN
+			       | GPSR6_AUDIO_CLKB_B
+			       | GPSR6_AUDIO_CLKA_A
+			       | GPSR6_SSI_SDATA8
+			       | GPSR6_SSI_SDATA7
+			       | GPSR6_SSI_WS78
+			       | GPSR6_SSI_SCK78
+			       | GPSR6_SSI_WS6
+			       | GPSR6_SSI_SCK6
+			       | GPSR6_SSI_SDATA4
+			       | GPSR6_SSI_WS4
+			       | GPSR6_SSI_SCK4
+			       | GPSR6_SSI_SDATA1_A
+			       | GPSR6_SSI_SDATA0
+			       | GPSR6_SSI_WS0129
+			       | GPSR6_SSI_SCK0129);
+	pfc_reg_write(PFC_GPSR7, GPSR7_HDMI1_CEC
+			       | GPSR7_HDMI0_CEC
+			       | GPSR7_AVS2
+			       | GPSR7_AVS1);
+
+	/* initialize POC control register */
+	pfc_reg_write(PFC_POCCTRL0, POC_SD3_DS_33V
+				  | POC_SD3_DAT7_33V
+				  | POC_SD3_DAT6_33V
+				  | POC_SD3_DAT5_33V
+				  | POC_SD3_DAT4_33V
+				  | POC_SD3_DAT3_33V
+				  | POC_SD3_DAT2_33V
+				  | POC_SD3_DAT1_33V
+				  | POC_SD3_DAT0_33V
+				  | POC_SD3_CMD_33V
+				  | POC_SD3_CLK_33V
+				  | POC_SD0_DAT3_33V
+				  | POC_SD0_DAT2_33V
+				  | POC_SD0_DAT1_33V
+				  | POC_SD0_DAT0_33V
+				  | POC_SD0_CMD_33V
+				  | POC_SD0_CLK_33V);
+
+	/* initialize DRV control register */
+	reg = mmio_read_32(PFC_DRVCTRL0);
+	reg = ((reg & DRVCTRL0_MASK) | DRVCTRL0_QSPI0_SPCLK(3)
+				  | DRVCTRL0_QSPI0_MOSI_IO0(3)
+				  | DRVCTRL0_QSPI0_MISO_IO1(3)
+				  | DRVCTRL0_QSPI0_IO2(3)
+				  | DRVCTRL0_QSPI0_IO3(3)
+				  | DRVCTRL0_QSPI0_SSL(3)
+				  | DRVCTRL0_QSPI1_SPCLK(3)
+				  | DRVCTRL0_QSPI1_MOSI_IO0(3));
+	pfc_reg_write(PFC_DRVCTRL0, reg);
+	reg = mmio_read_32(PFC_DRVCTRL1);
+	reg = ((reg & DRVCTRL1_MASK) | DRVCTRL1_QSPI1_MISO_IO1(3)
+				     | DRVCTRL1_QSPI1_IO2(3)
+				     | DRVCTRL1_QSPI1_IO3(3)
+				     | DRVCTRL1_QSPI1_SS(3)
+				     | DRVCTRL1_RPC_INT(3)
+				     | DRVCTRL1_RPC_WP(3)
+				     | DRVCTRL1_RPC_RESET(3)
+				     | DRVCTRL1_AVB_RX_CTL(7));
+	pfc_reg_write(PFC_DRVCTRL1, reg);
+	reg = mmio_read_32(PFC_DRVCTRL2);
+	reg = ((reg & DRVCTRL2_MASK) | DRVCTRL2_AVB_RXC(7)
+				     | DRVCTRL2_AVB_RD0(7)
+				     | DRVCTRL2_AVB_RD1(7)
+				     | DRVCTRL2_AVB_RD2(7)
+				     | DRVCTRL2_AVB_RD3(7)
+				     | DRVCTRL2_AVB_TX_CTL(7)
+				     | DRVCTRL2_AVB_TXC(7)
+				     | DRVCTRL2_AVB_TD0(7));
+	pfc_reg_write(PFC_DRVCTRL2, reg);
+	reg = mmio_read_32(PFC_DRVCTRL3);
+	reg = ((reg & DRVCTRL3_MASK) | DRVCTRL3_AVB_TD1(7)
+				     | DRVCTRL3_AVB_TD2(7)
+				     | DRVCTRL3_AVB_TD3(7)
+				     | DRVCTRL3_AVB_TXCREFCLK(7)
+				     | DRVCTRL3_AVB_MDIO(7)
+				     | DRVCTRL3_AVB_MDC(7)
+				     | DRVCTRL3_AVB_MAGIC(7)
+				     | DRVCTRL3_AVB_PHY_INT(7));
+	pfc_reg_write(PFC_DRVCTRL3, reg);
+	reg = mmio_read_32(PFC_DRVCTRL4);
+	reg = ((reg & DRVCTRL4_MASK) | DRVCTRL4_AVB_LINK(7)
+				     | DRVCTRL4_AVB_AVTP_MATCH(7)
+				     | DRVCTRL4_AVB_AVTP_CAPTURE(7)
+				     | DRVCTRL4_IRQ0(7)
+				     | DRVCTRL4_IRQ1(7)
+				     | DRVCTRL4_IRQ2(7)
+				     | DRVCTRL4_IRQ3(7)
+				     | DRVCTRL4_IRQ4(7));
+	pfc_reg_write(PFC_DRVCTRL4, reg);
+	reg = mmio_read_32(PFC_DRVCTRL5);
+	reg = ((reg & DRVCTRL5_MASK) | DRVCTRL5_IRQ5(7)
+				     | DRVCTRL5_PWM0(7)
+				     | DRVCTRL5_PWM1(7)
+				     | DRVCTRL5_PWM2(7)
+				     | DRVCTRL5_A0(7)
+				     | DRVCTRL5_A1(7)
+				     | DRVCTRL5_A2(7)
+				     | DRVCTRL5_A3(7));
+	pfc_reg_write(PFC_DRVCTRL5, reg);
+	reg = mmio_read_32(PFC_DRVCTRL6);
+	reg = ((reg & DRVCTRL6_MASK) | DRVCTRL6_A4(7)
+				     | DRVCTRL6_A5(7)
+				     | DRVCTRL6_A6(7)
+				     | DRVCTRL6_A7(7)
+				     | DRVCTRL6_A8(7)
+				     | DRVCTRL6_A9(7)
+				     | DRVCTRL6_A10(7)
+				     | DRVCTRL6_A11(7));
+	pfc_reg_write(PFC_DRVCTRL6, reg);
+	reg = mmio_read_32(PFC_DRVCTRL7);
+	reg = ((reg & DRVCTRL7_MASK) | DRVCTRL7_A12(7)
+				     | DRVCTRL7_A13(7)
+				     | DRVCTRL7_A14(7)
+				     | DRVCTRL7_A15(7)
+				     | DRVCTRL7_A16(7)
+				     | DRVCTRL7_A17(7)
+				     | DRVCTRL7_A18(7)
+				     | DRVCTRL7_A19(7));
+	pfc_reg_write(PFC_DRVCTRL7, reg);
+	reg = mmio_read_32(PFC_DRVCTRL8);
+	reg = ((reg & DRVCTRL8_MASK) | DRVCTRL8_CLKOUT(7)
+				     | DRVCTRL8_CS0(7)
+				     | DRVCTRL8_CS1_A2(7)
+				     | DRVCTRL8_BS(7)
+				     | DRVCTRL8_RD(7)
+				     | DRVCTRL8_RD_W(7)
+				     | DRVCTRL8_WE0(7)
+				     | DRVCTRL8_WE1(7));
+	pfc_reg_write(PFC_DRVCTRL8, reg);
+	reg = mmio_read_32(PFC_DRVCTRL9);
+	reg = ((reg & DRVCTRL9_MASK) | DRVCTRL9_EX_WAIT0(7)
+				     | DRVCTRL9_PRESETOU(7)
+				     | DRVCTRL9_D0(7)
+				     | DRVCTRL9_D1(7)
+				     | DRVCTRL9_D2(7)
+				     | DRVCTRL9_D3(7)
+				     | DRVCTRL9_D4(7)
+				     | DRVCTRL9_D5(7));
+	pfc_reg_write(PFC_DRVCTRL9, reg);
+	reg = mmio_read_32(PFC_DRVCTRL10);
+	reg = ((reg & DRVCTRL10_MASK) | DRVCTRL10_D6(7)
+				      | DRVCTRL10_D7(7)
+				      | DRVCTRL10_D8(7)
+				      | DRVCTRL10_D9(7)
+				      | DRVCTRL10_D10(7)
+				      | DRVCTRL10_D11(7)
+				      | DRVCTRL10_D12(7)
+				      | DRVCTRL10_D13(7));
+	pfc_reg_write(PFC_DRVCTRL10, reg);
+	reg = mmio_read_32(PFC_DRVCTRL11);
+	reg = ((reg & DRVCTRL11_MASK) | DRVCTRL11_D14(7)
+				      | DRVCTRL11_D15(7)
+				      | DRVCTRL11_AVS1(7)
+				      | DRVCTRL11_AVS2(7)
+				      | DRVCTRL11_HDMI0_CEC(7)
+				      | DRVCTRL11_HDMI1_CEC(7)
+				      | DRVCTRL11_DU_DOTCLKIN0(3)
+				      | DRVCTRL11_DU_DOTCLKIN1(3));
+	pfc_reg_write(PFC_DRVCTRL11, reg);
+	reg = mmio_read_32(PFC_DRVCTRL12);
+	reg = ((reg & DRVCTRL12_MASK) | DRVCTRL12_DU_DOTCLKIN2(3)
+				      | DRVCTRL12_DU_DOTCLKIN3(3)
+				         | DRVCTRL12_DU_FSCLKST(3)
+				      | DRVCTRL12_DU_TMS(3));
+	pfc_reg_write(PFC_DRVCTRL12, reg);
+	reg = mmio_read_32(PFC_DRVCTRL13);
+	reg = ((reg & DRVCTRL13_MASK) | DRVCTRL13_TDO(3)
+				      | DRVCTRL13_ASEBRK(3)
+				      | DRVCTRL13_SD0_CLK(7)
+				      | DRVCTRL13_SD0_CMD(7)
+				      | DRVCTRL13_SD0_DAT0(7)
+				      | DRVCTRL13_SD0_DAT1(7)
+				      | DRVCTRL13_SD0_DAT2(7)
+				      | DRVCTRL13_SD0_DAT3(7));
+	pfc_reg_write(PFC_DRVCTRL13, reg);
+	reg = mmio_read_32(PFC_DRVCTRL14);
+	reg = ((reg & DRVCTRL14_MASK) | DRVCTRL14_SD1_CLK(7)
+				      | DRVCTRL14_SD1_CMD(7)
+				      | DRVCTRL14_SD1_DAT0(7)
+				      | DRVCTRL14_SD1_DAT1(7)
+				      | DRVCTRL14_SD1_DAT2(7)
+				      | DRVCTRL14_SD1_DAT3(7)
+				      | DRVCTRL14_SD2_CLK(7)
+				      | DRVCTRL14_SD2_CMD(7));
+	pfc_reg_write(PFC_DRVCTRL14, reg);
+	reg = mmio_read_32(PFC_DRVCTRL15);
+	reg = ((reg & DRVCTRL15_MASK) | DRVCTRL15_SD2_DAT0(7)
+				      | DRVCTRL15_SD2_DAT1(7)
+				      | DRVCTRL15_SD2_DAT2(7)
+				      | DRVCTRL15_SD2_DAT3(7)
+				      | DRVCTRL15_SD2_DS(7)
+				      | DRVCTRL15_SD3_CLK(7)
+				      | DRVCTRL15_SD3_CMD(7)
+				      | DRVCTRL15_SD3_DAT0(7));
+	pfc_reg_write(PFC_DRVCTRL15, reg);
+	reg = mmio_read_32(PFC_DRVCTRL16);
+	reg = ((reg & DRVCTRL16_MASK) | DRVCTRL16_SD3_DAT1(7)
+				      | DRVCTRL16_SD3_DAT2(7)
+				      | DRVCTRL16_SD3_DAT3(7)
+				      | DRVCTRL16_SD3_DAT4(7)
+				      | DRVCTRL16_SD3_DAT5(7)
+				      | DRVCTRL16_SD3_DAT6(7)
+				      | DRVCTRL16_SD3_DAT7(7)
+				      | DRVCTRL16_SD3_DS(7));
+	pfc_reg_write(PFC_DRVCTRL16, reg);
+	reg = mmio_read_32(PFC_DRVCTRL17);
+	reg = ((reg & DRVCTRL17_MASK) | DRVCTRL17_SD0_CD(7)
+				      | DRVCTRL17_SD0_WP(7)
+				      | DRVCTRL17_SD1_CD(7)
+				      | DRVCTRL17_SD1_WP(7)
+				      | DRVCTRL17_SCK0(7)
+				      | DRVCTRL17_RX0(7)
+				      | DRVCTRL17_TX0(7)
+				      | DRVCTRL17_CTS0(7));
+	pfc_reg_write(PFC_DRVCTRL17, reg);
+	reg = mmio_read_32(PFC_DRVCTRL18);
+	reg = ((reg & DRVCTRL18_MASK) | DRVCTRL18_RTS0_TANS(7)
+				      | DRVCTRL18_RX1(7)
+				      | DRVCTRL18_TX1(7)
+				      | DRVCTRL18_CTS1(7)
+				      | DRVCTRL18_RTS1_TANS(7)
+				      | DRVCTRL18_SCK2(7)
+				      | DRVCTRL18_TX2(7)
+				      | DRVCTRL18_RX2(7));
+	pfc_reg_write(PFC_DRVCTRL18, reg);
+	reg = mmio_read_32(PFC_DRVCTRL19);
+	reg = ((reg & DRVCTRL19_MASK) | DRVCTRL19_HSCK0(7)
+				      | DRVCTRL19_HRX0(7)
+				      | DRVCTRL19_HTX0(7)
+				      | DRVCTRL19_HCTS0(7)
+				      | DRVCTRL19_HRTS0(7)
+				      | DRVCTRL19_MSIOF0_SCK(7)
+				      | DRVCTRL19_MSIOF0_SYNC(7)
+				      | DRVCTRL19_MSIOF0_SS1(7));
+	pfc_reg_write(PFC_DRVCTRL19, reg);
+	reg = mmio_read_32(PFC_DRVCTRL20);
+	reg = ((reg & DRVCTRL20_MASK) | DRVCTRL20_MSIOF0_TXD(7)
+				      | DRVCTRL20_MSIOF0_SS2(7)
+				      | DRVCTRL20_MSIOF0_RXD(7)
+				      | DRVCTRL20_MLB_CLK(7)
+				      | DRVCTRL20_MLB_SIG(7)
+				      | DRVCTRL20_MLB_DAT(7)
+				      | DRVCTRL20_MLB_REF(7)
+				      | DRVCTRL20_SSI_SCK0129(7));
+	pfc_reg_write(PFC_DRVCTRL20, reg);
+	reg = mmio_read_32(PFC_DRVCTRL21);
+	reg = ((reg & DRVCTRL21_MASK) | DRVCTRL21_SSI_WS0129(7)
+				      | DRVCTRL21_SSI_SDATA0(7)
+				      | DRVCTRL21_SSI_SDATA1(7)
+				      | DRVCTRL21_SSI_SDATA2(7)
+				      | DRVCTRL21_SSI_SCK34(7)
+				      | DRVCTRL21_SSI_WS34(7)
+				      | DRVCTRL21_SSI_SDATA3(7)
+				      | DRVCTRL21_SSI_SCK4(7));
+	pfc_reg_write(PFC_DRVCTRL21, reg);
+	reg = mmio_read_32(PFC_DRVCTRL22);
+	reg = ((reg & DRVCTRL22_MASK) | DRVCTRL22_SSI_WS4(7)
+				      | DRVCTRL22_SSI_SDATA4(7)
+				      | DRVCTRL22_SSI_SCK5(7)
+				      | DRVCTRL22_SSI_WS5(7)
+				      | DRVCTRL22_SSI_SDATA5(7)
+				      | DRVCTRL22_SSI_SCK6(7)
+				      | DRVCTRL22_SSI_WS6(7)
+				      | DRVCTRL22_SSI_SDATA6(7));
+	pfc_reg_write(PFC_DRVCTRL22, reg);
+	reg = mmio_read_32(PFC_DRVCTRL23);
+	reg = ((reg & DRVCTRL23_MASK) | DRVCTRL23_SSI_SCK78(7)
+				      | DRVCTRL23_SSI_WS78(7)
+				      | DRVCTRL23_SSI_SDATA7(7)
+				      | DRVCTRL23_SSI_SDATA8(7)
+				      | DRVCTRL23_SSI_SDATA9(7)
+				      | DRVCTRL23_AUDIO_CLKA(7)
+				      | DRVCTRL23_AUDIO_CLKB(7)
+				      | DRVCTRL23_USB0_PWEN(7));
+	pfc_reg_write(PFC_DRVCTRL23, reg);
+	reg = mmio_read_32(PFC_DRVCTRL24);
+	reg = ((reg & DRVCTRL24_MASK) | DRVCTRL24_USB0_OVC(7)
+				      | DRVCTRL24_USB1_PWEN(7)
+				      | DRVCTRL24_USB1_OVC(7)
+				      | DRVCTRL24_USB30_PWEN(7)
+				      | DRVCTRL24_USB30_OVC(7)
+				      | DRVCTRL24_USB31_PWEN(7)
+				      | DRVCTRL24_USB31_OVC(7));
+	pfc_reg_write(PFC_DRVCTRL24, reg);
+
+	/* initialize LSI pin pull-up/down control */
+	pfc_reg_write(PFC_PUD0,0x00005FBFU);
+	pfc_reg_write(PFC_PUD1,0x00300FFEU);
+	pfc_reg_write(PFC_PUD2,0x330001E6U);
+	pfc_reg_write(PFC_PUD3,0x000002E0U);
+	pfc_reg_write(PFC_PUD4,0xFFFFFF00U);
+	pfc_reg_write(PFC_PUD5,0x7F5FFF87U);
+	pfc_reg_write(PFC_PUD6,0x00000055U);
+
+	/* initialize LSI pin pull-enable register */
+	pfc_reg_write(PFC_PUEN0,0x00000FFFU);
+	pfc_reg_write(PFC_PUEN1,0x00100234U);
+	pfc_reg_write(PFC_PUEN2,0x000004C4U);
+	pfc_reg_write(PFC_PUEN3,0x00000200U);
+	pfc_reg_write(PFC_PUEN4,0x3E000000U);
+	pfc_reg_write(PFC_PUEN5,0x1F000805U);
+	pfc_reg_write(PFC_PUEN6,0x00000006U);
+
+	/* initialize positive/negative logic select */
+	mmio_write_32(GPIO_POSNEG0, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG1, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG2, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG3, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG4, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG5, 0x00000000U);
+	mmio_write_32(GPIO_POSNEG6, 0x00000000U);
+
+	/* initialize general IO/interrupt switching */
+	mmio_write_32(GPIO_IOINTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL1, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL2, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL3, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL5, 0x00000000U);
+	mmio_write_32(GPIO_IOINTSEL6, 0x00000000U);
+
+	/* initialize general output register */
+	mmio_write_32(GPIO_OUTDT1, 0x00000000U);
+	mmio_write_32(GPIO_OUTDT2, 0x00000400U);
+	mmio_write_32(GPIO_OUTDT3, 0x0000C000U);
+	mmio_write_32(GPIO_OUTDT5, 0x00000006U);
+	mmio_write_32(GPIO_OUTDT6, 0x00003880U);
+
+	/* initialize general input/output switching */
+	mmio_write_32(GPIO_INOUTSEL0, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL1, 0x01000A00U);
+	mmio_write_32(GPIO_INOUTSEL2, 0x00000400U);
+	mmio_write_32(GPIO_INOUTSEL3, 0x0000C000U);
+	mmio_write_32(GPIO_INOUTSEL4, 0x00000000U);
+	mmio_write_32(GPIO_INOUTSEL5, 0x0000020EU);
+	mmio_write_32(GPIO_INOUTSEL6, 0x00013880U);
+}
diff --git a/plat/renesas/rcar/pfc/M3/pfc_init_m3.h b/plat/renesas/rcar/pfc/M3/pfc_init_m3.h
new file mode 100644
index 0000000..c409948
--- /dev/null
+++ b/plat/renesas/rcar/pfc/M3/pfc_init_m3.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PFC_INIT_M3_H__
+#define PFC_INIT_M3_H__
+
+void pfc_init_m3(void);
+
+#endif	/* PFC_INIT_M3_H__ */
diff --git a/plat/renesas/rcar/pfc/pfc.mk b/plat/renesas/rcar/pfc/pfc.mk
new file mode 100644
index 0000000..029d9b0
--- /dev/null
+++ b/plat/renesas/rcar/pfc/pfc.mk
@@ -0,0 +1,39 @@
+#
+# Copyright (c) 2015-2016, Renesas Electronics Corporation
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+#   - Redistributions of source code must retain the above copyright notice,
+#     this list of conditions and the following disclaimer.
+#
+#   - Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#
+#   - Neither the name of Renesas nor the names of its contributors may be
+#     used to endorse or promote products derived from this software without
+#     specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+ifeq (${RCAR_LSI},${RCAR_H3})
+    BL2_SOURCES += plat/renesas/rcar/pfc/H3/pfc_init_h3.c
+endif
+ifeq (${RCAR_LSI},${RCAR_M3})
+    BL2_SOURCES += plat/renesas/rcar/pfc/M3/pfc_init_m3.c
+endif
+
+BL2_SOURCES += plat/renesas/rcar/pfc/pfc_init.c
diff --git a/plat/renesas/rcar/pfc/pfc_init.c b/plat/renesas/rcar/pfc/pfc_init.c
new file mode 100644
index 0000000..dc4fe17
--- /dev/null
+++ b/plat/renesas/rcar/pfc/pfc_init.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include "pfc_init.h"
+#if RCAR_LSI == RCAR_H3	/* H3 */
+  #include "H3/pfc_init_h3.h"
+#endif
+#if RCAR_LSI == RCAR_M3	/* M3 */
+  #include "M3/pfc_init_m3.h"
+#endif
+
+
+void pfc_init(void)
+{
+#if RCAR_LSI == RCAR_H3		/* H3 */
+	pfc_init_h3();
+#elif RCAR_LSI == RCAR_M3	/* M3 */
+	pfc_init_m3();
+#endif
+}
diff --git a/plat/renesas/rcar/platform.mk b/plat/renesas/rcar/platform.mk
new file mode 100644
index 0000000..153c70c
--- /dev/null
+++ b/plat/renesas/rcar/platform.mk
@@ -0,0 +1,170 @@
+#
+# Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+# Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# Redistributions of source code must retain the above copyright notice, this
+# list of conditions and the following disclaimer.
+#
+# Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation
+# and/or other materials provided with the distribution.
+#
+# Neither the name of ARM nor the names of its contributors may be used
+# to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+
+# Process flags
+
+PLAT_INCLUDES		:=	-Iinclude/common/tbbr				\
+				-Iplat/renesas/rcar/include/
+
+PLAT_BL_COMMON_SOURCES	:=	lib/aarch64/xlat_tables.c			\
+				plat/common/aarch64/plat_common.c
+
+BL2_SOURCES		+=	plat/common/aarch64/platform_up_stack.S		\
+				drivers/arm/gic/arm_gic.c			\
+				drivers/arm/gic/gic_v2.c			\
+				drivers/arm/gic/gic_v3.c			\
+				plat/common/plat_gic.c				\
+				plat/renesas/rcar/drivers/timer/bl2_swdt.c	\
+				plat/renesas/rcar/drivers/error/bl2_int_error.c	\
+				plat/renesas/rcar/aarch64/rcar_helpers.S	\
+				plat/renesas/rcar/bl2_rcar_setup.c		\
+				plat/renesas/rcar/aarch64/rcar_common.c		\
+				plat/renesas/rcar/drivers/io/io_rcar.c		\
+				plat/renesas/rcar/drivers/io/io_memdrv.c	\
+				plat/renesas/rcar/drivers/scif/scif.S		\
+				plat/renesas/rcar/drivers/auth/rcarboot.c	\
+				plat/renesas/rcar/rcar_io_storage.c		\
+				drivers/io/io_storage.c				\
+				plat/renesas/rcar/drivers/rpc/rpc_driver.c	\
+				plat/renesas/rcar/drivers/dma/dma_driver.c	\
+				plat/renesas/rcar/drivers/avs/avs_driver.c	\
+				plat/renesas/rcar/bl2_secure_setting.c		\
+				plat/renesas/rcar/bl2_cpg_init.c		\
+				plat/renesas/rcar/aarch64/bl2_reset.S
+
+BL31_SOURCES		+=	drivers/arm/cci/cci.c				\
+				drivers/arm/gic/arm_gic.c			\
+				drivers/arm/gic/gic_v2.c			\
+				drivers/arm/gic/gic_v3.c			\
+				lib/cpus/aarch64/aem_generic.S			\
+				lib/cpus/aarch64/cortex_a53.S			\
+				lib/cpus/aarch64/cortex_a57.S			\
+				plat/common/plat_gic.c				\
+				plat/common/aarch64/platform_mp_stack.S		\
+				plat/renesas/rcar/bl31_rcar_setup.c		\
+				plat/renesas/rcar/rcar_pm.c			\
+				plat/renesas/rcar/drivers/memdrv/rcar_console.S	\
+				plat/renesas/rcar/drivers/memdrv/rcar_printf.c	\
+				plat/renesas/rcar/rcar_topology.c		\
+				plat/renesas/rcar/aarch64/rcar_helpers.S	\
+				plat/renesas/rcar/aarch64/rcar_common.c		\
+				plat/renesas/rcar/drivers/pwrc/rcar_pwrc.c
+
+# compile option setting
+SPD			:= opteed
+ARM_CCI_PRODUCT_ID	:= 500
+TRUSTED_BOARD_BOOT	:= 1
+
+# LSI setting common define
+RCAR_H3:=0
+RCAR_M3:=1
+$(eval $(call add_define,RCAR_H3))
+$(eval $(call add_define,RCAR_M3))
+RCAR_CUT_10:=0
+RCAR_CUT_11:=1
+$(eval $(call add_define,RCAR_CUT_10))
+$(eval $(call add_define,RCAR_CUT_11))
+
+ifndef LSI
+  $(error "Error: Unknown LSI. Please use LSI=<LSI name> to specify the LSI")
+else
+  ifeq (${LSI},H3)
+    RCAR_LSI:=${RCAR_H3}
+    ifndef LSI_CUT
+      # enable compatible function.
+      RCAR_LSI_CUT_COMPAT := 1
+      $(eval $(call add_define,RCAR_LSI_CUT_COMPAT))
+    else
+      # disable compatible function.
+      ifeq (${LSI_CUT},10)
+        RCAR_LSI_CUT:=0
+      endif
+      ifeq (${LSI_CUT},11)
+        RCAR_LSI_CUT:=1
+      endif
+      $(eval $(call add_define,RCAR_LSI_CUT))
+    endif
+  else ifeq (${LSI},M3)
+    RCAR_LSI:=${RCAR_M3}
+  else
+    $(error "Error: ${LSI} is not supported.")
+  endif
+  $(eval $(call add_define,RCAR_LSI))
+endif
+
+# Process RCAR_SECURE_BOOT flag
+ifndef RCAR_SECURE_BOOT
+RCAR_SECURE_BOOT := 1
+endif
+$(eval $(call add_define,RCAR_SECURE_BOOT))
+
+# Process RCAR_QOS_TYPE flag
+ifndef RCAR_QOS_TYPE
+RCAR_QOS_TYPE := 0
+endif
+$(eval $(call add_define,RCAR_QOS_TYPE))
+
+# Process RCAR_DRAM_SPLIT flag
+ifndef RCAR_DRAM_SPLIT
+RCAR_DRAM_SPLIT := 0
+endif
+$(eval $(call add_define,RCAR_DRAM_SPLIT))
+
+# Process RCAR_MASTER_BOOT_CPU flag
+ifndef RCAR_MASTER_BOOT_CPU
+RCAR_MASTER_BOOT_CPU := 0
+endif
+$(eval $(call add_define,RCAR_MASTER_BOOT_CPU))
+
+# Process RCAR_BL33_EXECUTION_EL flag
+ifndef RCAR_BL33_EXECUTION_EL
+RCAR_BL33_EXECUTION_EL := 0
+endif
+$(eval $(call add_define,RCAR_BL33_EXECUTION_EL))
+
+# Process PSCI_DISABLE_BIGLITTLE_IN_CA57BOOT flag
+ifndef PSCI_DISABLE_BIGLITTLE_IN_CA57BOOT
+PSCI_DISABLE_BIGLITTLE_IN_CA57BOOT := 1
+endif
+$(eval $(call add_define,PSCI_DISABLE_BIGLITTLE_IN_CA57BOOT))
+
+# Process RCAR_AVS_SETTING_ENABLE flag
+ifeq (${RCAR_AVS_SETTING_ENABLE},0)
+AVS_SETTING_ENABLE := 0
+else
+AVS_SETTING_ENABLE := 1
+endif
+$(eval $(call add_define,AVS_SETTING_ENABLE))
+
+include plat/renesas/rcar/ddr/ddr.mk
+include plat/renesas/rcar/qos/qos.mk
+include plat/renesas/rcar/pfc/pfc.mk
diff --git a/plat/renesas/rcar/rcar_def.h b/plat/renesas/rcar/rcar_def.h
new file mode 100644
index 0000000..ec2a5dc
--- /dev/null
+++ b/plat/renesas/rcar/rcar_def.h
@@ -0,0 +1,267 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_DEF_H__
+#define RCAR_DEF_H__
+
+#include <tbbr_img_def.h>
+
+/* Firmware Image Package */
+#define RCAR_PRIMARY_CPU			0x0
+
+/*
+ * Some of the definitions in this file use the 'ull' suffix in order to avoid
+ * subtle integer overflow errors due to implicit integer type promotion when
+ * working with 32-bit values.
+ *
+ * The TSP linker script includes some of these definitions to define the BL3-2
+ * memory map, but the GNU LD does not support the 'ull' suffix, causing the
+ * build process to fail. To solve this problem, the auxiliary macro MAKE_ULL(x)
+ * will add the 'ull' suffix only when the macro __LINKER__  is not defined
+ * (__LINKER__ is defined in the command line to preprocess the linker script).
+ * Constants in the linker script will not have the 'ull' suffix, but this is
+ * not a problem since the linker evaluates all constant expressions to 64 bit
+ * (assuming the target architecture is 64 bit).
+ */
+#ifndef __LINKER__
+  #define MAKE_ULL(x)			x##ull
+#else
+  #define MAKE_ULL(x)			x
+#endif
+
+/*******************************************************************************
+ * RCAR memory map related constants
+ ******************************************************************************/
+
+/* The first 4KB of Trusted SRAM are used as shared memory */
+#define RCAR_SHARED_MEM_BASE	(RCAR_TRUSTED_SRAM_BASE + RCAR_TRUSTED_SRAM_SIZE)
+#define RCAR_SHARED_MEM_SIZE	0x00001000U	/* 4 KB */
+
+/* The remaining Trusted SRAM is used to load the BL images */
+#define RCAR_TRUSTED_SRAM_BASE	0x44000000	/* Trusted Firmware Image */
+#define RCAR_TRUSTED_SRAM_SIZE	0x0003E000	/* 248 KB */
+
+#define FLASH0_BASE		0x08000000U		/* LBSC RPC address */
+#define FLASH0_SIZE		0x04000000U		/* 64MB */
+
+/* Aggregate of all devices in the first GB */
+#define DEVICE_RCAR_BASE	0xE6000000U
+#define DEVICE_RCAR_SIZE	0x1A000000U
+
+#define DRAM1_BASE		MAKE_ULL(0x40000000)
+#define DRAM1_SIZE		MAKE_ULL(0x80000000)
+
+#define DRAM1_NS_BASE		(DRAM1_BASE + 0x8000000U)
+#define DRAM1_NS_SIZE		(DRAM1_SIZE - DRAM1_NS_BASE)
+#define DRAM1_NS_END		(DRAM1_NS_BASE + DRAM1_NS_SIZE - 1)
+
+
+#define SYS_CNTCTL_BASE		0xE6080000U
+
+
+
+/*
+ * The number of regions like RO(code), coherent and data required by
+ * different BL stages which need to be mapped in the MMU.
+ */
+#if USE_COHERENT_MEM
+#define RCAR_BL_REGIONS		3
+#else
+#define RCAR_BL_REGIONS		2
+#endif
+
+/*
+ * The RCAR_MAX_MMAP_REGIONS depend on the number of entries in rcar_mmap[]
+ * defined for each BL stage in rcar_common.c.
+ */
+#if IMAGE_BL2
+#define RCAR_MMAP_ENTRIES		7
+#endif
+#if IMAGE_BL31
+#define RCAR_MMAP_ENTRIES		5
+#endif
+
+/* Load address of BL33 in the RCAR port */
+#define NS_IMAGE_OFFSET		(DRAM1_BASE + 0x09000000U) /* DRAM */
+
+/* Special value used to verify platform parameters from BL2 to BL3-1 */
+#define RCAR_BL31_PLAT_PARAM_VAL	0x0f1e2d3c4b5a6978ULL
+
+
+/*******************************************************************************
+ * CCI-400 related constants
+ ******************************************************************************/
+#define CCI500_BASE			0xF1200000
+#define CCI500_CLUSTER0_SL_IFACE_IX	2
+#define CCI500_CLUSTER1_SL_IFACE_IX	3
+#define CCI500_CLUSTER0_SL_IFACE_IX_FOR_M3	1
+#define CCI500_CLUSTER1_SL_IFACE_IX_FOR_M3	2
+
+/* CCI-500	*/
+#define	RCAR_CCI_BASE			(0xF1200000U)					/* The base address of CCI-500						*/
+
+/*******************************************************************************
+ * GIC-400 & interrupt handling related constants
+ ******************************************************************************/
+#define RCAR_GICD_BASE			(0xF1010000U)
+#define RCAR_GICD_BASE_A		(0xF1010000)
+#define RCAR_GICR_BASE			(0xF1010000U)	/* not use */
+#define RCAR_GICC_BASE			(0xF1020000U)
+#define RCAR_GICC_BASE_A		(0xF1020000)
+#define RCAR_GICH_BASE			(0xF1040000U)	/* not use */
+#define RCAR_GICV_BASE			(0xF1060000U)	/* not use */
+
+#define ARM_IRQ_SEC_PHY_TIMER		29U
+
+#define ARM_IRQ_SEC_SGI_0		8U
+#define ARM_IRQ_SEC_SGI_1		9U
+#define ARM_IRQ_SEC_SGI_2		10U
+#define ARM_IRQ_SEC_SGI_3		11U
+#define ARM_IRQ_SEC_SGI_4		12U
+#define ARM_IRQ_SEC_SGI_5		13U
+#define ARM_IRQ_SEC_SGI_6		14U
+#define ARM_IRQ_SEC_SGI_7		15U
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	Interrupt ID for Secure world																*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+#define	ARM_IRQ_SEC_RPC			( 70U)						/* RPC									*/
+#define	ARM_IRQ_SEC_TIMER		(166U)						/* Secure timer								*/
+#define	ARM_IRQ_SEC_TIMER_UP		(171U)						/* Secure timer UP							*/
+#define	ARM_IRQ_SEC_WDT			(173U)						/* System watch dog timer						*/
+#define	ARM_IRQ_SEC_WDT_A		(173)						/* System watch dog timer for Assembly language				*/
+#define	ARM_IRQ_SEC_CRYPT		(102U)						/* Crypt Engine sec							*/
+#define	ARM_IRQ_SEC_CRYPT_SecPKA	( 97U)						/* Crypt Engine PKA sec							*/
+#define	ARM_IRQ_SEC_CRYPT_PubPKA	( 98U)						/* Crypt Engine PKA pub							*/
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	New definition for R-CarGen3																*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+#define	RCAR_DEVICE_BASE		(0xE6000000)					/* Start address of BL31 register area					*/
+#define	RCAR_DEVICE_SIZE		(0x1A000000)					/* Size of BL31 register area						*/
+#define	RCAR_LOG_RES_SIZE		(512/8)						/* Size of reservation in log area					*/
+#define	RCAR_LOG_HEADER_SIZE		(16)						/* Size of LOG header							*/
+#define	RCAR_LOG_OTHER_SIZE		(RCAR_LOG_HEADER_SIZE+RCAR_LOG_RES_SIZE)	/* Size of write pointer, log header, reservation			*/
+#define	RCAR_BL31_LOG_MAX		(RCAR_BL31_LOG_SIZE - RCAR_LOG_OTHER_SIZE)	/* MAX log size								*/
+
+#define	RCAR_CRASH_STACK		(0x4403F800)					/* Temporary stack for crash						*/
+
+/****************************************************************************************************************************************************************/
+/*																				*/
+/*	Definition of R-CarGen3 register address														*/
+/*																				*/
+/****************************************************************************************************************************************************************/
+/* Timer	*/
+#define	RCAR_CNTC_BASE			(0xE6080000U)					/* The base addess of generic timer control register			*/
+/* Reset	*/
+#define	RCAR_CPGWPR			(0xE6150900U)					/* CPG write protect register						*/
+#define	RCAR_MODEMR			(0xE6160060U)					/* Mode pin register							*/
+#define	RCAR_MODEMR_A			(0xE6160060)					/* Mode pin register for Assembly language				*/
+#define	RCAR_CA57RESCNT			(0xE6160040U)					/* Reset control register for A57					*/
+#define	RCAR_CA53RESCNT			(0xE6160044U)					/* Reset control register for A53					*/
+#define	RCAR_SRESCR			(0xE6160110U)					/* Soft Power On Reset Control Register					*/
+#define	RCAR_CA53WUPCR			(0xE6151010U)					/* Wake-up control register for A53					*/
+#define	RCAR_CA57WUPCR			(0xE6152010U)					/* Wake-up control register for A57					*/
+#define	RCAR_CA53PSTR			(0xE6151040U)					/* Power status register for A53					*/
+#define	RCAR_CA57PSTR			(0xE6152040U)					/* Power status register for A57					*/
+#define	RCAR_CA53CPU0CR			(0xE6151100U)					/* The base address of CPU power status control register for A53	*/
+#define	RCAR_CA57CPU0CR			(0xE6152100U)					/* The base address of CPU power status control register for A57	*/
+#define	RCAR_CA53CPUCMCR		(0xE6151184U)					/* Common power control register for A53				*/
+#define	RCAR_CA57CPUCMCR		(0xE6152184U)					/* Common power control register for A57				*/
+#define	RCAR_WUPMSKCA57			(0xE6180014U)					/* Wake-up mask register for A57					*/
+#define	RCAR_WUPMSKCA53			(0xE6180018U)					/* Wake-up mask register for A53					*/
+/* SYSC		*/
+#define	RCAR_PWRSR3			(0xE6180140U)					/* Power status register CA53-SCU					*/
+#define	RCAR_PWRSR5			(0xE61801C0U)					/* Power status register CA57-SCU					*/
+#define	RCAR_SYSCIER			(0xE618000CU)					/* Interrupt enable register						*/
+#define	RCAR_SYSCIMR			(0xE6180010U)					/* Interrupt mask register						*/
+#define	RCAR_SYSCSR			(0xE6180000U)					/* SYSC status register							*/
+#define	RCAR_PWRONCR3			(0xE618014CU)					/* Power resume control register CA53-SCU				*/
+#define	RCAR_PWRONCR5			(0xE61801CCU)					/* Power resume control register CA57-SCU				*/
+#define	RCAR_PWROFFCR3			(0xE6180144U)					/* Power shutoff control register CA53-SCU				*/
+#define	RCAR_PWROFFCR5			(0xE61801C4U)					/* Power shutoff control register CA57-SCU				*/
+#define	RCAR_PWRER3			(0xE6180154U)					/* Power shutoff/resume error register CA53-SCU				*/
+#define	RCAR_PWRER5			(0xE61801D4U)					/* Power shutoff/resume error register CA57-SCU				*/
+#define	RCAR_SYSCISR			(0xE6180004U)					/* Interrupt status register						*/
+#define	RCAR_SYSCISCR			(0xE6180008U)					/* Interrupt status clear register					*/
+/* Product register	*/
+#define	RCAR_PRR			(0xFFF00044U)					/* Product register							*/
+
+/*******************************************************************************
+ *  RCAR product and cut information
+ ******************************************************************************/
+#define RCAR_PRODUCT_MASK		(0x00007F00U)
+#define RCAR_CUT_MASK			(0x000000FFU)
+#define RCAR_PRODUCT_H3			(0x00004F00U)
+#define RCAR_PRODUCT_M3			(0x00005200U)
+#define RCAR_CUT_ES10			(0x00000000U)
+#define RCAR_CUT_ES11			(0x00000001U)
+#define RCAR_MAJOR_MASK			(0x000000F0U)
+#define RCAR_MINOR_MASK			(0x0000000FU)
+#define RCAR_PRODUCT_SHIFT		(8U)
+#define RCAR_MAJOR_SHIFT		(4U)
+#define RCAR_MINOR_SHIFT		(0U)
+#define RCAR_MAJOR_OFFSET		(1U)
+#define RCAR_PRODUCT_H3_CUT10		(RCAR_PRODUCT_H3 | 0x00U) /* H3 WS1.0 */
+#define RCAR_PRODUCT_H3_CUT11		(RCAR_PRODUCT_H3 | 0x01U) /* H3 WS1.1 */
+#define RCAR_PRODUCT_M3_CUT10		(RCAR_PRODUCT_M3 | 0x00U) /* M3 */
+/****************************************************************************************************************************************************************/
+/* Memory mapped Generic timer interfaces  */
+/****************************************************************************************************************************************************************/
+#define ARM_SYS_CNTCTL_BASE		RCAR_CNTC_BASE
+
+/*******************************************************************************
+ *  Boot CPU
+ ******************************************************************************/
+#define	RCAR_BOOT_CA5X			(0U)	/* Master boot CPU is CA57/53 */
+#define	RCAR_BOOT_CR7			(1U)	/* Master boot CPU is CR7 */
+
+/*******************************************************************************
+ *  Shared Data
+ ******************************************************************************/
+
+#define	RCAR_BL31_MAIL_BASE	(0x4403E000)
+#define	RCAR_BL31_MAIL_SIZE	(0x00002000)
+#define	RCAR_BL31_WORK_BASE	(0x44022000)
+#define	RCAR_BL31_WORK_SIZE	(0x0001C000)
+
+/* Entrypoint mailboxes */
+#define MBOX_BASE		RCAR_SHARED_MEM_BASE
+#define MBOX_SIZE		0x200
+
+/* Base address where parameters to BL31 are stored */
+#define PARAMS_BASE		(MBOX_BASE + MBOX_SIZE)
+
+#endif /* RCAR_DEF_H__ */
diff --git a/plat/renesas/rcar/rcar_io_storage.c b/plat/renesas/rcar/rcar_io_storage.c
new file mode 100644
index 0000000..fd3e413
--- /dev/null
+++ b/plat/renesas/rcar/rcar_io_storage.c
@@ -0,0 +1,442 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <bl_common.h>		/* For ARRAY_SIZE */
+#include <debug.h>
+#include <io_driver.h>
+#include <io_storage.h>
+#include <io_semihosting.h>
+#include <platform_def.h>
+#include <string.h>
+#include "io_common.h"
+#include "io_rcar.h"
+#include "io_memdrv.h"
+
+/* IO devices */
+static uintptr_t rcar_dev_handle;
+static uintptr_t memdrv_dev_handle;
+
+static const io_block_spec_t rcar_block_spec = {
+	.offset = FLASH0_BASE,
+	.length = FLASH0_SIZE
+};
+
+static const io_block_spec_t bl2_file_spec = {
+	.offset = BL2_IMAGE_ID,
+};
+
+static const io_block_spec_t bl31_file_spec = {
+	.offset = BL31_IMAGE_ID,
+};
+
+static const io_block_spec_t bl32_file_spec = {
+	.offset = BL32_IMAGE_ID,
+};
+
+static const io_block_spec_t bl33_file_spec = {
+	.offset = BL33_IMAGE_ID,
+};
+
+static const io_block_spec_t bl332_file_spec = {
+	.offset = BL332_IMAGE_ID,
+};
+
+static const io_block_spec_t bl333_file_spec = {
+	.offset = BL333_IMAGE_ID,
+};
+
+static const io_block_spec_t bl334_file_spec = {
+	.offset = BL334_IMAGE_ID,
+};
+
+static const io_block_spec_t bl335_file_spec = {
+	.offset = BL335_IMAGE_ID,
+};
+
+static const io_block_spec_t bl336_file_spec = {
+	.offset = BL336_IMAGE_ID,
+};
+
+static const io_block_spec_t bl337_file_spec = {
+	.offset = BL337_IMAGE_ID,
+};
+
+static const io_block_spec_t bl338_file_spec = {
+	.offset = BL338_IMAGE_ID,
+};
+
+
+#if TRUSTED_BOARD_BOOT
+static const io_block_spec_t trusted_key_cert_file_spec = {
+	.offset = TRUSTED_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl31_key_cert_file_spec = {
+	.offset = BL31_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl32_key_cert_file_spec = {
+	.offset = BL32_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl33_key_cert_file_spec = {
+	.offset = BL33_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl332_key_cert_file_spec = {
+	.offset = BL332_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl333_key_cert_file_spec = {
+	.offset = BL333_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl334_key_cert_file_spec = {
+	.offset = BL334_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl335_key_cert_file_spec = {
+	.offset = BL335_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl336_key_cert_file_spec = {
+	.offset = BL336_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl337_key_cert_file_spec = {
+	.offset = BL337_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl338_key_cert_file_spec = {
+	.offset = BL338_KEY_CERT_ID,
+};
+
+static const io_block_spec_t bl31_cert_file_spec = {
+	.offset = BL31_CERT_ID,
+};
+
+static const io_block_spec_t bl32_cert_file_spec = {
+	.offset = BL32_CERT_ID,
+};
+
+static const io_block_spec_t bl33_cert_file_spec = {
+	.offset = BL33_CERT_ID,
+};
+
+static const io_block_spec_t bl332_cert_file_spec = {
+	.offset = BL332_CERT_ID,
+};
+
+static const io_block_spec_t bl333_cert_file_spec = {
+	.offset = BL333_CERT_ID,
+};
+
+static const io_block_spec_t bl334_cert_file_spec = {
+	.offset = BL334_CERT_ID,
+};
+
+static const io_block_spec_t bl335_cert_file_spec = {
+	.offset = BL335_CERT_ID,
+};
+
+static const io_block_spec_t bl336_cert_file_spec = {
+	.offset = BL336_CERT_ID,
+};
+
+static const io_block_spec_t bl337_cert_file_spec = {
+	.offset = BL337_CERT_ID,
+};
+
+static const io_block_spec_t bl338_cert_file_spec = {
+	.offset = BL338_CERT_ID,
+};
+#endif /* TRUSTED_BOARD_BOOT */
+
+static int32_t open_rcar(const uintptr_t spec);
+static int32_t open_memmap(const uintptr_t spec);
+
+/* sakata check table info */
+struct plat_io_policy {
+	uintptr_t *dev_handle;
+	uintptr_t image_spec;
+	int32_t (*check)(const uintptr_t spec);
+};
+
+static const struct plat_io_policy policies[] = {
+	[FIP_IMAGE_ID] = {
+		&memdrv_dev_handle,
+		(uintptr_t)&rcar_block_spec,
+		&open_memmap
+	},
+	[BL2_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl2_file_spec,
+		&open_rcar
+	},
+	[BL31_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_file_spec,
+		&open_rcar
+	},
+	[BL32_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_file_spec,
+		&open_rcar
+	},
+	[BL33_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_file_spec,
+		&open_rcar
+	},
+	[BL332_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl332_file_spec,
+		&open_rcar
+	},
+	[BL333_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl333_file_spec,
+		&open_rcar
+	},
+	[BL334_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl334_file_spec,
+		&open_rcar
+	},
+	[BL335_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl335_file_spec,
+		&open_rcar
+	},
+	[BL336_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl336_file_spec,
+		&open_rcar
+	},
+	[BL337_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl337_file_spec,
+		&open_rcar
+	},
+	[BL338_IMAGE_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl338_file_spec,
+		&open_rcar
+	},
+#if TRUSTED_BOARD_BOOT
+	[TRUSTED_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&trusted_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL31_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL32_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL33_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL332_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl332_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL333_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl333_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL334_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl334_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL335_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl335_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL336_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl336_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL337_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl337_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL338_KEY_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl338_key_cert_file_spec,
+		&open_rcar
+	},
+	[BL31_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl31_cert_file_spec,
+		&open_rcar
+	},
+	[BL32_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl32_cert_file_spec,
+		&open_rcar
+	},
+	[BL33_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl33_cert_file_spec,
+		&open_rcar
+	},
+	[BL332_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl332_cert_file_spec,
+		&open_rcar
+	},
+	[BL333_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl333_cert_file_spec,
+		&open_rcar
+	},
+	[BL334_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl334_cert_file_spec,
+		&open_rcar
+	},
+	[BL335_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl335_cert_file_spec,
+		&open_rcar
+	},
+	[BL336_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl336_cert_file_spec,
+		&open_rcar
+	},
+	[BL337_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl337_cert_file_spec,
+		&open_rcar
+	},
+	[BL338_CERT_ID] = {
+		&rcar_dev_handle,
+		(uintptr_t)&bl338_cert_file_spec,
+		&open_rcar
+	},{
+#endif /* TRUSTED_BOARD_BOOT */
+		0, 0, 0
+	}
+};
+
+
+static int32_t open_rcar(const uintptr_t spec)
+{
+	int32_t result;
+
+	/* See if a Firmware Image Package is available */
+	result = io_dev_init(rcar_dev_handle, (uintptr_t)FIP_IMAGE_ID);
+	if (result == IO_SUCCESS) {
+		VERBOSE("Using RCar File Manager\n");
+	}
+	return result;
+}
+
+
+static int32_t open_memmap(const uintptr_t spec)
+{
+	int32_t result;
+	uintptr_t local_image_handle;
+
+	result = io_dev_init(memdrv_dev_handle, 0U);
+	if (result == IO_SUCCESS) {
+		result = io_open(memdrv_dev_handle, spec, &local_image_handle);
+		if (result == IO_SUCCESS) {
+			VERBOSE("Using Memdrv IO\n");
+			(void)io_close(local_image_handle);
+		}
+	}
+	return result;
+}
+
+
+
+void rcar_io_setup (void)
+{
+	int32_t io_result;
+	const io_dev_connector_t *rcar_dev_con;
+	const io_dev_connector_t *memmap_dev_con;
+
+	/* Register the IO devices on this platform */
+	io_result = register_io_dev_rcar(&rcar_dev_con);
+	assert(io_result == IO_SUCCESS);
+
+	io_result = register_io_dev_memdrv(&memmap_dev_con);
+	assert(io_result == IO_SUCCESS);
+
+	/* Open connections to devices and cache the handles */
+	io_result = io_dev_open(rcar_dev_con, 0U, &rcar_dev_handle);
+	assert(io_result == IO_SUCCESS);
+
+	io_result = io_dev_open(memmap_dev_con, 0U,
+				&memdrv_dev_handle);
+	assert(io_result == IO_SUCCESS);
+
+	/* Ignore improbable errors in release builds */
+	(void)io_result;
+}
+
+
+/* Return an IO device handle and specification which can be used to access
+ * an image. Use this to enforce platform load policy */
+int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	int result = IO_FAIL;
+	const struct plat_io_policy *policy;
+
+	assert(image_id < ARRAY_SIZE(policies));
+
+	policy = &policies[image_id];
+	result = policy->check(policy->image_spec);
+	if (result == IO_SUCCESS) {
+		*image_spec = policy->image_spec;
+		*dev_handle = *(policy->dev_handle);
+	}
+
+	return result;
+}
diff --git a/plat/renesas/rcar/rcar_pm.c b/plat/renesas/rcar/rcar_pm.c
new file mode 100644
index 0000000..7750169
--- /dev/null
+++ b/plat/renesas/rcar/rcar_pm.c
@@ -0,0 +1,427 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <arch_helpers.h>
+#include <arm_gic.h>
+#include <assert.h>
+#include <bakery_lock.h>
+#include <cci.h>
+#include <debug.h>
+#include <mmio.h>
+#include <platform.h>
+#include <platform_def.h>
+#include <psci.h>
+#include <errno.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+#include "rcar_def.h"
+#include "rcar_private.h"
+
+static void rcar_program_mailbox(uint64_t mpidr, uint64_t address);
+static int32_t rcar_do_plat_actions(unsigned int afflvl, unsigned int state);
+static void rcar_cpu_pwrdwn_common(void);
+static void rcar_cluster_pwrdwn_common(void);
+static void __dead2 rcar_system_off(void);
+static void __dead2 rcar_system_reset(void);
+
+static int32_t cpu_on_check(uint64_t mpidr);
+
+extern int32_t platform_is_primary_cpu(uint64_t mpidr);
+
+/*******************************************************************************
+ * Private RCAR function to program the mailbox for a cpu before it is released
+ * from reset.
+ ******************************************************************************/
+static void rcar_program_mailbox(uint64_t mpidr, uint64_t address)
+{
+	uint64_t linear_id;
+	mailbox_t *rcar_mboxes;
+
+	linear_id = platform_get_core_pos(mpidr);
+	rcar_mboxes = (mailbox_t *)MBOX_BASE;
+	rcar_mboxes[linear_id].value = address;
+	flush_dcache_range((unsigned long)&rcar_mboxes[linear_id],
+			sizeof(unsigned long));
+}
+
+/*******************************************************************************
+ * Function which implements the common RCAR specific operations to power down a
+ * cpu in response to a CPU_OFF or CPU_SUSPEND request.
+ ******************************************************************************/
+static void rcar_cpu_pwrdwn_common(void)
+{
+	/* Prevent interrupts from spuriously waking up this cpu */
+	arm_gic_cpuif_deactivate();
+
+	/* Program the power controller to power off this cpu. */
+	rcar_pwrc_cpuoff (read_mpidr_el1());
+}
+
+/*******************************************************************************
+ * Function which implements the common RCAR specific operations to power down a
+ * cluster in response to a CPU_OFF or CPU_SUSPEND request.
+ ******************************************************************************/
+static void rcar_cluster_pwrdwn_common(void)
+{
+	uint64_t mpidr = read_mpidr_el1();
+
+	/* Disable coherency if this cluster is to be turned off */
+	rcar_cci_disable();
+
+	/* Program the power controller to turn the cluster off */
+	rcar_pwrc_clusteroff(mpidr);
+}
+
+/*******************************************************************************
+ * Private RCAR function which is used to determine if any platform actions
+ * should be performed for the specified affinity instance given its
+ * state. Nothing needs to be done if the 'state' is not off or if this is not
+ * the highest affinity level which will enter the 'state'.
+ ******************************************************************************/
+static int32_t rcar_do_plat_actions(unsigned int afflvl, unsigned int state)
+{
+	unsigned int max_phys_off_afflvl;
+
+	assert(afflvl <= MPIDR_AFFLVL1);
+
+	if (state != PSCI_STATE_OFF) {
+		return -EAGAIN;
+	}
+
+	/*
+	 * Find the highest affinity level which will be suspended and postpone
+	 * all the platform specific actions until that level is hit.
+	 */
+	max_phys_off_afflvl = psci_get_max_phys_off_afflvl();
+	assert(max_phys_off_afflvl != PSCI_INVALID_DATA);
+	if (afflvl != max_phys_off_afflvl) {
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to enter standby.
+ ******************************************************************************/
+void rcar_affinst_standby(unsigned int power_state)
+{
+	/*
+	 * Enter standby state
+	 * dsb is good practice before using wfi to enter low power states
+	 */
+	dsb();
+	wfi();
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be turned on. The
+ * level and mpidr determine the affinity instance.
+ ******************************************************************************/
+int rcar_affinst_on(unsigned long mpidr, unsigned long sec_entrypoint,
+		unsigned int afflvl, unsigned int state)
+{
+	int rc = PSCI_E_SUCCESS;
+
+#if PSCI_DISABLE_BIGLITTLE_IN_CA57BOOT
+	uint64_t boot_cluster = read_mpidr_el1() & ((uint64_t)MPIDR_CLUSTER_MASK);
+	if (boot_cluster == 0x0000U) {
+		if ((mpidr & ((uint64_t)MPIDR_CLUSTER_MASK)) != boot_cluster) {
+			return PSCI_E_INTERN_FAIL;
+		}
+	}
+#endif
+	/*
+	 * It's possible to turn on only affinity level 0 i.e. a cpu
+	 * on the RCAR. Ignore any other affinity level.
+	 */
+	if (afflvl != MPIDR_AFFLVL0) {
+		return rc;
+	}
+
+	/*
+	 * Ensure that we do not cancel an inflight power off request
+	 * for the target cpu. That would leave it in a zombie wfi.
+	 * Wait for it to power off, program the jump address for the
+	 * target cpu and then program the power controller to turn
+	 * that cpu on
+	 */
+
+	rcar_program_mailbox(mpidr, sec_entrypoint);
+	rcar_pwrc_cpuon(mpidr);
+
+	return rc;
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be turned off. The
+ * level and mpidr determine the affinity instance. The 'state' arg. allows the
+ * platform to decide whether the cluster is being turned off and take apt
+ * actions.
+ *
+ * CAUTION: There is no guarantee that caches will remain turned on across calls
+ * to this function as each affinity level is dealt with. So do not write & read
+ * global variables across calls. It will be wise to do flush a write to the
+ * global to prevent unpredictable results.
+ ******************************************************************************/
+void rcar_affinst_off(unsigned int afflvl, unsigned int state)
+{
+	/* Determine if any platform actions need to be executed */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/*
+	 * If execution reaches this stage then this affinity level will be
+	 * suspended. Perform at least the cpu specific actions followed the
+	 * cluster specific operations if applicable.
+	 */
+	rcar_cpu_pwrdwn_common();
+
+	if (afflvl != MPIDR_AFFLVL0) {
+		rcar_cluster_pwrdwn_common();
+	}
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance is about to be suspended. The
+ * level and mpidr determine the affinity instance. The 'state' arg. allows the
+ * platform to decide whether the cluster is being turned off and take apt
+ * actions.
+ *
+ * CAUTION: There is no guarantee that caches will remain turned on across calls
+ * to this function as each affinity level is dealt with. So do not write & read
+ * global variables across calls. It will be wise to do flush a write to the
+ * global to prevent unpredictable results.
+ ******************************************************************************/
+void rcar_affinst_suspend(unsigned long sec_entrypoint, unsigned int afflvl,
+		unsigned int state)
+{
+	unsigned long mpidr;
+
+	/* Determine if any platform actions need to be executed. */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/* Get the mpidr for this cpu */
+	mpidr = read_mpidr_el1();
+
+	/* Program the jump address for the this cpu */
+	rcar_program_mailbox(mpidr, sec_entrypoint);
+
+	/* Program the power controller to enable wakeup interrupts. */
+	rcar_pwrc_enable_interrupt_wakeup(mpidr);
+
+	/* Perform the common cpu specific operations */
+	rcar_cpu_pwrdwn_common();
+
+	/* Perform the common cluster specific operations */
+	if (afflvl != MPIDR_AFFLVL0) {
+		rcar_cluster_pwrdwn_common();
+	}
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance has just been powered on after
+ * being turned off earlier. The level and mpidr determine the affinity
+ * instance. The 'state' arg. allows the platform to decide whether the cluster
+ * was turned off prior to wakeup and do what's necessary to setup it up
+ * correctly.
+ ******************************************************************************/
+void rcar_affinst_on_finish(unsigned int afflvl, unsigned int state)
+{
+	unsigned long mpidr;
+
+	/* Determine if any platform actions need to be executed. */
+	if (rcar_do_plat_actions(afflvl, state) == -EAGAIN) {
+		return;
+	}
+
+	/* Get the mpidr for this cpu */
+	mpidr = read_mpidr_el1();
+
+	/* Perform the common cluster specific operations */
+	if (afflvl != MPIDR_AFFLVL0) {
+		/* Enable coherency if this cluster was off */
+		rcar_cci_enable();
+	}
+
+	/*
+	 * Prohibit cpu wake up by interrupt
+	 */
+	rcar_pwrc_disable_interrupt_wakeup(mpidr);
+
+	/* Zero the jump address in the mailbox for this cpu */
+	rcar_program_mailbox(mpidr, 0U);
+
+	/* Enable the gic cpu interface */
+	arm_gic_cpuif_setup();
+
+	/* TODO: This setup is needed only after a cold boot */
+	arm_gic_pcpu_distif_setup();
+}
+
+/*******************************************************************************
+ * RCAR handler called when an affinity instance has just been powered on after
+ * having been suspended earlier. The level and mpidr determine the affinity
+ * instance.
+ * TODO: At the moment we reuse the on finisher and reinitialize the secure
+ * context. Need to implement a separate suspend finisher.
+ ******************************************************************************/
+void rcar_affinst_suspend_finish(unsigned int afflvl, unsigned int state)
+{
+	rcar_affinst_on_finish(afflvl, state);
+}
+
+/*******************************************************************************
+ * RCAR handlers to shutdown/reboot the system
+ ******************************************************************************/
+static void __dead2 rcar_system_off(void)
+{
+	uint64_t my_cpu;
+	int32_t rtn_primary;
+	int32_t rtn_on;
+
+	my_cpu = read_mpidr_el1();
+	rtn_primary = platform_is_primary_cpu(my_cpu);
+	rtn_on = cpu_on_check(my_cpu);
+	if ((rtn_primary != 0) && (rtn_on == 0)) {
+		rcar_pwrc_cpuoff(my_cpu);
+		rcar_pwrc_clusteroff(my_cpu);
+	} else {
+		panic();
+	}
+	wfi();
+
+	ERROR("RCAR System Off: operation not handled.\n");
+	panic();
+}
+
+static void __dead2 rcar_system_reset(void)
+{
+	rcar_pwrc_system_reset();
+
+	ERROR("RCAR System Reset: operation not handled.\n");
+	panic();
+}
+
+static int32_t cpu_on_check(uint64_t mpidr)
+{
+	uint64_t i;
+	uint64_t j;
+	uint64_t cpu_count;
+	uintptr_t reg_PSTR;
+	uint32_t status;
+	uint64_t my_cpu;
+	int32_t rtn;
+
+	const uint64_t cpu_num_in_core[PLATFORM_MAX_AFFLVL + 1] = {
+			(uint64_t)PLATFORM_CLUSTER0_CORE_COUNT,
+			(uint64_t)PLATFORM_CLUSTER1_CORE_COUNT
+	};
+	const uintptr_t registerPSTR[PLATFORM_MAX_AFFLVL + 1] = {
+			RCAR_CA57PSTR,
+			RCAR_CA53PSTR
+	};
+
+	rtn = 0;
+	my_cpu = mpidr & ((uint64_t)((MPIDR_CLUSTER_MASK) | (MPIDR_CPU_MASK)));
+	for (i = 0U; i < ((uint64_t)(PLATFORM_MAX_AFFLVL + 1U)); i++) {
+		cpu_count = cpu_num_in_core[i];
+		reg_PSTR = registerPSTR[i];
+		for (j = 0U; j < cpu_count; j++) {
+			if (my_cpu != ((i * 0x100U) + j)) {
+				status = mmio_read_32(reg_PSTR) >> (j * 4U);
+				if ((status & 0x00000003U) == 0U) {
+					rtn--;
+				}
+			}
+		}
+	}
+	return (rtn);
+
+}
+
+/*******************************************************************************
+ * RCAR handler called to check the validity of the power state parameter.
+ ******************************************************************************/
+int rcar_validate_power_state(unsigned int power_state)
+{
+	/* Sanity check the requested state */
+	if (psci_get_pstate_type(power_state) == PSTATE_TYPE_STANDBY) {
+		/*
+		 * It's possible to enter standby only on affinity level 0
+		 * i.e. a cpu on the rcar. Ignore any other affinity level.
+		 */
+		if (psci_get_pstate_afflvl(power_state) != MPIDR_AFFLVL0) {
+			return PSCI_E_INVALID_PARAMS;
+		}
+	}
+
+	/*
+	 * We expect the 'state id' to be zero.
+	 */
+	if (psci_get_pstate_id(power_state) != 0U) {
+		return PSCI_E_INVALID_PARAMS;
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+unsigned int rcar_get_sys_suspend_power_state(void)
+{
+	return psci_make_powerstate(0, PSTATE_TYPE_POWERDOWN,
+			PLATFORM_MAX_AFFLVL);
+}
+/*******************************************************************************
+ * Export the platform handlers to enable psci to invoke them
+ ******************************************************************************/
+static const plat_pm_ops_t rcar_plat_pm_ops = {
+	.affinst_standby = rcar_affinst_standby,
+	.affinst_on = rcar_affinst_on,
+	.affinst_off = rcar_affinst_off,
+	.affinst_suspend = rcar_affinst_suspend,
+	.affinst_on_finish = rcar_affinst_on_finish,
+	.affinst_suspend_finish = rcar_affinst_suspend_finish,
+	.system_off = rcar_system_off,
+	.system_reset = rcar_system_reset,
+	.validate_power_state = rcar_validate_power_state,
+	.get_sys_suspend_power_state = rcar_get_sys_suspend_power_state
+};
+
+/*******************************************************************************
+ * Export the platform specific power ops & initialize the rcar power controller
+ ******************************************************************************/
+int platform_setup_pm(const plat_pm_ops_t **plat_ops)
+{
+	*plat_ops = &rcar_plat_pm_ops;
+	return 0;
+}
diff --git a/plat/renesas/rcar/rcar_private.h b/plat/renesas/rcar/rcar_private.h
new file mode 100644
index 0000000..b5894a1
--- /dev/null
+++ b/plat/renesas/rcar/rcar_private.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_PRIVATE_H__
+#define RCAR_PRIVATE_H__
+
+#include <bakery_lock.h>
+#include <bl_common.h>
+#include <cpu_data.h>
+#include <platform_def.h>
+
+
+typedef volatile struct mailbox {
+	unsigned long value
+	__attribute__((__aligned__(CACHE_WRITEBACK_GRANULE)));
+} mailbox_t;
+
+/*******************************************************************************
+ * This structure represents the superset of information that is passed to
+ * BL31 e.g. while passing control to it from BL2 which is bl31_params
+ * and bl31_plat_params and its elements
+ ******************************************************************************/
+typedef struct bl2_to_bl31_params_mem {
+	bl31_params_t bl31_params;
+	image_info_t bl31_image_info;
+	image_info_t bl32_image_info;
+	image_info_t bl33_image_info;
+	entry_point_info_t bl33_ep_info;
+	entry_point_info_t bl32_ep_info;
+	entry_point_info_t bl31_ep_info;
+} bl2_to_bl31_params_mem_t;
+
+#if USE_COHERENT_MEM
+/*
+ * Use this macro to instantiate lock before it is used in below
+ * rcar_lock_xxx() macros
+ */
+#define RCAR_INSTANTIATE_LOCK	DEFINE_BAKERY_LOCK(rcar_lock);
+
+/*
+ * These are wrapper macros to the Coherent Memory Bakery Lock API.
+ */
+#define rcar_lock_init()	bakery_lock_init(&rcar_lock)
+#define rcar_lock_get()		bakery_lock_get(&rcar_lock)
+#define rcar_lock_release()	bakery_lock_release(&rcar_lock)
+
+
+#else
+
+/*******************************************************************************
+ * Constants to specify how many bakery locks this platform implements. These
+ * are used if the platform chooses not to use coherent memory for bakery lock
+ * data structures.
+ ******************************************************************************/
+#define RCAR_MAX_BAKERIES	2
+#define RCAR_PWRC_BAKERY_ID	0
+
+/*******************************************************************************
+ * Definition of structure which holds platform specific per-cpu data. Currently
+ * it holds only the bakery lock information for each cpu. Constants to
+ * specify how many bakeries this platform implements and bakery ids are
+ * specified in rcar_def.h
+ ******************************************************************************/
+typedef struct rcar_cpu_data {
+	bakery_info_t pcpu_bakery_info[RCAR_MAX_BAKERIES];
+} rcar_cpu_data_t;
+
+/* Macro to define the offset of bakery_info_t in rcar_cpu_data_t */
+#define RCAR_CPU_DATA_LOCK_OFFSET	__builtin_offsetof\
+					    (rcar_cpu_data_t, pcpu_bakery_info)
+
+
+/*******************************************************************************
+ * Helper macros for bakery lock api when using the above rcar_cpu_data_t for
+ * bakery lock data structures. It assumes that the bakery_info is at the
+ * beginning of the platform specific per-cpu data.
+ ******************************************************************************/
+#define rcar_lock_init(_lock_arg)	/* No init required */
+#define rcar_lock_get(_lock_arg)		bakery_lock_get(_lock_arg,  \
+						CPU_DATA_PLAT_PCPU_OFFSET + \
+						RCAR_CPU_DATA_LOCK_OFFSET)
+#define rcar_lock_release(_lock_arg)	bakery_lock_release(_lock_arg,	    \
+						CPU_DATA_PLAT_PCPU_OFFSET + \
+						RCAR_CPU_DATA_LOCK_OFFSET)
+
+/*
+ * Ensure that the size of the RCAR specific per-cpu data structure and the size
+ * of the memory allocated in generic per-cpu data for the platform are the same.
+ */
+CASSERT(PLAT_PCPU_DATA_SIZE == sizeof(rcar_cpu_data_t),	\
+	rcar_pcpu_data_size_mismatch);
+
+#endif /* __USE_COHERENT_MEM__ */
+
+/*******************************************************************************
+ * Function and variable prototypes
+ ******************************************************************************/
+void rcar_configure_mmu_el1(unsigned long total_base,
+			   unsigned long total_size,
+			   unsigned long,
+			   unsigned long
+#if USE_COHERENT_MEM
+			   , unsigned long,
+			   unsigned long
+#endif
+			   );
+void rcar_configure_mmu_el3(unsigned long total_base,
+			   unsigned long total_size,
+			   unsigned long,
+			   unsigned long
+#if USE_COHERENT_MEM
+			   , unsigned long,
+			   unsigned long
+#endif
+			   );
+
+void rcar_cci_init(void);
+void rcar_cci_enable(void);
+void rcar_cci_disable(void);
+
+/* Declarations for rcar_topology.c */
+void rcar_setup_topology(void);
+
+/* Gets the SPR for BL32 entry */
+uint32_t rcar_get_spsr_for_bl32_entry(void);
+
+/* Gets the SPSR for BL33 entry */
+uint32_t rcar_get_spsr_for_bl33_entry(void);
+
+/* Prototype function for power management	*/
+void rcar_affinst_standby(unsigned int power_state);
+int rcar_affinst_on(unsigned long mpidr, unsigned long sec_entrypoint,
+		unsigned int afflvl, unsigned int state);
+void rcar_affinst_off(unsigned int afflvl, unsigned int state);
+void rcar_affinst_suspend(unsigned long sec_entrypoint, unsigned int afflvl,
+		unsigned int state);
+void rcar_affinst_on_finish(unsigned int afflvl, unsigned int state);
+void rcar_affinst_suspend_finish(unsigned int afflvl, unsigned int state);
+int rcar_validate_power_state(unsigned int power_state);
+
+/* Function prototypes for read and write to the CPU system registers */
+void iciallu(void);
+
+#endif /* RCAR_PRIVATE_H__ */
diff --git a/plat/renesas/rcar/rcar_topology.c b/plat/renesas/rcar/rcar_topology.c
new file mode 100644
index 0000000..78dcdd9
--- /dev/null
+++ b/plat/renesas/rcar/rcar_topology.c
@@ -0,0 +1,223 @@
+/*
+ * Copyright (c) 2013-2014, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * Neither the name of ARM nor the names of its contributors may be used
+ * to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <platform_def.h>
+/* TODO: Reusing psci error codes & state information. Get our own! */
+#include <psci.h>
+#include "drivers/pwrc/rcar_pwrc.h"
+
+/* We treat '255' as an invalid affinity instance */
+#define AFFINST_INVAL	0xff
+
+typedef struct affinity_info {
+	unsigned char sibling;
+	unsigned char child;
+	unsigned char state;
+	unsigned int data;
+} affinity_info_t;
+
+/*******************************************************************************
+ * The following two data structures store the topology tree for the rcar. There
+ * is a separate array for each affinity level i.e. cpus and clusters. The child
+ * and sibling references allow traversal inside and in between the two arrays.
+ ******************************************************************************/
+static affinity_info_t rcar_aff1_topology_map[PLATFORM_CLUSTER_COUNT];
+static affinity_info_t rcar_aff0_topology_map[PLATFORM_CORE_COUNT];
+
+/* Simple global variable to safeguard us from stupidity */
+static unsigned int topology_setup_done;
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform to allow the former to detect the platform
+ * topology. psci queries the platform to determine how many affinity instances
+ * are present at a particular level for a given mpidr e.g. consider a dual
+ * cluster platform where each cluster has 4 cpus. A call to this function with
+ * (0, 0x100) will return the number of cpus implemented under cluster 1 i.e. 4.
+ * Similarly a call with (1, 0x100) will return 2 i.e. the number of clusters.
+ * This is 'cause we are effectively asking how many affinity level 1 instances
+ * are implemented under affinity level 2 instance 0.
+ ******************************************************************************/
+unsigned int plat_get_aff_count(unsigned int aff_lvl,
+				unsigned long mpidr)
+{
+	unsigned int aff_count = 1, ctr;
+	unsigned char parent_aff_id;
+
+	assert(topology_setup_done == 1);
+
+	switch (aff_lvl) {
+	case 3:
+	case 2:
+		/*
+		 * Assert if the parent affinity instance is not 0.
+		 * This also takes care of level 3 in an obfuscated way
+		 */
+		parent_aff_id = (mpidr >> MPIDR_AFF3_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id == 0);
+
+		/*
+		 * Report that we implement a single instance of
+		 * affinity levels 2 & 3 which are AFF_ABSENT
+		 */
+		break;
+	case 1:
+		/* Assert if the parent affinity instance is not 0. */
+		parent_aff_id = (mpidr >> MPIDR_AFF2_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id == 0);
+
+		/* Fetch the starting index in the aff1 array */
+		for (ctr = 0;
+		     rcar_aff1_topology_map[ctr].sibling != AFFINST_INVAL;
+		     ctr = rcar_aff1_topology_map[ctr].sibling) {
+			aff_count++;
+		}
+
+		break;
+	case 0:
+		/* Assert if the cluster id is anything apart from 0 or 1 */
+		parent_aff_id = (mpidr >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+		assert(parent_aff_id < PLATFORM_CLUSTER_COUNT);
+
+		/* Fetch the starting index in the aff0 array */
+		for (ctr = rcar_aff1_topology_map[parent_aff_id].child;
+		     rcar_aff0_topology_map[ctr].sibling != AFFINST_INVAL;
+		     ctr = rcar_aff0_topology_map[ctr].sibling) {
+			aff_count++;
+		}
+
+		break;
+	default:
+		assert(0);
+	}
+
+	return aff_count;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform to allow the former to detect the state of a
+ * affinity instance in the platform topology. psci queries the platform to
+ * determine whether an affinity instance is present or absent. This caters for
+ * topologies where an intermediate affinity level instance is missing e.g.
+ * consider a platform which implements a single cluster with 4 cpus and there
+ * is another cpu sitting directly on the interconnect along with the cluster.
+ * The mpidrs of the cluster would range from 0x0-0x3. The mpidr of the single
+ * cpu would be 0x100 to highlight that it does not belong to cluster 0. Cluster
+ * 1 is however missing but needs to be accounted to reach this single cpu in
+ * the topology tree. Hence it will be marked as PSCI_AFF_ABSENT. This is not
+ * applicable to the RCAR but depicted as an example.
+ ******************************************************************************/
+unsigned int plat_get_aff_state(unsigned int aff_lvl,
+				unsigned long mpidr)
+{
+	unsigned int aff_state = PSCI_AFF_ABSENT, idx;
+	idx = (mpidr >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	assert(topology_setup_done == 1);
+
+	switch (aff_lvl) {
+	case 3:
+	case 2:
+		/* Report affinity levels 2 & 3 as absent */
+		break;
+	case 1:
+		aff_state = rcar_aff1_topology_map[idx].state;
+		break;
+	case 0:
+		/*
+		 * First get start index of the aff0 in its array & then add
+		 * to it the affinity id that we want the state of
+		 */
+		idx = rcar_aff1_topology_map[idx].child;
+		idx += (mpidr >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+		aff_state = rcar_aff0_topology_map[idx].state;
+		break;
+	default:
+		assert(0);
+	}
+
+	return aff_state;
+}
+
+/*******************************************************************************
+ * This function populates the RCAR specific topology information depending upon
+ * the RCAR flavour its running on. We construct all the mpidrs we can handle
+ * and rely on the PRR to flag absent cpus when their status is queried.
+ ******************************************************************************/
+void rcar_setup_topology(void)
+{
+	unsigned char aff0, aff1, aff_state, aff0_offset = 0;
+	unsigned long mpidr;
+
+	topology_setup_done = 0;
+
+	for (aff1 = 0; aff1 < PLATFORM_CLUSTER_COUNT; aff1++) {
+
+		rcar_aff1_topology_map[aff1].child = aff0_offset;
+		rcar_aff1_topology_map[aff1].sibling = aff1 + 1;
+
+		for (aff0 = 0; aff0 < PLATFORM_MAX_CPUS_PER_CLUSTER; aff0++) {
+
+			mpidr = aff1 << MPIDR_AFF1_SHIFT;
+			mpidr |= aff0 << MPIDR_AFF0_SHIFT;
+
+			if (rcar_pwrc_status(mpidr) != RCAR_INVALID) {
+				/*
+				 * Presence of even a single aff0 indicates
+				 * presence of parent aff1 on the RCAR.
+				 */
+				aff_state = PSCI_AFF_PRESENT;
+				rcar_aff1_topology_map[aff1].state =
+					PSCI_AFF_PRESENT;
+			} else {
+				aff_state = PSCI_AFF_ABSENT;
+			}
+
+			rcar_aff0_topology_map[aff0_offset].child = AFFINST_INVAL;
+			rcar_aff0_topology_map[aff0_offset].state = aff_state;
+			rcar_aff0_topology_map[aff0_offset].sibling =
+				aff0_offset + 1;
+
+			/* Increment the absolute number of aff0s traversed */
+			aff0_offset++;
+		}
+
+		/* Tie-off the last aff0 sibling to -1 to avoid overflow */
+		rcar_aff0_topology_map[aff0_offset - 1].sibling = AFFINST_INVAL;
+	}
+
+	/* Tie-off the last aff1 sibling to AFFINST_INVAL to avoid overflow */
+	rcar_aff1_topology_map[aff1 - 1].sibling = AFFINST_INVAL;
+
+	topology_setup_done = 1;
+}
diff --git a/plat/renesas/rcar/rcar_version.h b/plat/renesas/rcar/rcar_version.h
new file mode 100644
index 0000000..6d4e23a
--- /dev/null
+++ b/plat/renesas/rcar/rcar_version.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	RCAR_VERSION_H__
+#define	RCAR_VERSION_H__
+
+#include	<arch_helpers.h>
+
+#define		VERSION_OF_RENESAS	"1.0.7"
+
+extern const uint8_t	version_of_renesas[];
+
+#endif	/* RCAR_VERSION_H__	*/
diff --git a/services/spd/opteed/opteed_main.c b/services/spd/opteed/opteed_main.c
index fefc8a7..6e58173 100644
--- a/services/spd/opteed/opteed_main.c
+++ b/services/spd/opteed/opteed_main.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2015, ARM Limited and Contributors. All rights reserved.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -153,7 +154,7 @@ int32_t opteed_setup(void)
 	 * state i.e whether AArch32 or AArch64. Assuming it's AArch32
 	 * for the time being.
 	 */
-	opteed_rw = OPTEE_AARCH32;
+	opteed_rw = OPTEE_AARCH64;
 	opteed_init_optee_ep_state(optee_ep_info,
 				opteed_rw,
 				optee_ep_info->pc,
diff --git a/tools/dummy_create/makefile b/tools/dummy_create/makefile
new file mode 100644
index 0000000..4f40932
--- /dev/null
+++ b/tools/dummy_create/makefile
@@ -0,0 +1,103 @@
+#
+# Copyright (c) 2015-2016, Renesas Electronics Corporation
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+#   - Redistributions of source code must retain the above copyright notice,
+#     this list of conditions and the following disclaimer.
+#
+#   - Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#
+#   - Neither the name of Renesas nor the names of its contributors may be
+#     used to endorse or promote products derived from this software without
+#     specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+###################################################
+# makefile
+###################################################
+
+#output file name
+FILE_NAME_SA0   = bootparam_sa0
+FILE_NAME_SA6   = cert_header_sa6
+
+OUTPUT_FILE_SA0 = $(FILE_NAME_SA0).elf
+OUTPUT_FILE_SA6 = $(FILE_NAME_SA6).elf
+
+#object file name
+OBJ_FILE_SA0 =	sa0.o
+OBJ_FILE_SA6 =	sa6.o
+
+#linker script name 
+MEMORY_DEF_SA0 = sa0.ld.S
+MEMORY_DEF_SA6 = sa6.ld.S
+
+###################################################
+
+#c compiler
+CC = $(CROSS_COMPILE)gcc
+
+#Linker
+LD = $(CROSS_COMPILE)ld
+
+#objcopy
+objcopy = $(CROSS_COMPILE)objcopy
+
+#clean
+CL = rm -f
+
+###################################################
+.SUFFIXES : .s .c .o
+
+###################################################
+# command
+
+.PHONY: all
+all: $(OUTPUT_FILE_SA0) $(OUTPUT_FILE_SA6)
+###################################################
+# Linker
+###################################################
+$(OUTPUT_FILE_SA0) : $(MEMORY_DEF_SA0) $(OBJ_FILE_SA0)
+	$(LD) $(OBJ_FILE_SA0)		 	\
+	-T $(MEMORY_DEF_SA0)			\
+	-o $(OUTPUT_FILE_SA0)			\
+	-Map $(FILE_NAME_SA0).map 		\
+
+	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).srec
+	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA0) $(FILE_NAME_SA0).bin
+
+$(OUTPUT_FILE_SA6) : $(MEMORY_DEF_SA6) $(OBJ_FILE_SA6)
+	$(LD) $(OBJ_FILE_SA6)		 	\
+	-T $(MEMORY_DEF_SA6)			\
+	-o $(OUTPUT_FILE_SA6)			\
+	-Map $(FILE_NAME_SA6).map 		\
+
+	$(objcopy) -O srec --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).srec
+	$(objcopy) -O binary --adjust-vma=0xE6320000 --srec-forceS3  $(OUTPUT_FILE_SA6) $(FILE_NAME_SA6).bin
+
+###################################################
+# Compile
+###################################################
+
+%.o:../%.c
+	$(CC) -c -I $< -o $@
+
+.PHONY: clean
+clean:
+	$(CL)  *.bin *.map *.srec *.elf *.o
diff --git a/tools/dummy_create/sa0.c b/tools/dummy_create/sa0.c
new file mode 100644
index 0000000..9f0cb10
--- /dev/null
+++ b/tools/dummy_create/sa0.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/* SA0 */
+/* 0x00000000 */
+const unsigned int __attribute__ ((section (".sa0_bootrom"))) bootrom_paramA = 0x00000100;
+/* 0x00000C00 */
+/* 0x00000D54 */
+const unsigned int __attribute__ ((section (".sa0_bl2cert_addr"))) bl2cert_addr = 0xE6302000;
+/* 0x00000E64 */
+const unsigned int __attribute__ ((section (".sa0_bl2cert_size"))) bl2cert_size = 0x00008000;
+
diff --git a/tools/dummy_create/sa0.ld.S b/tools/dummy_create/sa0.ld.S
new file mode 100644
index 0000000..55a0eee
--- /dev/null
+++ b/tools/dummy_create/sa0.ld.S
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+SECTIONS
+{
+	. = 0x00000000;
+	.rodata : {
+		KEEP(*(.sa0_bootrom))
+		. = 0x00000D54;
+		KEEP(*(.sa0_bl2cert_addr))
+		. = 0x00000E64;
+		KEEP(*(.sa0_bl2cert_size))
+	}
+
+}
diff --git a/tools/dummy_create/sa6.c b/tools/dummy_create/sa6.c
new file mode 100644
index 0000000..8b864ec
--- /dev/null
+++ b/tools/dummy_create/sa6.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/* SA6 */
+/* 0x00180000 */
+const unsigned int __attribute__ ((section (".sa6_image_num"))) image_num = 0x00000001;
+/* 0x00180004 */
+const unsigned int __attribute__ ((section (".sa6_start_addr_1"))) start_addr_1 = 0x00640000;
+/* 0x00180400 */
+/* 0x00180554 */
+const unsigned int __attribute__ ((section (".sa6_bl31cert_addr"))) bl31cert_addr = 0x44000000;
+/* 0x00180664 */
+const unsigned int __attribute__ ((section (".sa6_bl31cert_size"))) bl31cert_size = 0x00004000;
+/* 0x00180800 */
+/* 0x00180954 */
+const unsigned int __attribute__ ((section (".sa6_bl32cert_addr"))) bl32cert_addr = 0x44100000;
+/* 0x00180A64 */
+const unsigned int __attribute__ ((section (".sa6_bl32cert_size"))) bl32cert_size = 0x00020000;
+/* 0x00180C00 */
+/* 0x00180D54 */
+const unsigned int __attribute__ ((section (".sa6_bl33cert_addr"))) bl33cert_addr = 0x49000000;
+/* 0x00180E64 */
+const unsigned int __attribute__ ((section (".sa6_bl33cert_size"))) bl33cert_size = 0x00040000;
+
diff --git a/tools/dummy_create/sa6.ld.S b/tools/dummy_create/sa6.ld.S
new file mode 100644
index 0000000..98569cb
--- /dev/null
+++ b/tools/dummy_create/sa6.ld.S
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *   - Redistributions of source code must retain the above copyright notice,
+ *     this list of conditions and the following disclaimer.
+ *
+ *   - Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ *   - Neither the name of Renesas nor the names of its contributors may be
+ *     used to endorse or promote products derived from this software without
+ *     specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+SECTIONS
+{
+	. = 0x00000000;
+	.rodata : {
+		KEEP(*(.sa6_image_num))
+		. = 0x00000004;
+		KEEP(*(.sa6_start_addr_1))
+		. = 0x00000554;
+		KEEP(*(.sa6_bl31cert_addr))
+		. = 0x00000664;
+		KEEP(*(.sa6_bl31cert_size))
+		. = 0x00000954;
+		KEEP(*(.sa6_bl32cert_addr))
+		. = 0x00000A64;
+		KEEP(*(.sa6_bl32cert_size))
+		. = 0x00000D54;
+		KEEP(*(.sa6_bl33cert_addr))
+		. = 0x00000E64;
+		KEEP(*(.sa6_bl33cert_size))
+	}
+
+}
-- 
1.9.1

