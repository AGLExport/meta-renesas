From 41b02b2bd5058fbb75393924e71df1546c13033c Mon Sep 17 00:00:00 2001
From: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
Date: Thu, 27 Aug 2015 11:18:39 +0900
Subject: usb: ehci: rcar_gen3: Fix usb storage detect and read

Signed-off-by: Hiroyuki Yokoyama <hiroyuki.yokoyama.vx@renesas.com>
---
 arch/arm/include/asm/arch-rcar_gen3/ehci-rcar.h | 19 ++++++++---
 drivers/usb/host/ehci-rcar_gen3.c               | 45 ++++++++++++++++++++++---
 2 files changed, 55 insertions(+), 9 deletions(-)

diff --git a/arch/arm/include/asm/arch-rcar_gen3/ehci-rcar.h b/arch/arm/include/asm/arch-rcar_gen3/ehci-rcar.h
index 6b47a97..816d4ca 100644
--- a/arch/arm/include/asm/arch-rcar_gen3/ehci-rcar.h
+++ b/arch/arm/include/asm/arch-rcar_gen3/ehci-rcar.h
@@ -16,6 +16,7 @@
 #define EHCI_OFFSET	0x100		/* offset: 0100H */
 #define EHCI_SIZE	0x100
 #define AHB_OFFSET	0x200
+#define USB_CORE_OFFSET	0x300
 
 #define EHCI_USBCMD	(EHCI_OFFSET + 0x0020)
 
@@ -42,10 +43,11 @@
 #define MAX_BURST_LEN_INCR4	(2 << 0)
 #define MAX_BURST_LEN_SINGLE	(3 << 0)
 
-#define SMSTPCR7        0xE615014C
-#define SMSTPCR701      (1 << 1)	/* EHCI2 */
-#define SMSTPCR702      (1 << 2)	/* EHCI1 */
-#define SMSTPCR703      (1 << 3)	/* EHCI0 */
+#define SMSTPCR7	0xE615014C
+#define SMSTPCR701	(1 << 1)	/* EHCI2 */
+#define SMSTPCR702	(1 << 2)	/* EHCI1 */
+#define SMSTPCR703	(1 << 3)	/* EHCI0 */
+#define SMSTPCR704	(1 << 4)	/* HSUSB */
 
 /* Init AHB master and slave functions of the host logic */
 #define AHB_BUS_CTR_INIT 0
@@ -74,4 +76,13 @@ struct rmobile_ehci_reg {
 	u32 portsc;		/* portsc */
 };
 
+struct usb_core_reg {
+	u32 revid;
+	u32 regen_cg_ctrl;
+	u32 spd_ctrl;
+	u32 spd_rsm_timset;
+	u32 oc_timset;
+	u32 sbrn_fladj_pw;
+};
+
 #endif /* __EHCI_RCAR_H__ */
diff --git a/drivers/usb/host/ehci-rcar_gen3.c b/drivers/usb/host/ehci-rcar_gen3.c
index 34aacf2..142c416 100644
--- a/drivers/usb/host/ehci-rcar_gen3.c
+++ b/drivers/usb/host/ehci-rcar_gen3.c
@@ -13,6 +13,17 @@
 #include <asm/arch/ehci-rcar.h>
 #include "ehci.h"
 
+#define BASE_HSUSB	0xE6590000
+#define REG_LPSTS	(BASE_HSUSB + 0x0102)	/* 16bit */
+#define SUSPM		0x4000
+#define SUSPM_SUSPEND	0x0000
+#define SUSPM_NORMAL	0x4000
+#define REG_UGCTRL2	(BASE_HSUSB + 0x0184)	/* 32bit */
+#define USB0SEL		0x00000030
+#define USB0SEL_EHCI	0x00000010
+#define USB0SEL_HSUSB	0x00000020
+#define USB0SEL_OTG	0x00000030
+
 static u32 usb_base_address[] = {
 	0xEE080000,	/* USB0 (EHCI) */
 	0xEE0A0000,	/* USB1 (EHCI) */
@@ -23,6 +34,7 @@ int ehci_hcd_stop(int index)
 {
 	int i;
 	u32 base = usb_base_address[index];
+	u32 val;
 
 	/* reset ehci */
 	setbits_le32((uintptr_t)(base + EHCI_USBCMD), CMD_RESET);
@@ -42,13 +54,22 @@ int ehci_hcd_stop(int index)
 	case 1:
 		setbits_le32(SMSTPCR7, SMSTPCR702);
 		break;
+#ifdef CONFIG_TARGET_SALVATORX
 	case 2:
 		setbits_le32(SMSTPCR7, SMSTPCR701);
 		break;
+#endif
 	default:
 		return -EINVAL;
 	}
-
+	val = readl(SMSTPCR7) & (SMSTPCR703 | SMSTPCR702 | SMSTPCR701);
+#ifdef CONFIG_TARGET_SALVATORX
+	if (val == (SMSTPCR703 | SMSTPCR702 | SMSTPCR701)) {
+#else
+	if (val == (SMSTPCR703 | SMSTPCR702)) {
+#endif
+		setbits_le32(SMSTPCR7, SMSTPCR704);
+	}
 	return 0;
 }
 
@@ -58,6 +79,7 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 	u32 base;
 	struct rmobile_ehci_reg *rehci;
 	struct ahb_bridge *ahb;
+	struct usb_core_reg *ucore;
 	uint32_t cap_base;
 
 	base = usb_base_address[index];
@@ -68,24 +90,37 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 	case 1:
 		clrbits_le32(SMSTPCR7, SMSTPCR702);
 		break;
+#ifdef CONFIG_TARGET_SALVATORX
 	case 2:
 		clrbits_le32(SMSTPCR7, SMSTPCR701);
 		break;
+#endif
 	default:
 		return -EINVAL;
 	}
+	clrbits_le32(SMSTPCR7, SMSTPCR704);
 
 	rehci = (struct rmobile_ehci_reg *)(uintptr_t)(base + EHCI_OFFSET);
 	ahb = (struct ahb_bridge *)(uintptr_t)(base + AHB_OFFSET);
+	ucore = (struct usb_core_reg *)(uintptr_t)(base + USB_CORE_OFFSET);
 
-	/* underconstruction */
+	*hccr = (struct ehci_hccr *)((uintptr_t)&rehci->hciversion);
+	cap_base = ehci_readl(&(*hccr)->cr_capbase);
+	*hcor = (struct ehci_hcor *)((uintptr_t)*hccr + HC_LENGTH(cap_base));
 
 	/* Enable interrupt */
 	setbits_le32(&ahb->int_enable, USBH_INTBEN | USBH_INTAEN);
+	writel(0x014e029b, &ucore->spd_rsm_timset);
+	writel(0x000209ab, &ucore->oc_timset);
 
-	*hccr = (struct ehci_hccr *)((uintptr_t)&rehci->hciversion);
-	cap_base = ehci_readl(&(*hccr)->cr_capbase);
-	*hcor = (struct ehci_hcor *)((uintptr_t)*hccr + HC_LENGTH(cap_base));
+	/* Choice USB0SEL */
+	clrsetbits_le32(REG_UGCTRL2, USB0SEL, USB0SEL_EHCI);
+
+	/* Clock & Reset */
+	clrbits_le32(&ahb->usbctr, PLL_RST);
+
+	/* low power status */
+	clrsetbits_le16(REG_LPSTS, SUSPM, SUSPM_NORMAL);
 
 	return 0;
 }
-- 
1.8.3.2

