From 7c7560a1a04e264405709c1076decc19b649bee4 Mon Sep 17 00:00:00 2001
From: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
Date: Fri, 17 May 2013 19:46:14 +0900
Subject: h2 bsp v 0 2 0


Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 arch/arm/boot/dts/r8a7790-lager.dts           |    3 +-
 arch/arm/boot/dts/r8a7790.dtsi                |   40 +-
 arch/arm/configs/shmobile_defconfig           |   50 +-
 arch/arm/mach-shmobile/Kconfig                |    1 +
 arch/arm/mach-shmobile/Makefile               |    4 +-
 arch/arm/mach-shmobile/board-lager.c          |   29 +-
 arch/arm/mach-shmobile/clock-r8a7790.c        |  268 +++-
 arch/arm/mach-shmobile/include/mach/common.h  |    8 +
 arch/arm/mach-shmobile/include/mach/r8a7790.h |  225 +++
 arch/arm/mach-shmobile/intc-r8a7790.c         |   48 +
 arch/arm/mach-shmobile/pm-r8a7790.c           |  232 +++
 arch/arm/mach-shmobile/setup-r8a7790.c        | 1271 +++++++++++++++
 arch/arm/mach-shmobile/smp-r8a7790.c          |  143 ++
 drivers/dma/Kconfig                           |   46 +-
 drivers/dma/sh/Makefile                       |    5 +-
 drivers/dma/sh/audma-pp.c                     |  337 ++++
 drivers/dma/sh/audma-pp.h                     |   65 +
 drivers/dma/sh/shdma-desc.c                   |  910 +++++++++++
 drivers/dma/sh/shdma-desc.h                   |   99 ++
 drivers/dma/sh/shdmapp-base.c                 |  245 +++
 drivers/gpu/drm/drm_fb_cma_helper.c           |   11 +-
 drivers/gpu/drm/drm_fb_helper.c               |   31 +-
 drivers/gpu/drm/drm_irq.c                     |    1 +
 drivers/gpu/drm/rcar-du/Kconfig               |   21 +
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c        |  125 +-
 drivers/gpu/drm/rcar-du/rcar_du_drv.c         |   96 ++
 drivers/gpu/drm/rcar-du/rcar_du_drv.h         |    5 +
 drivers/gpu/drm/rcar-du/rcar_du_kms.c         |    8 +-
 drivers/gpu/drm/rcar-du/rcar_du_lvds.c        |    8 +-
 drivers/gpu/drm/rcar-du/rcar_du_plane.c       |   11 +-
 drivers/gpu/drm/rcar-du/rcar_du_regs.h        |   19 +
 drivers/i2c/busses/i2c-rcar.c                 |   11 +-
 drivers/irqchip/irq-gic.c                     |    2 +
 drivers/mmc/card/block.c                      |    6 +
 drivers/mmc/core/Kconfig                      |   14 +
 drivers/mmc/core/Makefile                     |    1 +
 drivers/mmc/core/bus.c                        |   12 +
 drivers/mmc/core/core.c                       |    8 +
 drivers/mmc/core/lock.c                       |  191 +++
 drivers/mmc/core/lock.h                       |   42 +
 drivers/mmc/core/mmc.c                        |   17 +-
 drivers/mmc/core/mmc_ops.c                    |  128 ++
 drivers/mmc/core/mmc_ops.h                    |    5 +
 drivers/mmc/core/sd.c                         |   56 +-
 drivers/mmc/host/sh_mobile_sdhi.c             |   34 +
 drivers/mmc/host/tmio_mmc_dma.c               |   66 +-
 drivers/mmc/host/tmio_mmc_pio.c               |   57 +-
 drivers/mtd/devices/Kconfig                   |   19 +-
 drivers/mtd/devices/m25p80.c                  |  101 +-
 drivers/net/ethernet/renesas/Kconfig          |    3 +-
 drivers/net/ethernet/renesas/sh_eth.c         |   16 +-
 drivers/net/ethernet/renesas/sh_eth.h         |    7 +
 drivers/pinctrl/sh-pfc/pfc-r8a7790.c          |  172 ++
 drivers/spi/Kconfig                           |    5 +
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-qspi.c                        | 1279 +++++++++++++++
 drivers/usb/Kconfig                           |    2 +
 include/drm/drm_fb_cma_helper.h               |    2 +-
 include/drm/drm_fb_helper.h                   |    2 +
 include/linux/i2c/i2c-rcar.h                  |    3 +
 include/linux/mfd/tmio.h                      |   18 +
 include/linux/mmc/card.h                      |    3 +
 include/linux/mmc/host.h                      |    1 +
 include/linux/mmc/mmc.h                       |    8 +
 include/linux/mmc/sh_mobile_sdhi.h            |    1 +
 include/linux/sh_audma-pp.h                   |   58 +
 include/linux/sh_dma-desc.h                   |   75 +
 include/linux/shdmapp-base.h                  |   35 +
 include/sound/sh_scu.h                        | 2086 +++++++++++++++++++++++++
 sound/soc/sh/Kconfig                          |   32 +
 sound/soc/sh/Makefile                         |    4 +
 sound/soc/sh/lager.c                          |  682 ++++++++
 sound/soc/sh/scu_dai.c                        |  984 ++++++++++++
 sound/soc/sh/scu_pcm.c                        |  746 +++++++++
 74 files changed, 11261 insertions(+), 99 deletions(-)
 create mode 100644 arch/arm/mach-shmobile/intc-r8a7790.c
 create mode 100644 arch/arm/mach-shmobile/pm-r8a7790.c
 create mode 100644 arch/arm/mach-shmobile/smp-r8a7790.c
 create mode 100644 drivers/dma/sh/audma-pp.c
 create mode 100644 drivers/dma/sh/audma-pp.h
 create mode 100644 drivers/dma/sh/shdma-desc.c
 create mode 100644 drivers/dma/sh/shdma-desc.h
 create mode 100644 drivers/dma/sh/shdmapp-base.c
 create mode 100644 drivers/mmc/core/lock.c
 create mode 100644 drivers/mmc/core/lock.h
 create mode 100644 drivers/spi/spi-qspi.c
 create mode 100644 include/linux/sh_audma-pp.h
 create mode 100644 include/linux/sh_dma-desc.h
 create mode 100644 include/linux/shdmapp-base.h
 create mode 100644 include/sound/sh_scu.h
 create mode 100644 sound/soc/sh/lager.c
 create mode 100644 sound/soc/sh/scu_dai.c
 create mode 100644 sound/soc/sh/scu_pcm.c

diff --git a/arch/arm/boot/dts/r8a7790-lager.dts b/arch/arm/boot/dts/r8a7790-lager.dts
index 09a84fc..646ef5a 100644
--- a/arch/arm/boot/dts/r8a7790-lager.dts
+++ b/arch/arm/boot/dts/r8a7790-lager.dts
@@ -1,6 +1,7 @@
 /*
  * Device Tree Source for the Lager board
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright (C) 2013 Renesas Solutions Corp.
  *
  * This file is licensed under the terms of the GNU General Public License
@@ -16,7 +17,7 @@
 	compatible = "renesas,lager", "renesas,r8a7790";
 
 	chosen {
-		bootargs = "console=ttySC6,115200 ignore_loglevel";
+		bootargs = "console=ttySC6,38400 mem=768M ip=dhcp root=/dev/nfs ignore_loglevel";
 	};
 
 	memory@40000000 {
diff --git a/arch/arm/boot/dts/r8a7790.dtsi b/arch/arm/boot/dts/r8a7790.dtsi
index 7a17110..0b91ff9 100644
--- a/arch/arm/boot/dts/r8a7790.dtsi
+++ b/arch/arm/boot/dts/r8a7790.dtsi
@@ -1,6 +1,7 @@
 /*
  * Device Tree Source for the r8a7790 SoC
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright (C) 2013 Renesas Solutions Corp.
  *
  * This file is licensed under the terms of the GNU General Public License
@@ -24,6 +25,27 @@
 			reg = <0>;
 			clock-frequency = <1300000000>;
 		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <1>;
+			clock-frequency = <1300000000>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <2>;
+			clock-frequency = <1300000000>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <3>;
+			clock-frequency = <1300000000>;
+		};
 	};
 
 	gic: interrupt-controller@f1001000 {
@@ -42,7 +64,22 @@
 			cpuif-id = <4>;
 			cpu = <&cpu0>;
 		};
-	};
+		gic-cpuif@5 {
+			compatible = "arm,gic-cpuif";
+			cpuif-id = <5>;
+			cpu = <&cpu1>;
+		};
+		gic-cpuif@6 {
+			compatible = "arm,gic-cpuif";
+			cpuif-id = <6>;
+			cpu = <&cpu2>;
+		};
+		gic-cpuif@7 {
+			compatible = "arm,gic-cpuif";
+			cpuif-id = <7>;
+			cpu = <&cpu3>;
+		};
+};
 
 	timer {
 		compatible = "arm,armv7-timer";
@@ -50,6 +87,7 @@
 				<1 14 0xf08>,
 				<1 11 0xf08>,
 				<1 10 0xf08>;
+		clock-frequency = <10000000>;
 	};
 
 	irqc0: interrupt-controller@e61c0000 {
diff --git a/arch/arm/configs/shmobile_defconfig b/arch/arm/configs/shmobile_defconfig
index 7dba53f..be0978d 100644
--- a/arch/arm/configs/shmobile_defconfig
+++ b/arch/arm/configs/shmobile_defconfig
@@ -1,3 +1,4 @@
+CONFIG_EXPERIMENTAL=y
 CONFIG_SYSVIPC=y
 CONFIG_NO_HZ=y
 CONFIG_IKCONFIG=y
@@ -8,19 +9,17 @@ CONFIG_SYSCTL_SYSCALL=y
 CONFIG_EMBEDDED=y
 CONFIG_PERF_EVENTS=y
 CONFIG_SLAB=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
 # CONFIG_BLK_DEV_BSG is not set
 # CONFIG_IOSCHED_DEADLINE is not set
 # CONFIG_IOSCHED_CFQ is not set
 CONFIG_ARCH_SHMOBILE=y
-CONFIG_ARCH_SH7372=y
-CONFIG_ARCH_R8A7740=y
 CONFIG_ARCH_R8A7790=y
-CONFIG_ARCH_EMEV2=y
-CONFIG_MACH_MACKEREL=y
-CONFIG_MACH_ARMADILLO800EVA=y
 CONFIG_MACH_LAGER=y
-CONFIG_MACH_KZM9D=y
+CONFIG_SHMOBILE_TIMER_HZ=100
 # CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
 # CONFIG_SWP_EMULATE is not set
 CONFIG_ARM_ERRATA_430973=y
 CONFIG_ARM_ERRATA_458693=y
@@ -35,8 +34,8 @@ CONFIG_ARM_ERRATA_754322=y
 CONFIG_PL310_ERRATA_769419=y
 CONFIG_ARM_ERRATA_775420=y
 CONFIG_SMP=y
-CONFIG_NR_CPUS=2
-# CONFIG_LOCAL_TIMERS is not set
+CONFIG_NR_CPUS=4
+CONFIG_LOCAL_TIMERS=y
 CONFIG_AEABI=y
 # CONFIG_OABI_COMPAT is not set
 CONFIG_FORCE_MAX_ZONEORDER=13
@@ -54,6 +53,7 @@ CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
+CONFIG_EXT2_FS=y
 # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
 # CONFIG_INET_XFRM_MODE_TUNNEL is not set
 # CONFIG_INET_XFRM_MODE_BEET is not set
@@ -62,14 +62,23 @@ CONFIG_IP_PNP_DHCP=y
 # CONFIG_IPV6 is not set
 # CONFIG_WIRELESS is not set
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_REGMAP_SPI=y
 CONFIG_MTD=y
+CONFIG_MTD_OF_PARTS=y
 CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
 CONFIG_MTD_CFI=y
 CONFIG_MTD_CFI_ADV_OPTIONS=y
 CONFIG_MTD_CFI_INTELEXT=y
 CONFIG_MTD_PHYSMAP=y
 CONFIG_MTD_BLOCK2MTD=y
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_QUAD_READ=y
+CONFIG_OF_SPI=y
+CONFIG_OF_MTD=y
 CONFIG_SCSI=y
 CONFIG_BLK_DEV_SD=y
 CONFIG_MD=y
@@ -103,9 +112,16 @@ CONFIG_SERIAL_SH_SCI_NR_UARTS=8
 CONFIG_SERIAL_SH_SCI_CONSOLE=y
 # CONFIG_HW_RANDOM is not set
 CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_GPIO=y
 CONFIG_I2C_SH_MOBILE=y
+CONFIG_I2C_RCAR=y
 CONFIG_GPIO_EM=y
+CONFIG_DRM=y
+CONFIG_DRM_RCAR_DU=y
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_QSPI=y
 # CONFIG_HWMON is not set
 CONFIG_REGULATOR=y
 CONFIG_MEDIA_SUPPORT=y
@@ -127,7 +143,14 @@ CONFIG_LOGO=y
 # CONFIG_SND_DRIVERS is not set
 # CONFIG_SND_ARM is not set
 CONFIG_SND_SOC_SH4_FSI=y
+CONFIG_SND_SOC_SCU=y
+CONFIG_SND_SCU_LAGER=y
 CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
 CONFIG_USB_RENESAS_USBHS_HCD=y
 CONFIG_USB_RENESAS_USBHS=y
 CONFIG_USB_STORAGE=y
@@ -135,19 +158,28 @@ CONFIG_USB_GADGET=y
 CONFIG_USB_RENESAS_USBHS_UDC=y
 CONFIG_USB_ETH=y
 CONFIG_MMC=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_PASSWORDS=y
 CONFIG_MMC_SDHI=y
 CONFIG_MMC_SH_MMCIF=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_DRV_S35390A=y
 CONFIG_DMADEVICES=y
+CONFIG_SH_DMAE_BASE=y
 CONFIG_SH_DMAE=y
+CONFIG_SH_DMAE_DESC=y
+CONFIG_SH_DMAEPP_BASE=y
+CONFIG_SH_DMAEPP_AUPP=y
 CONFIG_UIO=y
 CONFIG_UIO_PDRV_GENIRQ=y
 # CONFIG_DNOTIFY is not set
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 403159f..b5f3b2d 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -114,6 +114,7 @@ config MACH_MARZEN
 config MACH_LAGER
 	bool "Lager board"
 	depends on ARCH_R8A7790
+	select ARCH_REQUIRE_GPIOLIB
 	select USE_OF
 
 config MACH_KZM9D
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index a4401cc..5306c8a 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -10,7 +10,7 @@ obj-$(CONFIG_ARCH_SH7372)	+= setup-sh7372.o clock-sh7372.o intc-sh7372.o
 obj-$(CONFIG_ARCH_SH73A0)	+= setup-sh73a0.o clock-sh73a0.o intc-sh73a0.o
 obj-$(CONFIG_ARCH_R8A7740)	+= setup-r8a7740.o clock-r8a7740.o intc-r8a7740.o
 obj-$(CONFIG_ARCH_R8A7779)	+= setup-r8a7779.o clock-r8a7779.o intc-r8a7779.o
-obj-$(CONFIG_ARCH_R8A7790)	+= setup-r8a7790.o clock-r8a7790.o
+obj-$(CONFIG_ARCH_R8A7790)	+= setup-r8a7790.o clock-r8a7790.o intc-r8a7790.o
 obj-$(CONFIG_ARCH_EMEV2)	+= setup-emev2.o clock-emev2.o
 
 # SMP objects
@@ -19,6 +19,7 @@ smp-$(CONFIG_HOTPLUG_CPU)	+= hotplug.o
 smp-$(CONFIG_ARCH_SH73A0)	+= smp-sh73a0.o
 smp-$(CONFIG_ARCH_R8A7779)	+= smp-r8a7779.o
 smp-$(CONFIG_ARCH_EMEV2)	+= smp-emev2.o
+smp-$(CONFIG_ARCH_R8A7790)	+= smp-r8a7790.o
 
 # IRQ objects
 obj-$(CONFIG_ARCH_SH7372)	+= entry-intc.o
@@ -31,6 +32,7 @@ obj-$(CONFIG_ARCH_SHMOBILE)	+= pm-rmobile.o
 obj-$(CONFIG_ARCH_SH7372)	+= pm-sh7372.o sleep-sh7372.o
 obj-$(CONFIG_ARCH_R8A7740)	+= pm-r8a7740.o
 obj-$(CONFIG_ARCH_R8A7779)	+= pm-r8a7779.o
+obj-$(CONFIG_ARCH_R8A7790)	+= pm-r8a7790.o
 
 # Board objects
 obj-$(CONFIG_MACH_G3EVM)	+= board-g3evm.o
diff --git a/arch/arm/mach-shmobile/board-lager.c b/arch/arm/mach-shmobile/board-lager.c
index c8a64b1..69139ed 100644
--- a/arch/arm/mach-shmobile/board-lager.c
+++ b/arch/arm/mach-shmobile/board-lager.c
@@ -1,6 +1,7 @@
 /*
  * Lager board support
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright (C) 2013  Renesas Solutions Corp.
  * Copyright (C) 2013  Magnus Damm
  *
@@ -23,11 +24,16 @@
 #include <linux/kernel.h>
 #include <linux/pinctrl/machine.h>
 #include <linux/platform_device.h>
+#include <linux/i2c.h>
 #include <mach/common.h>
 #include <mach/r8a7790.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 
+static struct i2c_board_info lager_i2c_devices[] = {
+	{ I2C_BOARD_INFO("ak4642", 0x12), },
+};
+
 static const struct pinctrl_map lager_pinctrl_map[] = {
 	/* SCIF0 (CN19: DEBUG SERIAL0) */
 	PIN_MAP_MUX_GROUP_DEFAULT("sh-sci.6", "pfc-r8a7790",
@@ -35,6 +41,24 @@ static const struct pinctrl_map lager_pinctrl_map[] = {
 	/* SCIF1 (CN20: DEBUG SERIAL1) */
 	PIN_MAP_MUX_GROUP_DEFAULT("sh-sci.7", "pfc-r8a7790",
 				  "scif1_data", "scif1"),
+	/* SDHI0 */
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.0", "pfc-r8a7790",
+				  "sdhi0_data4", "sdhi0"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.0", "pfc-r8a7790",
+				  "sdhi0_ctrl", "sdhi0"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.0", "pfc-r8a7790",
+				  "sdhi0_cd", "sdhi0"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.0", "pfc-r8a7790",
+				  "sdhi0_wp", "sdhi0"),
+	/* SDHI2 */
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.2", "pfc-r8a7790",
+				  "sdhi2_data4", "sdhi2"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.2", "pfc-r8a7790",
+				  "sdhi2_ctrl", "sdhi2"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.2", "pfc-r8a7790",
+				  "sdhi2_cd", "sdhi2"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mobile_sdhi.2", "pfc-r8a7790",
+				  "sdhi2_wp", "sdhi2"),
 };
 
 static void __init lager_add_standard_devices(void)
@@ -46,6 +70,8 @@ static void __init lager_add_standard_devices(void)
 	r8a7790_pinmux_init();
 
 	r8a7790_add_standard_devices();
+	i2c_register_board_info(2, lager_i2c_devices,
+				ARRAY_SIZE(lager_i2c_devices));
 }
 
 static const char *lager_boards_compat_dt[] __initdata = {
@@ -54,7 +80,8 @@ static const char *lager_boards_compat_dt[] __initdata = {
 };
 
 DT_MACHINE_START(LAGER_DT, "lager")
-	.init_irq	= irqchip_init,
+	.smp		= smp_ops(r8a7790_smp_ops),
+	.init_irq	= r8a7790_init_irq,
 	.timer		= &r8a7790_timer,
 	.init_machine	= lager_add_standard_devices,
 	.dt_compat	= lager_boards_compat_dt,
diff --git a/arch/arm/mach-shmobile/clock-r8a7790.c b/arch/arm/mach-shmobile/clock-r8a7790.c
index bad9bf2..8235a17 100644
--- a/arch/arm/mach-shmobile/clock-r8a7790.c
+++ b/arch/arm/mach-shmobile/clock-r8a7790.c
@@ -1,6 +1,7 @@
 /*
  * r8a7790 clock framework support
  *
+ * Copyright (C) 2013  Renesas Electronics Corporation
  * Copyright (C) 2013  Renesas Solutions Corp.
  * Copyright (C) 2013  Magnus Damm
  *
@@ -10,7 +11,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -27,43 +28,226 @@
 #define CPG_BASE 0xe6150000
 #define CPG_LEN 0x1000
 
-#define SMSTPCR2 0xe6150138
-#define SMSTPCR7 0xe615014c
+#define SMSTPCR1	0xE6150134
+#define SMSTPCR2	0xe6150138
+#define SMSTPCR3	0xE615013C
+#define SMSTPCR5	0xE6150144
+#define SMSTPCR7	0xe615014c
+#define SMSTPCR9	0xE6150994
+#define SMSTPCR10	0xE6150998
+
+#define SDCKCR		0xE6150074
+#define SD2CKCR		0xE6150078
+#define SD3CKCR		0xE615007C
 
 static struct clk_mapping cpg_mapping = {
-	.phys   = CPG_BASE,
-	.len    = CPG_LEN,
+	.phys	= CPG_BASE,
+	.len	= CPG_LEN,
+};
+
+static unsigned long d12_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 12;
+}
+
+static unsigned long d4_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 4;
+}
+
+static unsigned long d3_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 3;
+}
+
+static unsigned long d2_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 2;
+}
+
+static struct sh_clk_ops d12_clk_ops = {
+	.recalc		= d12_recalc,
 };
 
-static struct clk p_clk = {
-	.rate	= 65000000, /* shortcut for now */
+static struct sh_clk_ops d4_clk_ops = {
+	.recalc		= d4_recalc,
+};
+
+static struct sh_clk_ops d3_clk_ops = {
+	.recalc		= d3_recalc,
+};
+
+static struct sh_clk_ops d2_clk_ops = {
+	.recalc		= d2_recalc,
+};
+
+static struct clk extal_clk = {
+	.rate		= 30000000,
+	.mapping	= &cpg_mapping,
+};
+
+static struct clk pll1_clk = {
+	.rate		= 3120000000,
 	.mapping	= &cpg_mapping,
 };
 
+static struct clk pll1_d2_clk = {
+	.ops		= &d2_clk_ops,
+	.parent		= &pll1_clk,
+};
+
+static struct clk pll1_d4_clk = {
+	.ops		= &d4_clk_ops,
+	.parent		= &pll1_clk,
+};
+
+static struct clk zg_clk = {
+	.ops		= &d3_clk_ops,
+	.parent		= &pll1_d2_clk,
+};
+
+static struct clk hp_clk = {
+	.ops		= &d12_clk_ops,
+	.parent		= &pll1_d2_clk,
+};
+
+static struct clk qspi_clk = {
+	.rate		= 97500000,
+};
+
 static struct clk mp_clk = {
-	.rate	= 52000000,  /* shortcut for now */
+	.rate		= 52000000,
 	.mapping	= &cpg_mapping,
 };
 
+static struct clk cp_clk = {
+	.ops		= &d2_clk_ops,
+	.parent		= &extal_clk,
+};
+
 static struct clk *main_clks[] = {
-	&p_clk,
+	&extal_clk,
+	&pll1_clk,
+	&pll1_d2_clk,
+	&pll1_d4_clk,
+	&zg_clk,
+	&hp_clk,
+	&qspi_clk,
 	&mp_clk,
+	&cp_clk,
+};
+
+enum {
+	SD0, SD1,
+	SD01_NR };
+
+enum {
+	SD2, SD3,
+	SD23_NR };
+
+static int sd01_divisors[] = { 0, 0, 0, 0, 0, 12, 16, 18, 24, 0, 36, 48, 10};
+
+static struct clk_div_mult_table sd01_div_mult_table = {
+	.divisors = sd01_divisors,
+	.nr_divisors = ARRAY_SIZE(sd01_divisors),
+};
+
+static struct clk_div4_table div4_table = {
+	.div_mult_table = &sd01_div_mult_table,
+};
+
+#define SD_DIV(_parent, _reg, _shift, _flags)			\
+{								\
+	.parent = _parent,					\
+	.enable_reg = (void __iomem *)_reg,			\
+	.enable_bit = _shift,					\
+	.div_mask = SH_CLK_DIV_MSK(4),				\
+	.flags = _flags,					\
+}
+
+static struct clk sd01_clks[SD01_NR] = {
+	[SD0] = SD_DIV(&pll1_d2_clk, SDCKCR, 4, 0),
+	[SD1] = SD_DIV(&pll1_d2_clk, SDCKCR, 0, 0),
+};
+
+static struct clk sd23_clks[SD23_NR] = {
+	[SD2] = SH_CLK_DIV6(&pll1_d4_clk, SD2CKCR, 0),
+	[SD3] = SH_CLK_DIV6(&pll1_d4_clk, SD3CKCR, 0),
 };
 
-enum { MSTP721, MSTP720,
-	MSTP216, MSTP207, MSTP206, MSTP204, MSTP203, MSTP202, MSTP_NR };
+enum {
+	MSTP112,
+	MSTP216, MSTP207, MSTP206, MSTP204, MSTP203, MSTP202,
+	MSTP726, MSTP725, MSTP724, MSTP723, MSTP721, MSTP720, MSTP704, MSTP703,
+	MSTP314, MSTP313, MSTP312, MSTP311,
+	MSTP931, MSTP930, MSTP929, MSTP928, MSTP922, MSTP917,
+	MSTP502, MSTP501,
+	MSTP1031, MSTP1030, MSTP1019, MSTP1018, MSTP1017, MSTP1015, \
+	MSTP1014, MSTP1005,
+	MSTP_NR };
+
 static struct clk mstp_clks[MSTP_NR] = {
-	[MSTP721] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 21, 0), /* SCIF0 */
-	[MSTP720] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 20, 0), /* SCIF1 */
-	[MSTP216] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 16, 0), /* SCIFB2 */
-	[MSTP207] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 7, 0), /* SCIFB1 */
-	[MSTP206] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 6, 0), /* SCIFB0 */
-	[MSTP204] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 4, 0), /* SCIFA0 */
-	[MSTP203] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 3, 0), /* SCIFA1 */
-	[MSTP202] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 2, 0), /* SCIFA2 */
+	[MSTP112] = SH_CLK_MSTP32(&zg_clk, SMSTPCR1, 12, 0),
+	[MSTP216] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 16, 0),
+	[MSTP207] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 7, 0),
+	[MSTP206] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 6, 0),
+	[MSTP204] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 4, 0),
+	[MSTP203] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 3, 0),
+	[MSTP202] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 2, 0),
+	[MSTP726] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 26, 0),
+	[MSTP725] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 25, 0),
+	[MSTP314] = SH_CLK_MSTP32(&sd01_clks[SD0], SMSTPCR3, 14, 0),
+	[MSTP313] = SH_CLK_MSTP32(&sd01_clks[SD1], SMSTPCR3, 13, 0),
+	[MSTP312] = SH_CLK_MSTP32(&sd23_clks[SD2], SMSTPCR3, 12, 0),
+	[MSTP311] = SH_CLK_MSTP32(&sd23_clks[SD3], SMSTPCR3, 11, 0),
+	[MSTP502] = SH_CLK_MSTP32(&hp_clk, SMSTPCR5, 2, 0),
+	[MSTP501] = SH_CLK_MSTP32(&hp_clk, SMSTPCR5, 1, 0),
+	[MSTP724] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 24, 0),
+	[MSTP723] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 23, 0),
+	[MSTP721] = SH_CLK_MSTP32(&cp_clk, SMSTPCR7, 21, 0),
+	[MSTP720] = SH_CLK_MSTP32(&cp_clk, SMSTPCR7, 20, 0),
+	[MSTP704] = SH_CLK_MSTP32(&mp_clk, SMSTPCR7, 04, 0),
+	[MSTP703] = SH_CLK_MSTP32(&mp_clk, SMSTPCR7, 03, 0),
+	[MSTP917] = SH_CLK_MSTP32(&qspi_clk, SMSTPCR9, 17, 0),
+	[MSTP931] = SH_CLK_MSTP32(&hp_clk, SMSTPCR9, 31, 0),
+	[MSTP930] = SH_CLK_MSTP32(&hp_clk, SMSTPCR9, 30, 0),
+	[MSTP929] = SH_CLK_MSTP32(&hp_clk, SMSTPCR9, 29, 0),
+	[MSTP928] = SH_CLK_MSTP32(&hp_clk, SMSTPCR9, 28, 0),
+	[MSTP922] = SH_CLK_MSTP32(&hp_clk, SMSTPCR9, 22, 0),
+	[MSTP1031] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 31, 0),
+	[MSTP1030] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 30, 0),
+	[MSTP1019] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 19, 0),
+	[MSTP1018] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 18, 0),
+	[MSTP1017] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 17, 0),
+	[MSTP1015] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 15, 0),
+	[MSTP1014] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 14, 0),
+	[MSTP1005] = SH_CLK_MSTP32(&hp_clk, SMSTPCR10, 05, 0),
 };
 
 static struct clk_lookup lookups[] = {
+	/* main clocks */
+	CLKDEV_CON_ID("extal_clk", &extal_clk),
+	CLKDEV_CON_ID("pll1_clk", &pll1_clk),
+	CLKDEV_CON_ID("pll1_div2_clk", &pll1_d2_clk),
+	CLKDEV_CON_ID("pll1_div4_clk", &pll1_d4_clk),
+	CLKDEV_CON_ID("zg_clk", &zg_clk),
+	CLKDEV_CON_ID("hp_clk", &hp_clk),
+	CLKDEV_CON_ID("mp_clk", &mp_clk),
+	CLKDEV_CON_ID("cp_clk", &cp_clk),
+	CLKDEV_CON_ID("peripheral_clk", &hp_clk),
+
+	CLKDEV_DEV_ID("pvrsrvkm", &mstp_clks[MSTP112]),
+	CLKDEV_CON_ID("g6400", &mstp_clks[MSTP112]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP314]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[MSTP313]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.2", &mstp_clks[MSTP312]),
+	CLKDEV_DEV_ID("sh_mobile_sdhi.3", &mstp_clks[MSTP311]),
+	CLKDEV_CON_ID("audmac_lo", &mstp_clks[MSTP502]),
+	CLKDEV_CON_ID("audmac_up", &mstp_clks[MSTP501]),
+	CLKDEV_DEV_ID("rcar-du.0", &mstp_clks[MSTP724]),
+	CLKDEV_CON_ID("rcar-du.1", &mstp_clks[MSTP723]),
+	CLKDEV_CON_ID("lvds.0", &mstp_clks[MSTP726]),
+	CLKDEV_CON_ID("lvds.1", &mstp_clks[MSTP725]),
 	CLKDEV_DEV_ID("sh-sci.0", &mstp_clks[MSTP204]),
 	CLKDEV_DEV_ID("sh-sci.1", &mstp_clks[MSTP203]),
 	CLKDEV_DEV_ID("sh-sci.2", &mstp_clks[MSTP206]),
@@ -72,8 +256,46 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_DEV_ID("sh-sci.5", &mstp_clks[MSTP202]),
 	CLKDEV_DEV_ID("sh-sci.6", &mstp_clks[MSTP721]),
 	CLKDEV_DEV_ID("sh-sci.7", &mstp_clks[MSTP720]),
+	CLKDEV_CON_ID("hs_usb", &mstp_clks[MSTP704]),
+	CLKDEV_CON_ID("usb_fck", &mstp_clks[MSTP703]),
+	CLKDEV_DEV_ID("qspi.0", &mstp_clks[MSTP917]),
+	CLKDEV_DEV_ID("i2c-rcar.0", &mstp_clks[MSTP931]),
+	CLKDEV_DEV_ID("i2c-rcar.1", &mstp_clks[MSTP930]),
+	CLKDEV_DEV_ID("i2c-rcar.2", &mstp_clks[MSTP929]),
+	CLKDEV_DEV_ID("i2c-rcar.3", &mstp_clks[MSTP928]),
+	CLKDEV_DEV_ID("adg", &mstp_clks[MSTP922]),
+	CLKDEV_DEV_ID("src0", &mstp_clks[MSTP1031]),
+	CLKDEV_DEV_ID("src1", &mstp_clks[MSTP1030]),
+	CLKDEV_DEV_ID("dvc0", &mstp_clks[MSTP1019]),
+	CLKDEV_DEV_ID("dvc1", &mstp_clks[MSTP1018]),
+	CLKDEV_DEV_ID("scu-pcm-audio.0", &mstp_clks[MSTP1017]),
+	CLKDEV_DEV_ID("ssi0", &mstp_clks[MSTP1015]),
+	CLKDEV_DEV_ID("ssi1", &mstp_clks[MSTP1014]),
+	CLKDEV_DEV_ID("ssi", &mstp_clks[MSTP1005]),
+	CLKDEV_CON_ID("adg", &mstp_clks[MSTP922]),
+	CLKDEV_CON_ID("src0", &mstp_clks[MSTP1031]),
+	CLKDEV_CON_ID("src1", &mstp_clks[MSTP1030]),
+	CLKDEV_CON_ID("dvc0", &mstp_clks[MSTP1019]),
+	CLKDEV_CON_ID("dvc1", &mstp_clks[MSTP1018]),
+	CLKDEV_CON_ID("scu", &mstp_clks[MSTP1017]),
+	CLKDEV_CON_ID("ssi0", &mstp_clks[MSTP1015]),
+	CLKDEV_CON_ID("ssi1", &mstp_clks[MSTP1014]),
+	CLKDEV_CON_ID("ssi", &mstp_clks[MSTP1005]),
 };
 
+static void __init r8a7790_rgx_control_init(void)
+{
+	void __iomem *cpgp;
+	unsigned int val;
+
+#define RGXCR		0x0B4
+
+	cpgp = ioremap(CPG_BASE, PAGE_SIZE);
+	val = ioread32(cpgp + RGXCR);
+	iowrite32(val | (1 << 16), cpgp + RGXCR);
+	iounmap(cpgp);
+}
+
 void __init r8a7790_clock_init(void)
 {
 	int k, ret = 0;
@@ -82,6 +304,12 @@ void __init r8a7790_clock_init(void)
 		ret = clk_register(main_clks[k]);
 
 	if (!ret)
+		ret = sh_clk_div4_register(sd01_clks, SD01_NR, &div4_table);
+
+	if (!ret)
+		ret = sh_clk_div6_reparent_register(sd23_clks, SD23_NR);
+
+	if (!ret)
 		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
 
 	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
@@ -90,4 +318,6 @@ void __init r8a7790_clock_init(void)
 		shmobile_clk_init();
 	else
 		panic("failed to setup r8a7790 clocks\n");
+
+	r8a7790_rgx_control_init();
 }
diff --git a/arch/arm/mach-shmobile/include/mach/common.h b/arch/arm/mach-shmobile/include/mach/common.h
index 866e9f4..5e137c4 100644
--- a/arch/arm/mach-shmobile/include/mach/common.h
+++ b/arch/arm/mach-shmobile/include/mach/common.h
@@ -61,6 +61,14 @@ extern void r8a7740_meram_workaround(void);
 
 extern void r8a7779_register_twd(void);
 
+extern void r8a7790_init_irq(void);
+extern void r8a7790_map_io(void);
+extern void r8a7790_add_early_devices(void);
+extern void r8a7790_add_standard_devices(void);
+extern void r8a7790_clock_init(void);
+extern void r8a7790_pinmux_init(void);
+extern void r8a7790_pm_init(void);
+
 extern void shmobile_init_late(void);
 
 #ifdef CONFIG_SUSPEND
diff --git a/arch/arm/mach-shmobile/include/mach/r8a7790.h b/arch/arm/mach-shmobile/include/mach/r8a7790.h
index 52bfc30..af2e50d 100644
--- a/arch/arm/mach-shmobile/include/mach/r8a7790.h
+++ b/arch/arm/mach-shmobile/include/mach/r8a7790.h
@@ -2,11 +2,236 @@
 #define __ASM_R8A7790_H__
 
 #include <asm/mach/time.h>
+#include <linux/pm_domain.h>
+
+struct platform_device;
 
 void r8a7790_add_standard_devices(void);
 void r8a7790_clock_init(void);
 void r8a7790_pinmux_init(void);
 
 extern struct sys_timer r8a7790_timer;
+extern struct smp_operations r8a7790_smp_ops;
+
+struct r8a7790_pm_ch {
+	unsigned long chan_offs;
+	unsigned int chan_bit;
+	unsigned int isr_bit;
+};
+
+struct r8a7790_pm_domain {
+	struct generic_pm_domain genpd;
+	struct r8a7790_pm_ch ch;
+};
+
+static inline struct r8a7790_pm_ch *to_r8a7790_ch(struct generic_pm_domain *d)
+{
+	return &container_of(d, struct r8a7790_pm_domain, genpd)->ch;
+}
+
+extern int r8a7790_sysc_power_down(struct r8a7790_pm_ch *r8a7790_ch);
+extern int r8a7790_sysc_power_up(struct r8a7790_pm_ch *r8a7790_ch);
+
+#ifdef CONFIG_PM
+extern struct r8a7790_pm_domain r8a7790_rgx;
+
+extern void r8a7790_init_pm_domain(struct r8a7790_pm_domain *r8a7790_pd);
+extern void r8a7790_add_device_to_domain(struct r8a7790_pm_domain *r8a7790_pd,
+					 struct platform_device *pdev);
+#else
+#define r8a7790_init_pm_domain(pd) do { } while (0)
+#define r8a7790_add_device_to_domain(pd, pdev) do { } while (0)
+#endif /* CONFIG_PM */
+
+/* USB Host */
+#define SHUSBH_MAX_CH		3
+
+#define SHUSBH_BASE		UL(0xee080000)
+#define SHUSBH_OHCI_BASE	(SHUSBH_BASE)
+#define SHUSBH_OHCI_SIZE	0x1000
+#define SHUSBH_EHCI_BASE	(SHUSBH_BASE + 0x1000)
+#define SHUSBH_EHCI_SIZE	0x1000
+
+/* PCI Configuration Registers for AHB-PCI Bridge Registers */
+#define PCI_CONF_AHBPCI_BAS	(SHUSBH_BASE + 0x10000)
+#define VID_DID			0x0000
+#define CMND_STS		0x0004
+#define REVID_CC		0x0008
+#define CLS_LT_HT_BIST		0x000C
+#define BASEAD			0x0010
+#define WIN1_BASEAD		0x0014
+#define WIN2_BASEAD		0x0018
+#define SSVID_SSID		0x002C
+
+/* PCI Configuration Registers for OHCI/EHCI */
+#define PCI_CONF_OHCI_BASE	(SHUSBH_BASE + 0x10000)
+#define OHCI_VID_DID		0x0000
+#define OHCI_CMND_STS		0x0004
+#define OHCI_BASEAD		0x0010
+
+#define PCI_CONF_EHCI_BASE	(SHUSBH_BASE + 0x10100)
+#define EHCI_VID_DID		0x0000
+#define EHCI_CMND_STS		0x0004
+#define EHCI_BASEAD		0x0010
+
+/* AHB-PCI Bridge Register */
+#define AHBPCI_BASE		(SHUSBH_BASE + 0x10800)
+#define PCIAHB_WIN1_CTR		0x0000
+#define PCIAHB_WIN2_CTR		0x0004
+#define PCIAHB_DCT_CTR		0x0008
+#define AHBPCI_WIN1_CTR		0x0010
+#define AHBPCI_WIN2_CTR		0x0014
+#define AHBPCI_DCT_CTR		0x001C
+#define PCI_INT_ENABLE		0x0020
+#define PCI_INT_STATUS		0x0024
+#define AHB_BUS_CTR		0x0030
+#define USBCTR			0x0034
+#define PCI_ARBITER_CTR		0x0040
+#define PCI_UNIT_REV		0x004C
+
+/* BIT */
+#define BIT00			0x00000001
+#define BIT01			0x00000002
+#define BIT02			0x00000004
+#define BIT03			0x00000008
+#define BIT04			0x00000010
+#define BIT05			0x00000020
+#define BIT06			0x00000040
+#define BIT07			0x00000080
+#define BIT08			0x00000100
+#define BIT09			0x00000200
+#define BIT10			0x00000400
+#define BIT11			0x00000800
+#define BIT12			0x00001000
+#define BIT13			0x00002000
+#define BIT14			0x00004000
+#define BIT15			0x00008000
+#define BIT16			0x00010000
+#define BIT17			0x00020000
+#define BIT18			0x00040000
+#define BIT19			0x00080000
+#define BIT20			0x00100000
+#define BIT21			0x00200000
+#define BIT22			0x00400000
+#define BIT23			0x00800000
+#define BIT24			0x01000000
+#define BIT25			0x02000000
+#define BIT26			0x04000000
+#define BIT27			0x08000000
+#define BIT28			0x10000000
+#define BIT29			0x20000000
+#define BIT30			0x40000000
+#define BIT31			0x80000000
+
+/*** PCI Configration Register for OHCI ***/
+/* VendorID, DeviceID 00h */
+#define OHCI_ID			0x00351033
+
+/*** PCI Configration Register for EHCI ***/
+/* VendorID, DeviceID 00h */
+#define EHCI_ID			0x00e01033
+
+/*** PCI Configration Register for AHB-PCI Bridge ***/
+/* CMND_STS 04h */
+#define DETPERR			BIT31
+#define SIGSERR			BIT30
+#define REMABORT		BIT29
+#define RETABORT		BIT28
+#define SIGTABORT		BIT27
+#define DEVTIM			(BIT26|BIT25)
+#define MDPERR			BIT24
+#define FBTBCAP			BIT23
+
+#define _66MCAP			BIT21
+#define CAPLIST			BIT20
+
+#define FBTBEN			BIT09
+#define SERREN			BIT08
+#define STEPCTR			BIT07
+#define PERREN			BIT06
+#define VGAPSNP			BIT05
+#define MWINVEN			BIT04
+#define SPECIALC		BIT03
+#define MASTEREN		BIT02
+#define MEMEN			BIT01
+#define IOEN			BIT00
+
+/*** AHB-PCI Bridge Setting ***/
+/* PCIAHB_WIN1_CTR 0x0800 */
+#define PREFETCH		(BIT01|BIT00)
+/* AHBPCI_WIN*_CTR 0810h,0814h */
+#define PCIWIN1_PCICMD		(BIT03|BIT01)
+
+#define AHB_CFG_HOST		0x80000000
+
+#define AHB_CFG_AHBPCI		0x40000000
+#define PCIWIN2_PCICMD		(BIT02|BIT01)
+
+/* PCI_INT_ENABLE 0820h */
+#define USBH_PMEEN		BIT19
+#define USBH_INTBEN		BIT17
+#define USBH_INTAEN		BIT16
+#define PCIAHB_WIN2_INTEN	BIT13
+#define PCIAHB_WIN1_INTEN	BIT12
+#define RESERR_INTEN		BIT05
+#define SIGSERR_INTEN		BIT04
+#define PERR_INTEN		BIT03
+#define REMARBORT_INTEN		BIT02
+#define RETARBORT_INTEN		BIT01
+#define SIGTARBORT_INTEN	BIT00
+
+/* AHB_BUS_CTR 0830h */
+#define AHB_BUS_CTR_SET \
+	(BIT17 | BIT07 | BIT02 | BIT01 | BIT00)
+/* USBCTR 0834h */
+#define PCI_AHB_WIN1_SIZE_256M	0
+#define PCI_AHB_WIN1_SIZE_512M	BIT10
+#define PCI_AHB_WIN1_SIZE_1G	BIT11
+#define PCI_AHB_WIN1_SIZE_2G	(BIT10 | BIT11)
+#define DIRPD			BIT08
+#define PLL_RST			BIT02
+#define PCICLK_MASK		BIT01
+#define USBH_RST		BIT00
+
+/* PCI_ARBITER_CTR 0840h */
+#define PCIBP_MODE		BIT12
+#define PCIREQ1			BIT01
+#define PCIREQ0			BIT00
+
+/* DMA device IDs */
+enum {
+	SHDMA_DEVID_AUDIO_LO,
+	SHDMA_DEVID_AUDIO_UP,
+	SHDMA_DEVID_AUDIOPP,
+	SHDMA_DEVID_SYS_LO,
+	SHDMA_DEVID_SYS_UP,
+};
+#define SHDMA_DEVID_AUDIO	(SHDMA_DEVID_AUDIO_LO | SHDMA_DEVID_AUDIO_UP)
+
+/* DMA slave IDs for Audio-DMAC and Audio-DMAC-pp */
+enum {
+	SHDMA_SLAVE_PCM_MEM_SSI0,
+	SHDMA_SLAVE_PCM_MEM_SRC0,
+	SHDMA_SLAVE_PCM_SSI1_MEM,
+	SHDMA_SLAVE_PCM_SRC1_MEM,
+	SHDMA_SLAVE_PCM_CMD1_MEM,
+	SHDMA_SLAVE_PCM_SRC0_SSI0,
+	SHDMA_SLAVE_PCM_CMD0_SSI0,
+	SHDMA_SLAVE_PCM_SSI1_SRC1,
+	SHDMA_SLAVE_PCM_MAX,
+};
+
+/* DMA slave IDs for SYS-DMAC */
+enum {
+	SHDMA_SLAVE_INVALID,
+	SHDMA_SLAVE_SDHI0_TX,
+	SHDMA_SLAVE_SDHI0_RX,
+	SHDMA_SLAVE_SDHI1_TX,
+	SHDMA_SLAVE_SDHI1_RX,
+	SHDMA_SLAVE_SDHI2_TX,
+	SHDMA_SLAVE_SDHI2_RX,
+	SHDMA_SLAVE_SDHI3_TX,
+	SHDMA_SLAVE_SDHI3_RX,
+};
 
 #endif /* __ASM_R8A7790_H__ */
diff --git a/arch/arm/mach-shmobile/intc-r8a7790.c b/arch/arm/mach-shmobile/intc-r8a7790.c
new file mode 100644
index 0000000..7a99e1b
--- /dev/null
+++ b/arch/arm/mach-shmobile/intc-r8a7790.c
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/mach-shmobile/intc-r8a7790.c
+ *     r8a7790 processor support - INTC hardware block
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <mach/irqs.h>
+#include <mach/r8a7790.h>
+
+extern struct irq_chip gic_arch_extn;
+int gic_of_init(struct device_node *node, struct device_node *parent);
+
+static int r8a7790_set_wake(struct irq_data *data, unsigned int on)
+{
+	return 0;
+}
+
+static  struct of_device_id r8a7790_irq_match[] __initdata = {
+	{ .compatible = "arm,cortex-a15-gic", .data = gic_of_init, },
+	{}
+};
+
+void __init r8a7790_init_irq(void)
+{
+	of_irq_init(r8a7790_irq_match);
+	gic_arch_extn.irq_set_wake = r8a7790_set_wake;
+}
diff --git a/arch/arm/mach-shmobile/pm-r8a7790.c b/arch/arm/mach-shmobile/pm-r8a7790.c
new file mode 100644
index 0000000..0eed6bc
--- /dev/null
+++ b/arch/arm/mach-shmobile/pm-r8a7790.c
@@ -0,0 +1,232 @@
+/*
+ * r8a7790 Power management support
+ *
+ * Copyright (C) 2013  Renesas Electronics Corporation
+ * Copyright (C) 2011  Renesas Solutions Corp.
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/err.h>
+#include <linux/pm_clock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <asm/io.h>
+#include <mach/common.h>
+#include <mach/r8a7790.h>
+
+static void __iomem *r8a7790_sysc_base;
+
+/* SYSC */
+#define SYSC_BASE	0xE6180000
+
+#define SYSCSR		0x000
+#define SYSCISR		0x004
+#define SYSCISCR	0x008
+#define SYSCIER		0x00C
+#define SYSCIMR		0x010
+#define PWRSR0		0x040
+#define PWRSR2		0x0C0
+#define PWRSR3		0x100
+#define PWRSR4		0x140
+#define PWRSR5		0x180
+#define PWRSR6		0x1C0
+
+#define PWRSR_OFFS	0x000
+#define PWROFFCR_OFFS	0x004
+#define PWRONCR_OFFS	0x00C
+#define PWRER_OFFS	0x014
+
+#define SYSCSR_RETRIES	100
+#define SYSCSR_DELAY_US	1
+
+#define SYSCISR_RETRIES		1000
+#define SYSCISR_DELAY_US	1
+
+#if defined(CONFIG_PM) || defined(CONFIG_SMP)
+
+static DEFINE_SPINLOCK(r8a7790_sysc_lock); /* SMP CPUs + I/O devices */
+
+static int r8a7790_sysc_pwr_on_off(struct r8a7790_pm_ch *r8a7790_ch,
+				   int sr_bit, int reg_offs)
+{
+	int k;
+
+	for (k = 0; k < SYSCSR_RETRIES; k++) {
+		if (ioread32(r8a7790_sysc_base + SYSCSR) & (1 << sr_bit))
+			break;
+		udelay(SYSCSR_DELAY_US);
+	}
+
+	if (k == SYSCSR_RETRIES)
+		return -EAGAIN;
+
+	iowrite32(1 << r8a7790_ch->chan_bit,
+		  r8a7790_sysc_base + r8a7790_ch->chan_offs + reg_offs);
+
+	return 0;
+}
+
+static int r8a7790_sysc_pwr_off(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_pwr_on_off(r8a7790_ch, 0, PWROFFCR_OFFS);
+}
+
+static int r8a7790_sysc_pwr_on(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_pwr_on_off(r8a7790_ch, 1, PWRONCR_OFFS);
+}
+
+static int r8a7790_sysc_update(struct r8a7790_pm_ch *r8a7790_ch,
+			       int (*on_off_fn)(struct r8a7790_pm_ch *))
+{
+	unsigned int isr_mask = 1 << r8a7790_ch->isr_bit;
+	unsigned int chan_mask = 1 << r8a7790_ch->chan_bit;
+	unsigned int status;
+	unsigned long flags;
+	int ret = 0;
+	int k;
+
+	spin_lock_irqsave(&r8a7790_sysc_lock, flags);
+
+	iowrite32(isr_mask, r8a7790_sysc_base + SYSCISCR);
+
+	do {
+		ret = on_off_fn(r8a7790_ch);
+		if (ret)
+			goto out;
+
+		status = ioread32(r8a7790_sysc_base +
+				  r8a7790_ch->chan_offs + PWRER_OFFS);
+	} while (status & chan_mask);
+
+	for (k = 0; k < SYSCISR_RETRIES; k++) {
+		if (ioread32(r8a7790_sysc_base + SYSCISR) & isr_mask)
+			break;
+		udelay(SYSCISR_DELAY_US);
+	}
+
+	if (k == SYSCISR_RETRIES)
+		ret = -EIO;
+
+	iowrite32(isr_mask, r8a7790_sysc_base + SYSCISCR);
+
+ out:
+	spin_unlock_irqrestore(&r8a7790_sysc_lock, flags);
+
+	pr_debug("r8a7790 power domain %d: %02x %02x %02x %02x %02x %02x -> %d\n",
+		 r8a7790_ch->isr_bit, ioread32(r8a7790_sysc_base + PWRSR0),
+		 ioread32(r8a7790_sysc_base + PWRSR2),
+		 ioread32(r8a7790_sysc_base + PWRSR3),
+		 ioread32(r8a7790_sysc_base + PWRSR4),
+		 ioread32(r8a7790_sysc_base + PWRSR5),
+		 ioread32(r8a7790_sysc_base + PWRSR6), ret);
+	return ret;
+}
+
+int r8a7790_sysc_power_down(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_update(r8a7790_ch, r8a7790_sysc_pwr_off);
+}
+
+int r8a7790_sysc_power_up(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_update(r8a7790_ch, r8a7790_sysc_pwr_on);
+}
+
+static void __init r8a7790_sysc_init(void)
+{
+	r8a7790_sysc_base = ioremap_nocache(SYSC_BASE, PAGE_SIZE);
+	if (!r8a7790_sysc_base)
+		panic("unable to ioremap r8a7790 SYSC hardware block\n");
+
+	/* enable all interrupt sources, but do not use interrupt handler */
+	iowrite32(0x0131000e, r8a7790_sysc_base + SYSCIER);
+	iowrite32(0, r8a7790_sysc_base + SYSCIMR);
+}
+
+#else /* CONFIG_PM || CONFIG_SMP */
+
+static inline void r8a7790_sysc_init(void) {}
+
+#endif /* CONFIG_PM || CONFIG_SMP */
+
+#ifdef CONFIG_PM
+
+static int pd_power_down(struct generic_pm_domain *genpd)
+{
+	return r8a7790_sysc_power_down(to_r8a7790_ch(genpd));
+}
+
+static int pd_power_up(struct generic_pm_domain *genpd)
+{
+	return r8a7790_sysc_power_up(to_r8a7790_ch(genpd));
+}
+
+static bool pd_is_off(struct generic_pm_domain *genpd)
+{
+	struct r8a7790_pm_ch *r8a7790_ch = to_r8a7790_ch(genpd);
+	unsigned int st;
+
+	st = ioread32(r8a7790_sysc_base + r8a7790_ch->chan_offs + PWRSR_OFFS);
+	if (st & (1 << r8a7790_ch->chan_bit))
+		return true;
+
+	return false;
+}
+
+static bool pd_active_wakeup(struct device *dev)
+{
+	return true;
+}
+
+void r8a7790_init_pm_domain(struct r8a7790_pm_domain *r8a7790_pd)
+{
+	struct generic_pm_domain *genpd = &r8a7790_pd->genpd;
+
+	pm_genpd_init(genpd, NULL, false);
+	genpd->dev_ops.stop = pm_clk_suspend;
+	genpd->dev_ops.start = pm_clk_resume;
+	genpd->dev_ops.active_wakeup = pd_active_wakeup;
+	genpd->dev_irq_safe = true;
+	genpd->power_off = pd_power_down;
+	genpd->power_on = pd_power_up;
+
+	if (pd_is_off(&r8a7790_pd->genpd))
+		pd_power_up(&r8a7790_pd->genpd);
+}
+
+void r8a7790_add_device_to_domain(struct r8a7790_pm_domain *r8a7790_pd,
+				 struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	pm_genpd_add_device(&r8a7790_pd->genpd, dev);
+	if (pm_clk_no_clocks(dev))
+		pm_clk_add(dev, NULL);
+}
+
+struct r8a7790_pm_domain r8a7790_rgx = {
+	.ch = {
+		.chan_offs = 0xc0, /* PWRSR2 .. PWRER2 */
+		.isr_bit = 20, /* RGX */
+	}
+};
+
+#endif /* CONFIG_PM */
+
+void __init r8a7790_pm_init(void)
+{
+	static int once;
+
+	if (!once++)
+		r8a7790_sysc_init();
+}
diff --git a/arch/arm/mach-shmobile/setup-r8a7790.c b/arch/arm/mach-shmobile/setup-r8a7790.c
index 21bbc51..e5f583f 100644
--- a/arch/arm/mach-shmobile/setup-r8a7790.c
+++ b/arch/arm/mach-shmobile/setup-r8a7790.c
@@ -1,6 +1,7 @@
 /*
  * r8a7790 processor support
  *
+ * Copyright (C) 2013  Renesas Electronics Corporation
  * Copyright (C) 2013  Renesas Solutions Corp.
  * Copyright (C) 2013  Magnus Damm
  *
@@ -22,12 +23,30 @@
 #include <linux/irqchip.h>
 #include <linux/kernel.h>
 #include <linux/of_platform.h>
+#include <linux/clk.h>
 #include <linux/serial_sci.h>
+#include <linux/sh_eth.h>
+#include <linux/i2c/i2c-rcar.h>
+#include <linux/sh_dma-desc.h>
+#include <linux/sh_audma-pp.h>
 #include <linux/platform_data/gpio-rcar.h>
 #include <linux/platform_data/irq-renesas-irqc.h>
+#include <linux/platform_data/rcar-du.h>
+#include <linux/clk.h>
+#include <linux/usb/ehci_pdriver.h>
+#include <linux/usb/ohci_pdriver.h>
+#include <linux/mfd/tmio.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
 #include <mach/common.h>
 #include <mach/irqs.h>
 #include <mach/r8a7790.h>
+#include <mach/dma-register.h>
 #include <asm/mach/arch.h>
 
 static const struct resource pfc_resources[] = {
@@ -119,6 +138,1233 @@ static inline void r8a7790_register_scif(int idx)
 				      sizeof(struct plat_sci_port));
 }
 
+static struct resource eth_resources[] = {
+	{
+		.start  = 0xee700200,
+		.end    = 0xee7003fc,
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(162),		/* IRQ0 */
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_eth_plat_data eth_platform_data = {
+	.phy = 0x1,
+	.edmac_endian = EDMAC_LITTLE_ENDIAN,
+	.register_type = SH_ETH_REG_FAST_SH4,
+	.phy_interface = PHY_INTERFACE_MODE_RMII,
+	.ether_link_active_low = 1,
+};
+
+static struct platform_device eth_device = {
+	.name = "sh-eth",
+	.id	= 0,
+	.dev = {
+		.platform_data = &eth_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(eth_resources),
+	.resource = eth_resources,
+};
+
+static struct resource powervr_resources[] = {
+	{
+		.start  = 0xfd000000,
+		.end    = 0xfd00ffff,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = gic_spi(119),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device powervr_device = {
+	.name           = "pvrsrvkm",
+	.id             = -1,
+	.resource       = powervr_resources,
+	.num_resources  = ARRAY_SIZE(powervr_resources),
+};
+
+static struct resource rcar_du_resources[] = {
+	[0] = {
+		.name	= "Display Unit",
+		.start	= 0xfeb00000,
+		.end	= 0xfeb6002c,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= 0xfeb90000,
+		.end	= 0xfeb9001c,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= 0xfeb94000,
+		.end	= 0xfeb9401c,
+		.flags	= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start	= gic_spi(256),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct rcar_du_encoder_data rcar_du_encoders[] = {
+	{
+		.encoder = RCAR_DU_ENCODER_VGA,
+		.output = 0,
+	},
+	{
+		.encoder = RCAR_DU_ENCODER_LVDS,
+		.output = 1,
+		.u.lvds.panel = {
+			.width_mm = 210,
+			.height_mm = 158,
+			.mode = {
+				.clock = 65000,
+				.hdisplay = 1024,
+				.hsync_start = 1048,
+				.hsync_end = 1184,
+				.htotal = 1344,
+				.vdisplay = 768,
+				.vsync_start = 771,
+				.vsync_end = 777,
+				.vtotal = 806,
+				.flags = 0,
+			},
+		},
+	},
+};
+
+static struct rcar_du_platform_data rcar_du_pdata = {
+	.encoders = rcar_du_encoders,
+	.num_encoders = ARRAY_SIZE(rcar_du_encoders),
+};
+
+static struct platform_device rcar_du_device = {
+	.name		= "rcar-du",
+	.num_resources	= ARRAY_SIZE(rcar_du_resources),
+	.resource	= rcar_du_resources,
+	.dev	= {
+		.platform_data = &rcar_du_pdata,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+static u64 usb_dmamask = ~(u32)0;
+
+struct usb_ehci_pdata ehci_pdata = {
+	.caps_offset	= 0,
+	.has_tt		= 0,
+};
+
+struct usb_ohci_pdata ohci_pdata = {
+};
+
+static struct resource ehci0_resources[] = {
+	[0] = {
+		.start	= 0xee080000 + 0x1000,
+		.end	= 0xee080000 + 0x1000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(108),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ehci0_device = {
+	.name	= "ehci-platform",
+	.id	= 0,
+	.dev	= {
+		.platform_data		= &ehci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ehci0_resources),
+	.resource	= ehci0_resources,
+};
+
+static struct resource ohci0_resources[] = {
+	[0] = {
+		.start	= 0xee080000,
+		.end	= 0xee080000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(108),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ohci0_device = {
+	.name	= "ohci-platform",
+	.id	= 0,
+	.dev	= {
+		.platform_data		= &ohci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ohci0_resources),
+	.resource	= ohci0_resources,
+};
+
+static struct resource ehci1_resources[] = {
+	[0] = {
+		.start	= 0xee0a0000 + 0x1000,
+		.end	= 0xee0a0000 + 0x1000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(112),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ehci1_device = {
+	.name	= "ehci-platform",
+	.id	= 1,
+	.dev	= {
+		.platform_data		= &ehci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ehci1_resources),
+	.resource	= ehci1_resources,
+};
+
+static struct resource ohci1_resources[] = {
+	[0] = {
+		.start	= 0xee0a0000,
+		.end	= 0xee0a0000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(112),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ohci1_device = {
+	.name	= "ohci-platform",
+	.id	= 1,
+	.dev	= {
+		.platform_data		= &ohci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ohci1_resources),
+	.resource	= ohci1_resources,
+};
+
+static struct resource ehci2_resources[] = {
+	[0] = {
+		.start	= 0xee0c0000 + 0x1000,
+		.end	= 0xee0c0000 + 0x1000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(113),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ehci2_device = {
+	.name	= "ehci-platform",
+	.id	= 2,
+	.dev	= {
+		.platform_data		= &ehci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ehci2_resources),
+	.resource	= ehci2_resources,
+};
+
+static struct resource ohci2_resources[] = {
+	[0] = {
+		.start	= 0xee0c0000,
+		.end	= 0xee0c0000 + 0x0fff - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(113),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ohci2_device = {
+	.name	= "ohci-platform",
+	.id	= 2,
+	.dev	= {
+		.platform_data		= &ohci_pdata,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(ohci2_resources),
+	.resource	= ohci2_resources,
+};
+
+static void __init usbh_internal_pci_bridge_init(int ch)
+{
+	u32 data;
+	void __iomem *ahbpci_base =
+		ioremap_nocache((AHBPCI_BASE + (ch * 0x20000)), 0x400);
+	void __iomem *pci_conf_ahbpci_bas =
+		ioremap_nocache((PCI_CONF_AHBPCI_BAS + (ch * 0x20000)),
+								0x100);
+
+	/* Clock & Reset & Direct Power Down */
+	data = ioread32(ahbpci_base + USBCTR);
+	data &= ~(DIRPD);
+	iowrite32(data, (ahbpci_base + USBCTR));
+
+	data &= ~(PLL_RST | PCICLK_MASK | USBH_RST);
+	iowrite32(data | PCI_AHB_WIN1_SIZE_1G, (ahbpci_base + USBCTR));
+
+	data = ioread32((ahbpci_base + AHB_BUS_CTR));
+	if (data == AHB_BUS_CTR_SET)
+		return;
+
+	/****** AHB-PCI Bridge Communication Registers ******/
+	/* AHB_BUS_CTR */
+	iowrite32(AHB_BUS_CTR_SET, (ahbpci_base + AHB_BUS_CTR));
+
+	/* PCIAHB_WIN1_CTR */
+	iowrite32((0x40000000 | PREFETCH),
+			(ahbpci_base + PCIAHB_WIN1_CTR));
+
+	/* AHBPCI_WIN2_CTR */
+	iowrite32((SHUSBH_OHCI_BASE | PCIWIN2_PCICMD),
+			(ahbpci_base + AHBPCI_WIN2_CTR));
+
+	/* PCI_ARBITER_CTR */
+	data = ioread32((ahbpci_base + PCI_ARBITER_CTR));
+	data |= (PCIBP_MODE | PCIREQ1 | PCIREQ0);
+	iowrite32(data, (ahbpci_base + PCI_ARBITER_CTR));
+
+	/* AHBPCI_WIN1_CTR : set PCI Configuratin Register for AHBPCI */
+	iowrite32(PCIWIN1_PCICMD | AHB_CFG_AHBPCI,
+			(ahbpci_base + AHBPCI_WIN1_CTR));
+
+	/****** PCI Configuration Registers for AHBPCI ******/
+	/* BASEAD */
+	iowrite32(AHBPCI_BASE, (pci_conf_ahbpci_bas + BASEAD));
+
+	/* WIN1_BASEAD */
+	iowrite32(0x40000000, (pci_conf_ahbpci_bas + WIN1_BASEAD));
+
+	/* System error enable, Parity error enable, PCI Master enable, */
+	/* Memory cycle enable */
+	iowrite32(((ioread32(pci_conf_ahbpci_bas + CMND_STS) & ~0x00100000)
+			| (SERREN | PERREN | MASTEREN | MEMEN)),
+			(pci_conf_ahbpci_bas + CMND_STS));
+
+	/****** PCI Configuration Registers for OHCI/EHCI ******/
+	iowrite32(PCIWIN1_PCICMD | AHB_CFG_HOST,
+			(ahbpci_base + AHBPCI_WIN1_CTR));
+
+	iounmap(ahbpci_base);
+	iounmap(pci_conf_ahbpci_bas);
+}
+
+static int __init usbh_ohci_init(int ch)
+{
+	u32 val;
+	int retval;
+
+	void __iomem *pci_conf_ohci_base
+		= ioremap_nocache((PCI_CONF_OHCI_BASE + (ch * 0x20000)),
+								0x100);
+
+	val = ioread32((pci_conf_ohci_base + OHCI_VID_DID));
+
+	if (val == OHCI_ID) {
+		/* OHCI_BASEAD */
+		iowrite32(SHUSBH_OHCI_BASE,
+				(pci_conf_ohci_base + OHCI_BASEAD));
+		retval = 0;
+
+		/* System error enable, Parity error enable, */
+		/* PCI Master enable, Memory cycle enable */
+		iowrite32(ioread32(pci_conf_ohci_base + OHCI_CMND_STS)
+				| (SERREN | PERREN | MASTEREN | MEMEN),
+				(pci_conf_ohci_base + OHCI_CMND_STS));
+	} else {
+		printk(KERN_ERR "Don't found OHCI controller. %x\n", val);
+		retval = -1;
+	}
+	iounmap(pci_conf_ohci_base);
+
+	return retval;
+}
+
+static int __init usbh_ehci_init(int ch)
+{
+	u32 val;
+	int retval;
+
+	void __iomem *pci_conf_ehci_base
+		= ioremap_nocache((PCI_CONF_EHCI_BASE + (ch * 0x20000)),
+								 0x100);
+
+	val = ioread32((pci_conf_ehci_base + EHCI_VID_DID));
+	if (val == EHCI_ID) {
+		/* EHCI_BASEAD */
+		iowrite32(SHUSBH_EHCI_BASE,
+				(pci_conf_ehci_base + EHCI_BASEAD));
+
+		/* System error enable, Parity error enable, */
+		/* PCI Master enable, Memory cycle enable */
+		iowrite32(ioread32(pci_conf_ehci_base + EHCI_CMND_STS) |
+				(SERREN | PERREN | MASTEREN | MEMEN),
+				(pci_conf_ehci_base + EHCI_CMND_STS));
+		retval = 0;
+	} else {
+		printk(KERN_ERR "Don't found EHCI controller. %x\n", val);
+		retval = -1;
+	}
+	iounmap(pci_conf_ehci_base);
+
+	return retval;
+}
+
+static void __init usbh_pci_int_enable(int ch)
+{
+	void __iomem *ahbpci_base =
+		ioremap_nocache((AHBPCI_BASE + (ch * 0x20000)), 0x400);
+	u32 data;
+
+	/* PCI_INT_ENABLE */
+	data = ioread32((ahbpci_base + PCI_INT_ENABLE));
+	data |= USBH_PMEEN | USBH_INTBEN | USBH_INTAEN;
+	iowrite32(data, (ahbpci_base + PCI_INT_ENABLE));
+
+	iounmap(ahbpci_base);
+}
+
+static int __init usbh_init(void)
+{
+	struct clk *clk_hs, *clk_ehci;
+	void __iomem *hs_usb = ioremap_nocache(0xE6590000, 0x1ff);
+	unsigned int ch;
+
+	clk_hs = clk_get(NULL, "hs_usb");
+	if (IS_ERR(clk_hs))
+		clk_hs = NULL;
+
+	clk_enable(clk_hs);
+
+	clk_ehci = clk_get(NULL, "usb_fck");
+	if (IS_ERR(clk_ehci))
+		clk_ehci = NULL;
+
+	clk_enable(clk_ehci);
+
+	/* Set EHCI for UGCTRL2 */
+	iowrite32(0x00000011, (hs_usb + 0x184));
+
+	for (ch = 0; ch < SHUSBH_MAX_CH; ch++) {
+		/* internal pci-bus bridge initialize */
+		usbh_internal_pci_bridge_init(ch);
+
+		/* ohci initialize */
+		usbh_ohci_init(ch);
+
+		/* ehci initialize */
+		usbh_ehci_init(ch);
+
+		/* pci int enable */
+		usbh_pci_int_enable(ch);
+	}
+	iounmap(hs_usb);
+
+	return 0;
+}
+
+/* Fixed 3.3V regulator to be used by SDHI0/1/2/3 */
+static struct regulator_consumer_supply fixed3v3_power_consumers[] = {
+	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
+	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
+	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.1"),
+	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.1"),
+	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.2"),
+	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.2"),
+	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.3"),
+	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.3"),
+};
+
+static void sdhi_set_pwr(struct platform_device *pdev, int state)
+{
+	switch (pdev->id) {
+	case 0:
+		break;
+	case 2:
+		break;
+	default:
+		break;
+	}
+}
+
+static int sdhi_get_cd(struct platform_device *pdev)
+{
+	return 1;
+}
+
+static int sdhi_get_ro(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct resource sdhi0_resources[] = {
+	[0] = {
+		.name	= "sdhi0",
+		.start	= 0xee100000,
+		.end	= 0xee1003ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(165),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mobile_sdhi_info sdhi0_platform_data = {
+	.dma_slave_tx	= SHDMA_SLAVE_SDHI0_TX,
+	.dma_slave_rx	= SHDMA_SLAVE_SDHI0_RX,
+	.tmio_caps = MMC_CAP_SD_HIGHSPEED,
+	.tmio_caps2 = MMC_CAP2_NO_2BLKS_READ,
+	.tmio_flags	= (TMIO_MMC_WRPROTECT_DISABLE
+				| TMIO_MMC_HAS_IDLE_WAIT
+				| TMIO_MMC_BUFF_16BITACC_ACTIVE_HIGH
+				| TMIO_MMC_NO_CTL_RESET_SDIO
+				| TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL
+				| TMIO_MMC_CLK_NO_SLEEP),
+	.set_pwr	= sdhi_set_pwr,
+	.get_cd		= sdhi_get_cd,
+	.get_ro		= sdhi_get_ro,
+};
+
+static struct platform_device sdhi0_device = {
+	.name = "sh_mobile_sdhi",
+	.num_resources = ARRAY_SIZE(sdhi0_resources),
+	.resource = sdhi0_resources,
+	.id = 0,
+	.dev = {
+		.platform_data = &sdhi0_platform_data,
+	}
+};
+
+static struct resource sdhi1_resources[] = {
+	[0] = {
+		.name	= "sdhi1",
+		.start	= 0xee120000,
+		.end	= 0xee1203ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(166),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mobile_sdhi_info sdhi1_platform_data = {
+	.dma_slave_tx	= SHDMA_SLAVE_SDHI1_TX,
+	.dma_slave_rx	= SHDMA_SLAVE_SDHI1_RX,
+	.tmio_caps = MMC_CAP_SD_HIGHSPEED,
+	.tmio_caps2 = MMC_CAP2_NO_2BLKS_READ,
+	.tmio_flags	= (TMIO_MMC_WRPROTECT_DISABLE
+				| TMIO_MMC_HAS_IDLE_WAIT
+				| TMIO_MMC_BUFF_16BITACC_ACTIVE_HIGH
+				| TMIO_MMC_NO_CTL_RESET_SDIO
+				| TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL
+				| TMIO_MMC_CLK_NO_SLEEP),
+	.set_pwr	= sdhi_set_pwr,
+	.get_cd		= sdhi_get_cd,
+	.get_ro		= sdhi_get_ro,
+};
+
+static struct platform_device sdhi1_device = {
+	.name = "sh_mobile_sdhi",
+	.num_resources = ARRAY_SIZE(sdhi1_resources),
+	.resource = sdhi1_resources,
+	.id = 1,
+	.dev = {
+		.platform_data = &sdhi1_platform_data,
+	}
+};
+
+static struct resource sdhi2_resources[] = {
+	[0] = {
+		.name	= "sdhi2",
+		.start	= 0xee140000,
+		.end	= 0xee1400ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(167),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mobile_sdhi_info sdhi2_platform_data = {
+	.dma_slave_tx	= SHDMA_SLAVE_SDHI2_TX,
+	.dma_slave_rx	= SHDMA_SLAVE_SDHI2_RX,
+	.tmio_caps = MMC_CAP_SD_HIGHSPEED,
+	.tmio_caps2 = MMC_CAP2_NO_2BLKS_READ,
+	.tmio_flags	= (TMIO_MMC_WRPROTECT_DISABLE
+				| TMIO_MMC_HAS_IDLE_WAIT
+				| TMIO_MMC_NO_CTL_RESET_SDIO
+				| TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL
+				| TMIO_MMC_CHECK_ILL_FUNC
+				| TMIO_MMC_CLK_NO_SLEEP),
+	.set_pwr	= sdhi_set_pwr,
+	.get_cd		= sdhi_get_cd,
+	.get_ro		= sdhi_get_ro,
+};
+
+static struct platform_device sdhi2_device = {
+	.name = "sh_mobile_sdhi",
+	.num_resources = ARRAY_SIZE(sdhi2_resources),
+	.resource = sdhi2_resources,
+	.id = 2,
+	.dev = {
+		.platform_data = &sdhi2_platform_data,
+	}
+};
+
+static struct resource sdhi3_resources[] = {
+	[0] = {
+		.name	= "sdhi3",
+		.start	= 0xee160000,
+		.end	= 0xee1600ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(168),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mobile_sdhi_info sdhi3_platform_data = {
+	.dma_slave_tx	= SHDMA_SLAVE_SDHI3_TX,
+	.dma_slave_rx	= SHDMA_SLAVE_SDHI3_RX,
+	.tmio_caps = MMC_CAP_SD_HIGHSPEED,
+	.tmio_caps2 = MMC_CAP2_NO_2BLKS_READ,
+	.tmio_flags	= (TMIO_MMC_WRPROTECT_DISABLE
+				| TMIO_MMC_HAS_IDLE_WAIT
+				| TMIO_MMC_NO_CTL_RESET_SDIO
+				| TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL
+				| TMIO_MMC_CHECK_ILL_FUNC
+				| TMIO_MMC_CLK_NO_SLEEP),
+	.set_pwr	= sdhi_set_pwr,
+	.get_cd		= sdhi_get_cd,
+	.get_ro		= sdhi_get_ro,
+};
+
+static struct platform_device sdhi3_device = {
+	.name = "sh_mobile_sdhi",
+	.num_resources = ARRAY_SIZE(sdhi3_resources),
+	.resource = sdhi3_resources,
+	.id = 3,
+	.dev = {
+		.platform_data = &sdhi3_platform_data,
+	}
+};
+
+/* QSPI resource */
+static struct resource qspi_resources[] = {
+	[0] = {
+		.name = "QSPI",
+		.start = 0xe6b10000,
+		.end = 0xe6b10fff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = gic_spi(184),
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* SPI Flash memory (Spansion S25FL512SAGMFIG11) */
+static struct mtd_partition spiflash_part[] = {
+	/* Reserved for user loader program, read-only */
+	[0] = {
+		.name = "loader_prg",
+		.offset = 0,
+		.size = SZ_256K,
+		.mask_flags = MTD_WRITEABLE,	/* read only */
+	},
+	/* Reserved for user program, read-only */
+	[1] = {
+		.name = "user_prg",
+		.offset = MTDPART_OFS_APPEND,
+		.size = SZ_4M,
+		.mask_flags = MTD_WRITEABLE,	/* read only */
+	},
+	/* All else is writable (e.g. JFFS2) */
+	[2] = {
+		.name = "flash_fs",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL,
+		.mask_flags = 0,
+	},
+};
+
+static struct flash_platform_data spiflash_data = {
+	.name		= "m25p80",
+	.parts		= spiflash_part,
+	.nr_parts	= ARRAY_SIZE(spiflash_part),
+	.type		= "s25fl512s",
+};
+
+static struct platform_device qspi_device = {
+	.name = "qspi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(qspi_resources),
+	.resource	= qspi_resources,
+	.dev  = {
+		.platform_data = &spiflash_data,
+	},
+};
+
+static struct spi_board_info spi_info[] __initdata = {
+	{
+		.modalias		= "m25p80",
+		.platform_data		= &spiflash_data,
+		.mode			= SPI_MODE_0,
+		.max_speed_hz		= 30000000,
+		.bus_num		= 0,
+		.chip_select		= 0,
+	},
+};
+
+/* I2C */
+static struct i2c_rcar_platform_data i2c_pd = {
+	.bus_speed	= 400000,
+	.icccr_cdf_width = I2C_RCAR_ICCCR_IS_3BIT,
+};
+
+static struct resource rcar_i2c0_res[] = {
+	{
+		.start  = 0xe6508000,
+		.end    = (0xe6518000 - 1),
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(287),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rcar_i2c1_res[] = {
+	{
+		.start  = 0xe6518000,
+		.end    = (0xe6528000 - 1),
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(288),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rcar_i2c2_res[] = {
+	{
+		.start  = 0xe6530000,
+		.end    = (0xe6540000 - 1),
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(286),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rcar_i2c3_res[] = {
+	{
+		.start  = 0xe6540000,
+		.end    = (0xe6550000 - 1),
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(290),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device i2c0_device = {
+	.name		= "i2c-rcar",
+	.id		= 0,
+	.dev = {
+		.platform_data = &i2c_pd,
+	},
+	.num_resources	= ARRAY_SIZE(rcar_i2c0_res),
+	.resource	= rcar_i2c0_res,
+};
+
+static struct platform_device i2c1_device = {
+	.name		= "i2c-rcar",
+	.id		= 1,
+	.dev = {
+		.platform_data = &i2c_pd,
+	},
+	.num_resources	= ARRAY_SIZE(rcar_i2c1_res),
+	.resource	= rcar_i2c1_res,
+};
+
+static struct platform_device i2c2_device = {
+	.name		= "i2c-rcar",
+	.id		= 2,
+	.dev = {
+		.platform_data = &i2c_pd,
+	},
+	.num_resources	= ARRAY_SIZE(rcar_i2c2_res),
+	.resource	= rcar_i2c2_res,
+};
+
+static struct platform_device i2c3_device = {
+	.name		= "i2c-rcar",
+	.id		= 3,
+	.dev = {
+		.platform_data = &i2c_pd,
+	},
+	.num_resources	= ARRAY_SIZE(rcar_i2c3_res),
+	.resource	= rcar_i2c3_res,
+};
+
+/* DMA */
+#define DMA_CHANNEL(a, b, c)	\
+{				\
+	.offset		= a,	\
+	.dmars		= b,	\
+	.dmars_bit	= 0,	\
+	.chclr_offset	= c	\
+}
+
+#define AUDMAPP_CHANNEL(a)	\
+{				\
+	.offset		= a,	\
+}
+
+/* Audio-DMA */
+/*  audmal  : Audio-DMAC lower (ch0-12)  */
+/*  audmau  : Audio-DMAC upper (ch13-25) */
+/*  audmapp : Audio-DMAC-pp (ch0-28)     */
+static struct clk *audma_clk_get(struct platform_device *pdev)
+{
+	if (pdev->id == SHDMA_DEVID_AUDIO_LO)
+		return clk_get(NULL, "audmac_lo");
+	else if (pdev->id == SHDMA_DEVID_AUDIO_UP)
+		return clk_get(NULL, "audmac_up");
+	else
+		return NULL;
+}
+
+static const struct sh_dmadesc_slave_config r8a7790_audma_slaves[] = {
+	{
+		.slave_id	= SHDMA_SLAVE_PCM_MEM_SSI0,
+		.addr		= 0xec241008,
+		.chcr		= CHCR_TX(XMIT_SZ_32BIT),
+		.mid_rid	= 0x01,
+	}, {
+		.slave_id	= SHDMA_SLAVE_PCM_MEM_SRC0,
+		.addr		= 0xec000000,
+		.chcr		= CHCR_TX(XMIT_SZ_32BIT),
+		.mid_rid	= 0x85,
+	}, {
+		.slave_id	= SHDMA_SLAVE_PCM_SSI1_MEM,
+		.addr		= 0xec24104c,
+		.chcr		= CHCR_RX(XMIT_SZ_32BIT),
+		.mid_rid	= 0x04,
+	}, {
+		.slave_id	= SHDMA_SLAVE_PCM_SRC1_MEM,
+		.addr		= 0xec004400,
+		.chcr		= CHCR_RX(XMIT_SZ_32BIT),
+		.mid_rid	= 0x9c,
+	},
+};
+
+static const struct sh_audmapp_slave_config r8a7790_audmapp_slaves[] = {
+	{
+		.slave_id	= SHDMA_SLAVE_PCM_SRC0_SSI0,
+		.sar		= 0xec304000,
+		.dar		= 0xec400000,
+		.chcr		= 0x2d000000,
+	}, {
+		.slave_id	= SHDMA_SLAVE_PCM_SSI1_SRC1,
+		.sar		= 0xec401000,
+		.dar		= 0xec300400,
+		.chcr		= 0x042e0000,
+	},
+};
+
+static const struct sh_dmadesc_channel r8a7790_audma_channels[] = {
+	DMA_CHANNEL(0x00008000, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008080, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008100, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008180, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008200, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008280, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008300, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008380, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008400, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008480, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008500, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008580, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008600, 0x40, 0x00000080),
+};
+
+static const struct sh_audmapp_channel r8a7790_audmapp_channels[] = {
+	AUDMAPP_CHANNEL(0x0000),
+	AUDMAPP_CHANNEL(0x0010),
+	AUDMAPP_CHANNEL(0x0020),
+	AUDMAPP_CHANNEL(0x0030),
+	AUDMAPP_CHANNEL(0x0040),
+	AUDMAPP_CHANNEL(0x0050),
+	AUDMAPP_CHANNEL(0x0060),
+	AUDMAPP_CHANNEL(0x0070),
+	AUDMAPP_CHANNEL(0x0080),
+	AUDMAPP_CHANNEL(0x0090),
+	AUDMAPP_CHANNEL(0x00a0),
+	AUDMAPP_CHANNEL(0x00b0),
+	AUDMAPP_CHANNEL(0x00c0),
+	AUDMAPP_CHANNEL(0x00d0),
+	AUDMAPP_CHANNEL(0x00e0),
+	AUDMAPP_CHANNEL(0x00f0),
+	AUDMAPP_CHANNEL(0x0100),
+	AUDMAPP_CHANNEL(0x0110),
+	AUDMAPP_CHANNEL(0x0120),
+	AUDMAPP_CHANNEL(0x0130),
+	AUDMAPP_CHANNEL(0x0140),
+	AUDMAPP_CHANNEL(0x0150),
+	AUDMAPP_CHANNEL(0x0160),
+	AUDMAPP_CHANNEL(0x0170),
+	AUDMAPP_CHANNEL(0x0180),
+	AUDMAPP_CHANNEL(0x0190),
+	AUDMAPP_CHANNEL(0x01a0),
+	AUDMAPP_CHANNEL(0x01b0),
+	AUDMAPP_CHANNEL(0x01c0),
+};
+
+static struct sh_dmadesc_pdata audma_platform_data = {
+	.slave		= r8a7790_audma_slaves,
+	.slave_num	= ARRAY_SIZE(r8a7790_audma_slaves),
+	.channel	= r8a7790_audma_channels,
+	.channel_num	= ARRAY_SIZE(r8a7790_audma_channels),
+	.ts_low_shift	= TS_LOW_SHIFT,
+	.ts_low_mask	= TS_LOW_BIT << TS_LOW_SHIFT,
+	.ts_high_shift	= TS_HI_SHIFT,
+	.ts_high_mask	= TS_HI_BIT << TS_HI_SHIFT,
+	.ts_shift	= dma_ts_shift,
+	.ts_shift_num	= ARRAY_SIZE(dma_ts_shift),
+	.dmaor_init	= DMAOR_DME,
+	.chclr_present	= 1,
+	.clk_get	= audma_clk_get,
+};
+
+static struct sh_audmapp_pdata audmapp_platform_data = {
+	.slave		= r8a7790_audmapp_slaves,
+	.slave_num	= ARRAY_SIZE(r8a7790_audmapp_slaves),
+	.channel	= r8a7790_audmapp_channels,
+	.channel_num	= ARRAY_SIZE(r8a7790_audmapp_channels),
+};
+
+static struct resource r8a7790_audmal_resources[] = {
+	{
+		.start	= 0xec700000,
+		.end	= 0xec70a7ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "error_irq",
+		.start	= gic_spi(346),
+		.end	= gic_spi(346),
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		/* IRQ for channels */
+		.start	= gic_spi(320),
+		.end	= gic_spi(332),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource r8a7790_audmau_resources[] = {
+	{
+		.start	= 0xec720000,
+		.end	= 0xec72a7ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "error_irq",
+		.start	= gic_spi(347),
+		.end	= gic_spi(347),
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		/* IRQ for channels */
+		.start	= gic_spi(333),
+		.end	= gic_spi(345),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource r8a7790_audmapp_resources[] = {
+	{
+		/* channel registers (0-28) */
+		.start	= 0xec740020,
+		.end	= 0xec7401ef,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device audmal_device = {
+	.name		= "sh-dmadesc-engine",
+	.id		= SHDMA_DEVID_AUDIO_LO,
+	.resource	= r8a7790_audmal_resources,
+	.num_resources	= ARRAY_SIZE(r8a7790_audmal_resources),
+	.dev		= {
+		.platform_data	= &audma_platform_data,
+	},
+};
+
+static struct platform_device audmau_device = {
+	.name		= "sh-dmadesc-engine",
+	.id		= SHDMA_DEVID_AUDIO_UP,
+	.resource	= r8a7790_audmau_resources,
+	.num_resources	= ARRAY_SIZE(r8a7790_audmau_resources),
+	.dev		= {
+		.platform_data	= &audma_platform_data,
+	},
+};
+
+static struct platform_device audmapp_device = {
+	.name		= "sh-audmapp-engine",
+	.id		= SHDMA_DEVID_AUDIOPP,
+	.resource	= r8a7790_audmapp_resources,
+	.num_resources	= ARRAY_SIZE(r8a7790_audmapp_resources),
+	.dev		= {
+		.platform_data	= &audmapp_platform_data,
+	},
+};
+
+/* SYS-DMA */
+static bool sysdma_filter(struct platform_device *pdev)
+{
+	if ((pdev->id != SHDMA_DEVID_SYS_LO) &&
+	    (pdev->id != SHDMA_DEVID_SYS_UP))
+		return false;
+	return true;
+}
+
+static const struct sh_dmadesc_slave_config r8a7790_sysdma_slaves[] = {
+	{
+		.slave_id	= SHDMA_SLAVE_SDHI0_TX,
+		.addr		= 0xee100060,
+		.chcr		= CHCR_TX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xcd,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI0_RX,
+		.addr		= 0xee100060 + 0x2000,
+		.chcr		= CHCR_RX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xce,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI1_TX,
+		.addr		= 0xee120030,
+		.chcr		= CHCR_TX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xc9,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI1_RX,
+		.addr		= 0xee120030 + 0x2000,
+		.chcr		= CHCR_RX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xca,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI2_TX,
+		.addr		= 0xee140030,
+		.chcr		= CHCR_TX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xc1,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI2_RX,
+		.addr		= 0xee140030 + 0x2000,
+		.chcr		= CHCR_RX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xc2,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI3_TX,
+		.addr		= 0xee160030,
+		.chcr		= CHCR_TX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xd3,
+	}, {
+		.slave_id	= SHDMA_SLAVE_SDHI3_RX,
+		.addr		= 0xee160030 + 0x2000,
+		.chcr		= CHCR_RX(XMIT_SZ_16BIT),
+		.mid_rid	= 0xd4,
+	},
+};
+
+static const struct sh_dmadesc_channel r8a7790_sysdma_channels[] = {
+	DMA_CHANNEL(0x00008000, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008080, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008100, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008180, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008200, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008280, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008300, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008380, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008400, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008480, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008500, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008580, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008600, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008680, 0x40, 0x00000080),
+	DMA_CHANNEL(0x00008700, 0x40, 0x00000080),
+};
+
+static struct sh_dmadesc_pdata sysdma_platform_data = {
+	.slave		= r8a7790_sysdma_slaves,
+	.slave_num	= ARRAY_SIZE(r8a7790_sysdma_slaves),
+	.channel	= r8a7790_sysdma_channels,
+	.channel_num	= ARRAY_SIZE(r8a7790_sysdma_channels),
+	.ts_low_shift	= TS_LOW_SHIFT,
+	.ts_low_mask	= TS_LOW_BIT << TS_LOW_SHIFT,
+	.ts_high_shift	= TS_HI_SHIFT,
+	.ts_high_mask	= TS_HI_BIT << TS_HI_SHIFT,
+	.ts_shift	= dma_ts_shift,
+	.ts_shift_num	= ARRAY_SIZE(dma_ts_shift),
+	.dmaor_init	= DMAOR_DME,
+	.chclr_present	= 1,
+	.dma_filter	= sysdma_filter,
+};
+
+static struct resource r8a7790_sysdmal_resources[] = {
+	{
+		.start	= 0xe6700000,
+		.end	= 0xe670a7ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "error_irq",
+		.start	= gic_spi(197),
+		.end	= gic_spi(197),
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		/* IRQ for channels */
+		.start	= gic_spi(200),
+		.end	= gic_spi(214),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource r8a7790_sysdmau_resources[] = {
+	{
+		.start	= 0xe6720000,
+		.end	= 0xe672a7ff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "error_irq",
+		.start	= gic_spi(220),
+		.end	= gic_spi(220),
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		/* IRQ for channels */
+		.start	= gic_spi(216),
+		.end	= gic_spi(219),
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		/* IRQ for channels */
+		.start	= gic_spi(308),
+		.end	= gic_spi(318),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device sysdmal_device = {
+	.name		= "sh-dmadesc-engine",
+	.id		= SHDMA_DEVID_SYS_LO,
+	.resource	= r8a7790_sysdmal_resources,
+	.num_resources	= ARRAY_SIZE(r8a7790_sysdmal_resources),
+	.dev		= {
+		.platform_data	= &sysdma_platform_data,
+	},
+};
+
+static struct platform_device sysdmau_device = {
+	.name		= "sh-dmadesc-engine",
+	.id		= SHDMA_DEVID_SYS_UP,
+	.resource	= r8a7790_sysdmau_resources,
+	.num_resources	= ARRAY_SIZE(r8a7790_sysdmau_resources),
+	.dev		= {
+		.platform_data	= &sysdma_platform_data,
+	},
+};
+
+/* Audio */
+static struct platform_device alsa_soc_platform_device = {
+	.name		= "lager_alsa_soc_platform",
+	.id		= 0,
+};
+
+static struct resource scu_resources[] = {
+	[0] = {
+		.name   = "scu",
+		.start  = 0xec000000,
+		.end    = 0xec500fff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.name   = "ssiu",
+		.start  = 0xec540000,
+		.end    = 0xec54085f,
+		.flags  = IORESOURCE_MEM,
+	},
+	[2] = {
+		.name   = "ssi",
+		.start  = 0xec541000,
+		.end    = 0xec54127f,
+		.flags  = IORESOURCE_MEM,
+	},
+	[3] = {
+		.name   = "adg",
+		.start  = 0xec5a0000,
+		.end    = 0xec5a0067,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device scu_device = {
+	.name		= "scu-pcm-audio",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(scu_resources),
+	.resource	= scu_resources,
+};
+
+static struct platform_device *r8a7790_early_devices[] __initdata = {
+	&eth_device,
+	&powervr_device,
+	&rcar_du_device,
+	&ehci0_device,
+	&ohci0_device,
+	&ehci1_device,
+	&ohci1_device,
+	&ehci2_device,
+	&ohci2_device,
+	&sdhi0_device,
+	&sdhi1_device,
+	&sdhi2_device,
+	&sdhi3_device,
+	&qspi_device,
+	&i2c0_device,
+	&i2c1_device,
+	&i2c2_device,
+	&i2c3_device,
+	&audmal_device,
+	&audmau_device,
+	&audmapp_device,
+	&sysdmau_device,
+	&alsa_soc_platform_device,
+	&scu_device,
+};
+
 static struct renesas_irqc_config irqc0_data = {
 	.irq_base = irq_pin(0), /* IRQ0 -> IRQ3 */
 };
@@ -140,6 +1386,23 @@ static struct resource irqc0_resources[] = {
 
 void __init r8a7790_add_standard_devices(void)
 {
+	r8a7790_pm_init();
+
+	r8a7790_init_pm_domain(&r8a7790_rgx);
+
+	regulator_register_fixed(0, fixed3v3_power_consumers,
+				ARRAY_SIZE(fixed3v3_power_consumers));
+
+	/* SD control registers IOCTRLn: SD pins driving ability */
+	__raw_writel(~0xAAAAAAAA, 0xE6060000);	/* PMMR */
+	__raw_writel(0xAAAAAAAA, 0xE6060060);	/* IOCTRL0 */
+	__raw_writel(~0xAAAAAAAA, 0xE6060000);	/* PMMR */
+	__raw_writel(0xAAAAAAAA, 0xE6060064);	/* IOCTRL1 */
+	__raw_writel(~0x00110000, 0xE6060000);	/* PMMR */
+	__raw_writel(0x00110000, 0xE6060088);	/* IOCTRL5 */
+	__raw_writel(~0xFFFFFFFF, 0xE6060000);	/* PMMR */
+	__raw_writel(0xFFFFFFFF, 0xE606008C);	/* IOCTRL6 */
+
 	r8a7790_register_scif(SCIFA0);
 	r8a7790_register_scif(SCIFA1);
 	r8a7790_register_scif(SCIFB0);
@@ -149,6 +1412,14 @@ void __init r8a7790_add_standard_devices(void)
 	r8a7790_register_scif(SCIF0);
 	r8a7790_register_scif(SCIF1);
 	r8a7790_register_irqc(0);
+	usbh_init();
+	platform_add_devices(r8a7790_early_devices,
+			     ARRAY_SIZE(r8a7790_early_devices));
+
+	r8a7790_add_device_to_domain(&r8a7790_rgx, &powervr_device);
+
+	/* QSPI flash memory */
+	spi_register_board_info(spi_info, ARRAY_SIZE(spi_info));
 }
 
 void __init r8a7790_timer_init(void)
diff --git a/arch/arm/mach-shmobile/smp-r8a7790.c b/arch/arm/mach-shmobile/smp-r8a7790.c
new file mode 100644
index 0000000..d921def
--- /dev/null
+++ b/arch/arm/mach-shmobile/smp-r8a7790.c
@@ -0,0 +1,143 @@
+/*
+ * arch/arm/mach-shmobile/smp-r8a7790.c
+ *     SMP support for R-Mobile / SH-Mobile - r8a7790 portion
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/smp.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/smp_plat.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+
+#define IO_BASE		0xe6150000
+#define CA15BAR		0x016020
+#define CA15RESCNT	0x010040
+#define RESCNT		0x010050
+#define CA15WUPCR	0x004010
+#define SYSCSR		0x030000
+#define MERAM		0xe8080000
+#define CCI_BASE	0xf0190000
+#define CCI_SLAVE3	0x4000
+#define CCI_SLAVE4	0x5000
+#define CCI_SNOOP	0x0000
+#define CCI_STATUS	0x000c
+
+static unsigned int r8a7790_get_core_count(void)
+{
+	return CONFIG_NR_CPUS;
+}
+
+static void __init r8a7790_smp_init_cpus(void)
+{
+	unsigned int ncores = r8a7790_get_core_count();
+
+	shmobile_smp_init_cpus(ncores);
+}
+
+static void __init r8a7790_smp_prepare_cpus(unsigned int max_cpus)
+{
+	u32 bar;
+	void __iomem *p;
+
+	/* MERAM for jump stub, because BAR requires 256KB aligned address */
+	p = ioremap_nocache(MERAM, 16);
+	memcpy(p, shmobile_secondary_vector, 16);
+	iounmap(p);
+
+	p = ioremap_nocache(IO_BASE, 0x40000);
+	bar = (MERAM >> 8) & 0xfffffc00;
+	__raw_writel(bar, (int)p + CA15BAR);
+	__raw_writel(bar | 0x10, (int)p + CA15BAR);
+	iounmap(p);
+}
+
+static void __cpuinit r8a7790_secondary_init(unsigned int cpu)
+{
+	gic_secondary_init(0);
+}
+
+static int __cpuinit r8a7790_boot_secondary(unsigned int cpu,
+					    struct task_struct *idle)
+{
+	u32 val;
+	void __iomem *p;
+
+	cpu = cpu_logical_map(cpu);
+
+	p = ioremap_nocache(IO_BASE, 0x40000);
+
+	__raw_writel(1 << (cpu & 3), (int)p + CA15WUPCR);
+
+	while ((__raw_readl((int)p + SYSCSR) & 0x3) != 0x3)
+		;
+	while (__raw_readl((int)p + CA15WUPCR) != 0x0)
+		;
+
+	val = __raw_readl((int)p + CA15RESCNT);
+	val |= 0xa5a50000;
+	switch (cpu & 3) {
+	case 1:
+		__raw_writel(val & ~0x4, (int)p + CA15RESCNT);
+		break;
+	case 2:
+		__raw_writel(val & ~0x2, (int)p + CA15RESCNT);
+		break;
+	case 3:
+		__raw_writel(val & ~0x1, (int)p + CA15RESCNT);
+		break;
+	}
+
+	iounmap(p);
+	return 0;
+}
+
+static int __maybe_unused r8a7790_cpu_kill(unsigned int cpu)
+{
+	int k;
+
+	/* this function is running on another CPU than the offline target,
+	 * here we need wait for shutdown code in platform_cpu_die() to
+	 * finish before asking SoC-specific code to power off the CPU core.
+	 */
+	for (k = 0; k < 1000; k++) {
+		if (shmobile_cpu_is_dead(cpu))
+			return 1;
+
+		mdelay(1);
+	}
+
+	return 0;
+}
+
+struct smp_operations r8a7790_smp_ops  __initdata = {
+	.smp_init_cpus		= r8a7790_smp_init_cpus,
+	.smp_prepare_cpus	= r8a7790_smp_prepare_cpus,
+	.smp_secondary_init	= r8a7790_secondary_init,
+	.smp_boot_secondary	= r8a7790_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_kill		= r8a7790_cpu_kill,
+	.cpu_die		= shmobile_cpu_die,
+	.cpu_disable		= shmobile_cpu_disable,
+#endif
+};
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index ef378b5..6f30993 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -148,14 +148,58 @@ config TXX9_DMAC
 	  Support the TXx9 SoC internal DMA controller.  This can be
 	  integrated in chips such as the Toshiba TX4927/38/39.
 
+config SH_DMAE_BASE
+	tristate "Renesas SuperH DMA Engine support (Memory <-> Peripheral)"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	select DMA_ENGINE
+	help
+	  Enable support for the DMA Engine driver base library of Renesas DMA controllers.
+	  This is supported to DMAC that is transferred between memory and peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
 config SH_DMAE
 	tristate "Renesas SuperH DMAC support"
 	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
 	depends on !SH_DMA_API
-	select DMA_ENGINE
+	depends on SH_DMAE_BASE
 	help
 	  Enable support for the Renesas SuperH DMA controllers.
 
+config SH_DMAE_DESC
+	tristate "Renesas SuperH SYS-DMAC/Audio-DMAC support"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	depends on SH_DMAE_BASE
+	help
+	  Enable support for the Renesas DMA controllers.
+	  This is supported to SYS-DMAC and Audio-DMAC.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SH_DMAEPP_BASE
+	tristate "Renesas SuperH DMA Engine support (Peripheral <-> Peripheral)"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	select DMA_ENGINE
+	help
+	  Enable support for the DMA Engine driver base library of Renesas DMA controllers.
+	  This is supported to DMAC that is transferred between peripheral and peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SH_DMAEPP_AUPP
+	tristate "Renesas SuperH Audio-DMAC-pp support"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	depends on SH_DMAEPP_BASE
+	help
+	  Enable support for the Renesas DMA controllers.
+	  This is supported to Audio-DMAC-Peripheral-Peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
 config COH901318
 	bool "ST-Ericsson COH901318 DMA support"
 	select DMA_ENGINE
diff --git a/drivers/dma/sh/Makefile b/drivers/dma/sh/Makefile
index 54ae957..84116d9 100644
--- a/drivers/dma/sh/Makefile
+++ b/drivers/dma/sh/Makefile
@@ -1,2 +1,5 @@
-obj-$(CONFIG_SH_DMAE) += shdma-base.o
+obj-$(CONFIG_SH_DMAE_BASE) += shdma-base.o
 obj-$(CONFIG_SH_DMAE) += shdma.o
+obj-$(CONFIG_SH_DMAE_DESC) += shdma-desc.o
+obj-$(CONFIG_SH_DMAEPP_BASE) += shdmapp-base.o
+obj-$(CONFIG_SH_DMAEPP_AUPP) += audma-pp.o
diff --git a/drivers/dma/sh/audma-pp.c b/drivers/dma/sh/audma-pp.c
new file mode 100644
index 0000000..0f2c782
--- /dev/null
+++ b/drivers/dma/sh/audma-pp.c
@@ -0,0 +1,337 @@
+/*
+ * drivers/dma/sh/audma-pp.c
+ *     This file is DMA Engine driver for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.c
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * base is drivers/dma/flsdma.c
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * - DMA of SuperH does not have Hardware DMA chain mode.
+ * - MAX DMA size is 16MB.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/platform_device.h>
+#include <linux/sh_audma-pp.h>
+#include <linux/kdebug.h>
+#include <linux/spinlock.h>
+#include <linux/rculist.h>
+
+#include "../dmaengine.h"
+#include "audma-pp.h"
+
+#define SH_DMAE_DRV_NAME "sh-audmapp-engine"
+
+/* Default MEMCPY transfer size = 2^2 = 4 bytes */
+#define LOG2_DEFAULT_XFER_SIZE	2
+#define SH_DMA_SLAVE_NUMBER 256
+#define SH_DMA_TCR_MAX (16 * 1024 * 1024 - 1)
+
+/*
+ * Used for write-side mutual exclusion for the global device list,
+ * read-side synchronization by way of RCU, and per-controller data.
+ */
+static DEFINE_SPINLOCK(sh_audmapp_lock);
+static LIST_HEAD(sh_audmapp_devices);
+
+static void sh_audmapp_writel(struct sh_audmapp_chan *sh_dc, u32 data, u32 reg)
+{
+	__raw_writel(data, sh_dc->base + reg / sizeof(u32));
+}
+
+static u32 sh_audmapp_readl(struct sh_audmapp_chan *sh_dc, u32 reg)
+{
+	return __raw_readl(sh_dc->base + reg / sizeof(u32));
+}
+
+static void dmae_start(struct sh_audmapp_chan *sh_chan)
+{
+	u32 chcr = sh_audmapp_readl(sh_chan, PDMACHCR);
+
+	sh_audmapp_writel(sh_chan, (chcr | PDMACHCR_DE), PDMACHCR);
+}
+
+static void dmae_halt(struct sh_audmapp_chan *sh_chan)
+{
+	u32 chcr = sh_audmapp_readl(sh_chan, PDMACHCR);
+
+	sh_audmapp_writel(sh_chan, (chcr & ~PDMACHCR_DE), PDMACHCR);
+}
+
+static const struct sh_audmapp_slave_config *dmae_find_slave(
+	struct sh_audmapp_chan *sh_chan, int slave_id)
+{
+	struct sh_audmapp_device *shdev = to_sh_dev(sh_chan);
+	struct sh_audmapp_pdata *pdata = shdev->pdata;
+	const struct sh_audmapp_slave_config *cfg;
+	int i;
+
+	if (slave_id >= SH_DMA_SLAVE_NUMBER)
+		return NULL;
+
+	for (i = 0, cfg = pdata->slave; i < pdata->slave_num; i++, cfg++)
+		if (cfg->slave_id == slave_id)
+			return cfg;
+
+	return NULL;
+}
+
+static int sh_audmapp_set_slave(struct shdma_chan *schan,
+			     int slave_id, bool try)
+{
+	struct sh_audmapp_chan *sh_chan =
+		container_of(schan, struct sh_audmapp_chan, shdma_chan);
+	const struct sh_audmapp_slave_config *cfg =
+		dmae_find_slave(sh_chan, slave_id);
+	if (!cfg)
+		return -ENODEV;
+
+	if (!try)
+		sh_chan->config = cfg;
+
+	sh_audmapp_writel(sh_chan, cfg->sar, PDMASAR);
+	sh_audmapp_writel(sh_chan, cfg->dar, PDMADAR);
+	sh_audmapp_writel(sh_chan, cfg->chcr, PDMACHCR);
+	dmae_start(sh_chan);
+
+	return 0;
+}
+
+static void sh_audmapp_halt(struct shdma_chan *schan)
+{
+	struct sh_audmapp_chan *sh_chan = container_of(schan,
+					struct sh_audmapp_chan, shdma_chan);
+	dmae_halt(sh_chan);
+}
+
+static int __devinit sh_audmapp_chan_probe(struct sh_audmapp_device *shdev,
+				int id, int irq, unsigned long flags)
+{
+	const struct sh_audmapp_channel *chan_pdata =
+						&shdev->pdata->channel[id];
+	struct shdma_dev *sdev = &shdev->shdma_dev;
+	struct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);
+	struct sh_audmapp_chan *sh_chan;
+	struct shdma_chan *schan;
+
+	sh_chan = kzalloc(sizeof(struct sh_audmapp_chan), GFP_KERNEL);
+	if (!sh_chan) {
+		dev_err(sdev->dma_dev.dev,
+			"No free memory for allocating dma channels!\n");
+		return -ENOMEM;
+	}
+
+	schan = &sh_chan->shdma_chan;
+	schan->max_xfer_len = SH_DMA_TCR_MAX + 1;
+
+	shdmapp_chan_probe(sdev, schan, id);
+
+	sh_chan->base = shdev->chan_reg + chan_pdata->offset / sizeof(u32);
+
+	/* set up channel irq */
+	if (pdev->id >= 0)
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dmae%d.%d", pdev->id, id);
+	else
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dma%d", id);
+
+	shdev->chan[id] = sh_chan;
+	return 0;
+}
+
+static void sh_audmapp_chan_remove(struct sh_audmapp_device *shdev)
+{
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct shdma_chan *schan;
+	int i;
+
+	shdma_for_each_chan(schan, &shdev->shdma_dev, i) {
+		struct sh_audmapp_chan *sh_chan = container_of(schan,
+					struct sh_audmapp_chan, shdma_chan);
+		BUG_ON(!schan);
+		shdmapp_chan_remove(schan);
+		kfree(sh_chan);
+	}
+	dma_dev->chancnt = 0;
+}
+
+static void sh_audmapp_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static const struct shdma_ops sh_audmapp_shdma_ops = {
+	.halt_channel = sh_audmapp_halt,
+	.set_slave = sh_audmapp_set_slave,
+};
+
+static int __devinit sh_audmapp_probe(struct platform_device *pdev)
+{
+	struct sh_audmapp_pdata *pdata = pdev->dev.platform_data;
+	unsigned long chan_flag[SH_AUDMAPP_MAX_CHANNELS] = {};
+	int chan_irq[SH_AUDMAPP_MAX_CHANNELS];
+	int err, i;
+	struct sh_audmapp_device *shdev;
+	struct dma_device *dma_dev;
+	struct resource *chan;
+
+	/* get platform data */
+	if (!pdata || !pdata->channel_num)
+		return -ENODEV;
+
+	chan = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!request_mem_region(chan->start, resource_size(chan), pdev->name)) {
+		dev_err(&pdev->dev, "DMAC register region already claimed\n");
+		return -EBUSY;
+	}
+
+	err = -ENOMEM;
+	shdev = kzalloc(sizeof(struct sh_audmapp_device), GFP_KERNEL);
+	if (!shdev) {
+		dev_err(&pdev->dev, "Not enough memory\n");
+		goto ealloc;
+	}
+
+	dma_dev = &shdev->shdma_dev.dma_dev;
+
+	shdev->chan_reg = ioremap(chan->start, resource_size(chan));
+	if (!shdev->chan_reg)
+		goto emapchan;
+
+	if (pdata->slave && pdata->slave_num)
+		dma_cap_set(DMA_SLAVE, dma_dev->cap_mask);
+
+	/* Default transfer size of 32 bytes requires 32-byte alignment */
+	dma_dev->copy_align = LOG2_DEFAULT_XFER_SIZE;
+
+	shdev->shdma_dev.ops = &sh_audmapp_shdma_ops;
+	shdev->shdma_dev.desc_size = sizeof(struct sh_audmapp_desc);
+
+	err = shdmapp_init(&pdev->dev, &shdev->shdma_dev,
+			      pdata->channel_num);
+	if (err < 0)
+		goto eshdma;
+
+	/* platform data */
+	shdev->pdata = pdev->dev.platform_data;
+
+	platform_set_drvdata(pdev, shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_add_tail_rcu(&shdev->node, &sh_audmapp_devices);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	/* Create DMA Channel */
+	for (i = 0; i < SH_AUDMAPP_MAX_CHANNELS; i++) {
+		err = sh_audmapp_chan_probe(shdev, i, chan_irq[i],
+								chan_flag[i]);
+		if (err)
+			goto chan_probe_err;
+	}
+
+	err = dma_async_device_register(&shdev->shdma_dev.dma_dev);
+	if (err < 0)
+		goto chan_probe_err;
+
+	return err;
+
+chan_probe_err:
+	sh_audmapp_chan_remove(shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	platform_set_drvdata(pdev, NULL);
+	shdmapp_cleanup(&shdev->shdma_dev);
+eshdma:
+	iounmap(shdev->chan_reg);
+	synchronize_rcu();
+emapchan:
+	kfree(shdev);
+ealloc:
+	release_mem_region(chan->start, resource_size(chan));
+
+	return err;
+}
+
+static int __devexit sh_audmapp_remove(struct platform_device *pdev)
+{
+	struct sh_audmapp_device *shdev = platform_get_drvdata(pdev);
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct resource *res;
+	int errirq = platform_get_irq(pdev, 0);
+
+	dma_async_device_unregister(dma_dev);
+
+	if (errirq > 0)
+		free_irq(errirq, shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	sh_audmapp_chan_remove(shdev);
+	shdmapp_cleanup(&shdev->shdma_dev);
+
+	iounmap(shdev->chan_reg);
+
+	platform_set_drvdata(pdev, NULL);
+
+	synchronize_rcu();
+	kfree(shdev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+static struct platform_driver aupp_dmae_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= SH_DMAE_DRV_NAME,
+	},
+	.remove		= __devexit_p(sh_audmapp_remove),
+	.shutdown	= sh_audmapp_shutdown,
+};
+
+static int __init sh_audmapp_init(void)
+{
+	return platform_driver_probe(&aupp_dmae_driver, sh_audmapp_probe);
+}
+module_init(sh_audmapp_init);
+
+static void __exit sh_audmapp_exit(void)
+{
+	platform_driver_unregister(&aupp_dmae_driver);
+}
+module_exit(sh_audmapp_exit);
+
+MODULE_AUTHOR("Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>");
+MODULE_DESCRIPTION("Renesas SH DMA Engine driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" SH_DMAE_DRV_NAME);
diff --git a/drivers/dma/sh/audma-pp.h b/drivers/dma/sh/audma-pp.h
new file mode 100644
index 0000000..905523e
--- /dev/null
+++ b/drivers/dma/sh/audma-pp.h
@@ -0,0 +1,65 @@
+/*
+ * drivers/dma/sh/audma-pp.h
+ *     This file is header file for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.h
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __DMA_AUDMAPP_H
+#define __DMA_AUDMAPP_H
+
+#include <linux/sh_audma-pp.h>
+#include <linux/shdmapp-base.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+
+#define SH_AUDMAPP_MAX_CHANNELS 29
+
+struct device;
+
+struct sh_audmapp_chan {
+	struct shdma_chan shdma_chan;
+	const struct sh_audmapp_slave_config *config;
+	u32 __iomem *base;
+	char dev_id[16];		/* unique name per DMAC of channel */
+};
+
+struct sh_audmapp_device {
+	struct shdma_dev shdma_dev;
+	struct sh_audmapp_chan *chan[SH_AUDMAPP_MAX_CHANNELS];
+	struct sh_audmapp_pdata *pdata;
+	struct list_head node;
+	u32 __iomem *chan_reg;
+};
+
+struct sh_audmapp_regs {
+	u32 sar;	/* SAR  / source address */
+	u32 dar;	/* DAR  / destination address */
+	u32 chcr;	/* CHCR / channel control */
+};
+
+struct sh_audmapp_desc {
+	struct sh_audmapp_regs hw;
+	struct shdma_desc shdma_desc;
+};
+
+#define to_sh_chan(chan) container_of(chan, struct sh_audmapp_chan, shdma_chan)
+#define to_sh_desc(lh) container_of(lh, struct sh_desc, node)
+#define tx_to_sh_desc(tx) container_of(tx, struct sh_desc, async_tx)
+#define to_sh_dev(chan) container_of(chan->shdma_chan.dma_chan.device,\
+				struct sh_audmapp_device, shdma_dev.dma_dev)
+
+#endif	/* __DMA_AUDMAPP_H */
diff --git a/drivers/dma/sh/shdma-desc.c b/drivers/dma/sh/shdma-desc.c
new file mode 100644
index 0000000..01dc8b3
--- /dev/null
+++ b/drivers/dma/sh/shdma-desc.c
@@ -0,0 +1,910 @@
+/*
+ * drivers/dma/sh/shdma-desc.c
+ *     This file is DMA Engine driver for SYS-DMAC/Audio-DMAC peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.c
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * base is drivers/dma/flsdma.c
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * - DMA of SuperH does not have Hardware DMA chain mode.
+ * - MAX DMA size is 16MB.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/sh_dma-desc.h>
+#include <linux/notifier.h>
+#include <linux/kdebug.h>
+#include <linux/spinlock.h>
+#include <linux/rculist.h>
+#include <linux/clk.h>
+
+#include "../dmaengine.h"
+#include "shdma-desc.h"
+
+#define SH_DMAE_DRV_NAME "sh-dmadesc-engine"
+
+/* Default MEMCPY transfer size = 2^2 = 4 bytes */
+#define LOG2_DEFAULT_XFER_SIZE	2
+#define SH_DMA_SLAVE_NUMBER 256
+#define SH_DMA_TCR_MAX (16 * 1024 * 1024 - 1)
+
+/*
+ * Used for write-side mutual exclusion for the global device list,
+ * read-side synchronization by way of RCU, and per-controller data.
+ */
+static DEFINE_SPINLOCK(sh_dmae_lock);
+static LIST_HEAD(sh_dmae_devices);
+
+static void chclr_write(struct sh_dmadesc_chan *sh_dc, u32 data)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_dc);
+
+	__raw_writel(data, shdev->chan_reg +
+		     shdev->pdata->channel[sh_dc->shdma_chan.id].chclr_offset);
+}
+
+static void sh_dmae_writel(struct sh_dmadesc_chan *sh_dc, u32 data, u32 reg)
+{
+	__raw_writel(data, sh_dc->base + reg / sizeof(u32));
+}
+
+static u32 sh_dmae_readl(struct sh_dmadesc_chan *sh_dc, u32 reg)
+{
+	return __raw_readl(sh_dc->base + reg / sizeof(u32));
+}
+
+static u16 dmaor_read(struct sh_dmadesc_device *shdev)
+{
+	u32 __iomem *addr = shdev->chan_reg + DMAOR / sizeof(u32);
+
+	if (shdev->pdata->dmaor_is_32bit)
+		return __raw_readl(addr);
+	else
+		return __raw_readw(addr);
+}
+
+static void dmaor_write(struct sh_dmadesc_device *shdev, u16 data)
+{
+	u32 __iomem *addr = shdev->chan_reg + DMAOR / sizeof(u32);
+
+	if (shdev->pdata->dmaor_is_32bit)
+		__raw_writel(data, addr);
+	else
+		__raw_writew(data, addr);
+}
+
+static void chcr_write(struct sh_dmadesc_chan *sh_dc, u32 data)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_dc);
+
+	__raw_writel(data, sh_dc->base + shdev->chcr_offset / sizeof(u32));
+}
+
+static u32 chcr_read(struct sh_dmadesc_chan *sh_dc)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_dc);
+
+	return __raw_readl(sh_dc->base + shdev->chcr_offset / sizeof(u32));
+}
+
+/*
+ * Reset DMA controller
+ *
+ * SH7780 has two DMAOR register
+ */
+static void sh_dmae_ctl_stop(struct sh_dmadesc_device *shdev)
+{
+	unsigned short dmaor;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sh_dmae_lock, flags);
+
+	dmaor = dmaor_read(shdev);
+	dmaor_write(shdev, dmaor & ~(DMAOR_AE | DMAOR_DME));
+
+	spin_unlock_irqrestore(&sh_dmae_lock, flags);
+}
+
+static int sh_dmae_rst(struct sh_dmadesc_device *shdev)
+{
+	unsigned short dmaor;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sh_dmae_lock, flags);
+
+	dmaor = dmaor_read(shdev) & ~(DMAOR_AE | DMAOR_DME);
+
+	if (shdev->pdata->chclr_present) {
+		struct sh_dmadesc_chan *sh_chan = shdev->chan[0];
+		struct sh_dmadesc_pdata *pdata = shdev->pdata;
+		chclr_write(sh_chan, (1 << pdata->channel_num) - 1);
+	}
+
+	dmaor_write(shdev, dmaor | shdev->pdata->dmaor_init);
+
+	dmaor = dmaor_read(shdev);
+
+	spin_unlock_irqrestore(&sh_dmae_lock, flags);
+
+	if (dmaor & DMAOR_AE) {
+		dev_warn(shdev->shdma_dev.dma_dev.dev,
+			"Can't initialize DMAOR.\n");
+		return -EIO;
+	}
+	if (shdev->pdata->dmaor_init & ~dmaor)
+		dev_warn(shdev->shdma_dev.dma_dev.dev,
+			"DMAOR=0x%x hasn't latched the initial value 0x%x.\n",
+			dmaor, shdev->pdata->dmaor_init);
+	return 0;
+}
+
+static bool dmae_is_busy(struct sh_dmadesc_chan *sh_chan)
+{
+	u32 chcr = chcr_read(sh_chan);
+
+	if ((chcr & (CHCR_DE | CHCR_TE)) == CHCR_DE)
+		return true; /* working */
+
+	return false; /* waiting */
+}
+
+static unsigned int calc_xmit_shift(struct sh_dmadesc_chan *sh_chan, u32 chcr)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	struct sh_dmadesc_pdata *pdata = shdev->pdata;
+	int cnt = ((chcr & pdata->ts_low_mask) >> pdata->ts_low_shift) |
+		((chcr & pdata->ts_high_mask) >> pdata->ts_high_shift);
+
+	if (cnt >= pdata->ts_shift_num)
+		cnt = 0;
+
+	return pdata->ts_shift[cnt];
+}
+
+static u32 log2size_to_chcr(struct sh_dmadesc_chan *sh_chan, int l2size)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	struct sh_dmadesc_pdata *pdata = shdev->pdata;
+	int i;
+
+	for (i = 0; i < pdata->ts_shift_num; i++)
+		if (pdata->ts_shift[i] == l2size)
+			break;
+
+	if (i == pdata->ts_shift_num)
+		i = 0;
+
+	return ((i << pdata->ts_low_shift) & pdata->ts_low_mask) |
+		((i << pdata->ts_high_shift) & pdata->ts_high_mask);
+}
+
+static void dmae_set_reg(struct sh_dmadesc_chan *sh_chan,
+					struct sh_dmadesc_regs *hw)
+{
+	sh_dmae_writel(sh_chan, hw->sar, SAR);
+	sh_dmae_writel(sh_chan, hw->dar, DAR);
+	sh_dmae_writel(sh_chan, hw->tcr >> sh_chan->xmit_shift, TCR);
+}
+
+static void dmae_start(struct sh_dmadesc_chan *sh_chan)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	u32 chcr = chcr_read(sh_chan);
+
+	if (shdev->pdata->needs_tend_set)
+		sh_dmae_writel(sh_chan, 0xFFFFFFFF, TEND);
+
+	chcr |= CHCR_DE | shdev->chcr_ie_bit;
+	chcr_write(sh_chan, chcr & ~CHCR_TE);
+}
+
+static void dmae_init(struct sh_dmadesc_chan *sh_chan)
+{
+	/*
+	 * Default configuration for dual address memory-memory transfer.
+	 * 0x400 represents auto-request.
+	 */
+	u32 chcr = DM_INC | SM_INC | 0x400 | log2size_to_chcr(sh_chan,
+						   LOG2_DEFAULT_XFER_SIZE);
+	sh_chan->xmit_shift = calc_xmit_shift(sh_chan, chcr);
+	chcr_write(sh_chan, chcr);
+}
+
+static int dmae_set_chcr(struct sh_dmadesc_chan *sh_chan, u32 val)
+{
+	/* If DMA is active, cannot set CHCR. */
+	/* TODO: remove this superfluous check */
+	if (dmae_is_busy(sh_chan))
+		return -EBUSY;
+
+	sh_chan->xmit_shift = calc_xmit_shift(sh_chan, val);
+	chcr_write(sh_chan, val);
+
+	return 0;
+}
+
+static int dmae_set_dmars(struct sh_dmadesc_chan *sh_chan, u16 val)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	struct sh_dmadesc_pdata *pdata = shdev->pdata;
+	const struct sh_dmadesc_channel *chan_pdata =
+					&pdata->channel[sh_chan->shdma_chan.id];
+	u16 __iomem *addr = shdev->dmars;
+
+	if (dmae_is_busy(sh_chan))
+		return -EBUSY;
+
+	if (pdata->no_dmars)
+		return 0;
+
+	/* in the case of a missing DMARS resource use first memory window */
+	if (!addr)
+		addr = (u16 __iomem *)shdev->chan_reg +
+				chan_pdata->offset / sizeof(u16);
+	addr += chan_pdata->dmars / sizeof(u16);
+	__raw_writew(val, addr);
+
+	return 0;
+}
+
+static void sh_dmae_start_xfer(struct shdma_chan *schan,
+			       struct shdma_desc *sdesc)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+	struct sh_dmadesc_desc *sh_desc =
+		container_of(sdesc, struct sh_dmadesc_desc, shdma_desc);
+
+	dev_dbg(sh_chan->shdma_chan.dev, "Queue #%d to %d: %u@%x -> %x\n",
+		sdesc->async_tx.cookie, sh_chan->shdma_chan.id,
+		sh_desc->hw.tcr, sh_desc->hw.sar, sh_desc->hw.dar);
+	/* Get the ld start address from ld_queue */
+	dmae_set_reg(sh_chan, &sh_desc->hw);
+	dmae_start(sh_chan);
+}
+
+static bool sh_dmae_channel_busy(struct shdma_chan *schan)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+	bool ret;
+
+	ret = dmae_is_busy(sh_chan);
+	return ret;
+}
+
+static void sh_dmae_setup_xfer(struct shdma_chan *schan, int slave_id)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+
+	if (slave_id >= 0) {
+		const struct sh_dmadesc_slave_config *cfg = sh_chan->config;
+
+		dmae_set_dmars(sh_chan, cfg->mid_rid);
+		dmae_set_chcr(sh_chan, cfg->chcr);
+	} else {
+		dmae_init(sh_chan);
+	}
+}
+
+static const struct sh_dmadesc_slave_config *dmae_find_slave(
+			struct sh_dmadesc_chan *sh_chan, int slave_id)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	struct sh_dmadesc_pdata *pdata = shdev->pdata;
+	const struct sh_dmadesc_slave_config *cfg;
+	int i;
+
+	if (slave_id >= SH_DMA_SLAVE_NUMBER)
+		return NULL;
+
+	for (i = 0, cfg = pdata->slave; i < pdata->slave_num; i++, cfg++) {
+		if (cfg->slave_id == slave_id)
+			return cfg;
+	}
+
+	return NULL;
+}
+
+static int sh_dmae_set_slave(struct shdma_chan *schan,
+			     int slave_id, bool try)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+	const struct sh_dmadesc_slave_config *cfg;
+
+	cfg = dmae_find_slave(sh_chan, slave_id);
+	if (!cfg)
+		return -ENODEV;
+
+	if (!try)
+		sh_chan->config = cfg;
+
+	return 0;
+}
+
+static void dmae_halt(struct sh_dmadesc_chan *sh_chan)
+{
+	struct sh_dmadesc_device *shdev = to_sh_dev(sh_chan);
+	u32 chcr = chcr_read(sh_chan);
+
+	chcr &= ~(CHCR_DE | CHCR_TE | shdev->chcr_ie_bit);
+	chcr_write(sh_chan, chcr);
+}
+
+static int sh_dmae_desc_setup(struct shdma_chan *schan,
+			      struct shdma_desc *sdesc,
+			      dma_addr_t src, dma_addr_t dst, size_t *len)
+{
+	struct sh_dmadesc_desc *sh_desc = container_of(sdesc,
+					struct sh_dmadesc_desc, shdma_desc);
+
+	if (*len > schan->max_xfer_len)
+		*len = schan->max_xfer_len;
+
+	sh_desc->hw.sar = src;
+	sh_desc->hw.dar = dst;
+	sh_desc->hw.tcr = *len;
+
+	return 0;
+}
+
+static void sh_dmae_halt(struct shdma_chan *schan)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+
+	/* DMA stop */
+	dmae_halt(sh_chan);
+}
+
+static bool sh_dmae_chan_irq(struct shdma_chan *schan, int irq)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+
+	if (!(chcr_read(sh_chan) & CHCR_TE))
+		return false;
+
+	/* DMA stop */
+	dmae_halt(sh_chan);
+
+	return true;
+}
+
+static size_t sh_dmae_get_partial(struct shdma_chan *schan,
+				  struct shdma_desc *sdesc)
+{
+	struct sh_dmadesc_chan *sh_chan =
+		container_of(schan, struct sh_dmadesc_chan, shdma_chan);
+	struct sh_dmadesc_desc *sh_desc =
+		container_of(sdesc, struct sh_dmadesc_desc, shdma_desc);
+
+	return (sh_desc->hw.tcr - sh_dmae_readl(sh_chan, TCR)) <<
+		sh_chan->xmit_shift;
+}
+
+/* Called from error IRQ or NMI */
+static bool sh_dmae_reset(struct sh_dmadesc_device *shdev)
+{
+	bool ret;
+
+	/* halt the dma controller */
+	sh_dmae_ctl_stop(shdev);
+
+	ret = shdma_reset(&shdev->shdma_dev);
+
+	sh_dmae_rst(shdev);
+
+	return ret;
+}
+
+static irqreturn_t sh_dmae_err(int irq, void *data)
+{
+	struct sh_dmadesc_device *shdev = data;
+
+	if (!(dmaor_read(shdev) & DMAOR_AE))
+		return IRQ_NONE;
+
+	sh_dmae_reset(shdev);
+	return IRQ_HANDLED;
+}
+
+static bool sh_dmae_desc_completed(struct shdma_chan *schan,
+				   struct shdma_desc *sdesc)
+{
+	struct sh_dmadesc_chan *sh_chan = container_of(schan,
+					struct sh_dmadesc_chan, shdma_chan);
+	struct sh_dmadesc_desc *sh_desc = container_of(sdesc,
+					struct sh_dmadesc_desc, shdma_desc);
+
+	u32 sar_buf = sh_dmae_readl(sh_chan, SAR);
+	u32 dar_buf = sh_dmae_readl(sh_chan, DAR);
+
+	return	(sdesc->direction == DMA_DEV_TO_MEM &&
+		 (sh_desc->hw.dar + sh_desc->hw.tcr) == dar_buf) ||
+		(sdesc->direction != DMA_DEV_TO_MEM &&
+		 (sh_desc->hw.sar + sh_desc->hw.tcr) == sar_buf);
+}
+
+static int __devinit sh_dmae_chan_probe(struct sh_dmadesc_device *shdev, int id,
+					int irq, unsigned long flags)
+{
+	const struct sh_dmadesc_channel *chan_pdata =
+						&shdev->pdata->channel[id];
+	struct shdma_dev *sdev = &shdev->shdma_dev;
+	struct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);
+	struct sh_dmadesc_chan *sh_chan;
+	struct shdma_chan *schan;
+	int err;
+
+	sh_chan = kzalloc(sizeof(struct sh_dmadesc_chan), GFP_KERNEL);
+	if (!sh_chan) {
+		dev_err(sdev->dma_dev.dev,
+			"No free memory for allocating dma channels!\n");
+		return -ENOMEM;
+	}
+
+	schan = &sh_chan->shdma_chan;
+	schan->max_xfer_len = SH_DMA_TCR_MAX + 1;
+
+	shdma_chan_probe(sdev, schan, id);
+
+	sh_chan->base = shdev->chan_reg + chan_pdata->offset / sizeof(u32);
+
+	/* set up channel irq */
+	if (pdev->id >= 0)
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dmae%d.%d", pdev->id, id);
+	else
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dma%d", id);
+
+	err = shdma_request_irq(schan, irq, flags, sh_chan->dev_id);
+	if (err) {
+		dev_err(sdev->dma_dev.dev,
+			"DMA channel %d request_irq error %d\n",
+			id, err);
+		goto err_no_irq;
+	}
+
+	shdev->chan[id] = sh_chan;
+	return 0;
+
+err_no_irq:
+	/* remove from dmaengine device node */
+	shdma_chan_remove(schan);
+	kfree(sh_chan);
+	return err;
+}
+
+static void sh_dmae_chan_remove(struct sh_dmadesc_device *shdev)
+{
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct shdma_chan *schan;
+	int i;
+
+	shdma_for_each_chan(schan, &shdev->shdma_dev, i) {
+		struct sh_dmadesc_chan *sh_chan = container_of(schan,
+					struct sh_dmadesc_chan, shdma_chan);
+		BUG_ON(!schan);
+
+		shdma_free_irq(&sh_chan->shdma_chan);
+
+		shdma_chan_remove(schan);
+		kfree(sh_chan);
+	}
+	dma_dev->chancnt = 0;
+}
+
+static void sh_dmae_shutdown(struct platform_device *pdev)
+{
+	struct sh_dmadesc_device *shdev = platform_get_drvdata(pdev);
+
+	sh_dmae_ctl_stop(shdev);
+}
+
+static int sh_dmae_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sh_dmae_runtime_resume(struct device *dev)
+{
+	struct sh_dmadesc_device *shdev = dev_get_drvdata(dev);
+
+	return sh_dmae_rst(shdev);
+}
+
+#ifdef CONFIG_PM
+static int sh_dmae_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int sh_dmae_resume(struct device *dev)
+{
+	struct sh_dmadesc_device *shdev = dev_get_drvdata(dev);
+	int i, ret;
+
+	ret = sh_dmae_rst(shdev);
+	if (ret < 0)
+		dev_err(dev, "Failed to reset!\n");
+
+	for (i = 0; i < shdev->pdata->channel_num; i++) {
+		struct sh_dmadesc_chan *sh_chan = shdev->chan[i];
+
+		if (!sh_chan->shdma_chan.desc_num)
+			continue;
+
+		if (sh_chan->shdma_chan.slave_id >= 0) {
+			const struct sh_dmadesc_slave_config *cfg =
+							sh_chan->config;
+			dmae_set_dmars(sh_chan, cfg->mid_rid);
+			dmae_set_chcr(sh_chan, cfg->chcr);
+		} else {
+			dmae_init(sh_chan);
+		}
+	}
+
+	return 0;
+}
+#else
+#define sh_dmae_suspend NULL
+#define sh_dmae_resume NULL
+#endif
+
+const struct dev_pm_ops sh_dmae_desc_pm = {
+	.suspend		= sh_dmae_suspend,
+	.resume			= sh_dmae_resume,
+	.runtime_suspend	= sh_dmae_runtime_suspend,
+	.runtime_resume		= sh_dmae_runtime_resume,
+};
+
+static dma_addr_t sh_dmae_slave_addr(struct shdma_chan *schan)
+{
+	struct sh_dmadesc_chan *sh_chan = container_of(schan,
+					struct sh_dmadesc_chan, shdma_chan);
+
+	/*
+	 * Implicit BUG_ON(!sh_chan->config)
+	 * This is an exclusive slave DMA operation, may only be called after a
+	 * successful slave configuration.
+	 */
+	return sh_chan->config->addr;
+}
+
+static struct shdma_desc *sh_dmae_embedded_desc(void *buf, int i)
+{
+	return &((struct sh_dmadesc_desc *)buf)[i].shdma_desc;
+}
+
+static const struct shdma_ops sh_dmae_shdma_ops = {
+	.desc_completed = sh_dmae_desc_completed,
+	.halt_channel = sh_dmae_halt,
+	.channel_busy = sh_dmae_channel_busy,
+	.slave_addr = sh_dmae_slave_addr,
+	.desc_setup = sh_dmae_desc_setup,
+	.set_slave = sh_dmae_set_slave,
+	.setup_xfer = sh_dmae_setup_xfer,
+	.start_xfer = sh_dmae_start_xfer,
+	.embedded_desc = sh_dmae_embedded_desc,
+	.chan_irq = sh_dmae_chan_irq,
+	.get_partial = sh_dmae_get_partial,
+};
+
+static int __devinit sh_dmae_probe(struct platform_device *pdev)
+{
+	struct sh_dmadesc_pdata *pdata = pdev->dev.platform_data;
+	unsigned long irqflags = IRQF_DISABLED,
+		chan_flag[SHDESC_DMAE_MAX_CHANNELS] = {};
+	int errirq, chan_irq[SHDESC_DMAE_MAX_CHANNELS];
+	int err, i, irq_cnt = 0, irqres = 0, irq_cap = 0;
+	struct sh_dmadesc_device *shdev;
+	struct dma_device *dma_dev;
+	struct resource *chan, *errirq_res, *chanirq_res;
+	struct clk *dma_clk = NULL;
+
+	/* get platform data */
+	if (!pdata || !pdata->channel_num)
+		return -ENODEV;
+
+	if (pdata->clk_get) {
+		dma_clk = pdata->clk_get(pdev);
+		if (dma_clk == NULL) {
+			dev_err(&pdev->dev, "Unable to get clock\n");
+			return -ENODEV;
+		}
+	}
+
+	chan = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	/*
+	 * IRQ resources:
+	 * 1. there always must be at least one IRQ IO-resource. On SH4 it is
+	 *    the error IRQ, in which case it is the only IRQ in this resource:
+	 *    start == end. If it is the only IRQ resource, all channels also
+	 *    use the same IRQ.
+	 * 2. DMA channel IRQ resources can be specified one per resource or in
+	 *    ranges (start != end)
+	 * 3. iff all events (channels and, optionally, error) on this
+	 *    controller use the same IRQ, only one IRQ resource can be
+	 *    specified, otherwise there must be one IRQ per channel, even if
+	 *    some of them are equal
+	 * 4. if all IRQs on this controller are equal or if some specific IRQs
+	 *    specify IORESOURCE_IRQ_SHAREABLE in their resources, they will be
+	 *    requested with the IRQF_SHARED flag
+	 */
+	errirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!chan || !errirq_res)
+		return -ENODEV;
+
+	if (!request_mem_region(chan->start, resource_size(chan), pdev->name)) {
+		dev_err(&pdev->dev, "DMAC register region already claimed\n");
+		return -EBUSY;
+	}
+
+	err = -ENOMEM;
+	shdev = kzalloc(sizeof(struct sh_dmadesc_device), GFP_KERNEL);
+	if (!shdev) {
+		dev_err(&pdev->dev, "Not enough memory\n");
+		goto ealloc;
+	}
+
+	dma_dev = &shdev->shdma_dev.dma_dev;
+
+	shdev->chan_reg = ioremap(chan->start, resource_size(chan));
+	if (!shdev->chan_reg)
+		goto emapchan;
+
+	if (pdata->clk_get)
+		clk_enable(dma_clk);
+
+	if (pdata->slave && pdata->slave_num)
+		dma_cap_set(DMA_SLAVE, dma_dev->cap_mask);
+
+	/* Default transfer size of 32 bytes requires 32-byte alignment */
+	dma_dev->copy_align = LOG2_DEFAULT_XFER_SIZE;
+
+	shdev->shdma_dev.ops = &sh_dmae_shdma_ops;
+	shdev->shdma_dev.desc_size = sizeof(struct sh_dmadesc_desc);
+	err = shdma_init(&pdev->dev, &shdev->shdma_dev,
+			      pdata->channel_num);
+	if (err < 0)
+		goto eshdma;
+
+	/* platform data */
+	shdev->pdata = pdev->dev.platform_data;
+
+	if (pdata->chcr_offset)
+		shdev->chcr_offset = pdata->chcr_offset;
+	else
+		shdev->chcr_offset = CHCR;
+
+	if (pdata->chcr_ie_bit)
+		shdev->chcr_ie_bit = pdata->chcr_ie_bit;
+	else
+		shdev->chcr_ie_bit = CHCR_IE;
+
+	platform_set_drvdata(pdev, shdev);
+
+	pm_runtime_enable(&pdev->dev);
+	err = pm_runtime_get_sync(&pdev->dev);
+	if (err < 0)
+		dev_err(&pdev->dev, "%s(): GET = %d\n", __func__, err);
+
+	spin_lock_irq(&sh_dmae_lock);
+	list_add_tail_rcu(&shdev->node, &sh_dmae_devices);
+	spin_unlock_irq(&sh_dmae_lock);
+
+#if defined(CONFIG_CPU_SH4) || defined(CONFIG_ARCH_SHMOBILE)
+	chanirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+
+	if (!chanirq_res)
+		chanirq_res = errirq_res;
+	else
+		irqres++;
+
+	if (chanirq_res == errirq_res ||
+	    (errirq_res->flags & IORESOURCE_BITS) == IORESOURCE_IRQ_SHAREABLE)
+		irqflags = IRQF_SHARED;
+
+	errirq = errirq_res->start;
+
+	err = request_irq(errirq, sh_dmae_err, irqflags,
+			  "DMAC Address Error", shdev);
+	if (err) {
+		dev_err(&pdev->dev,
+			"DMA failed requesting irq #%d, error %d\n",
+			errirq, err);
+		goto eirq_err;
+	}
+
+#else
+	chanirq_res = errirq_res;
+#endif /* CONFIG_CPU_SH4 || CONFIG_ARCH_SHMOBILE */
+
+	if (chanirq_res->start == chanirq_res->end &&
+	    !platform_get_resource(pdev, IORESOURCE_IRQ, 1)) {
+		/* Special case - all multiplexed */
+		for (; irq_cnt < pdata->channel_num; irq_cnt++) {
+			if (irq_cnt < SHDESC_DMAE_MAX_CHANNELS) {
+				chan_irq[irq_cnt] = chanirq_res->start;
+				chan_flag[irq_cnt] = IRQF_SHARED;
+			} else {
+				irq_cap = 1;
+				break;
+			}
+		}
+	} else {
+		do {
+			for (i = chanirq_res->start; i <= chanirq_res->end;
+									i++) {
+				if (irq_cnt >= SHDESC_DMAE_MAX_CHANNELS) {
+					irq_cap = 1;
+					break;
+				}
+
+				if ((errirq_res->flags & IORESOURCE_BITS) ==
+				    IORESOURCE_IRQ_SHAREABLE)
+					chan_flag[irq_cnt] = IRQF_SHARED;
+				else
+					chan_flag[irq_cnt] = IRQF_DISABLED;
+				dev_dbg(&pdev->dev,
+					"Found IRQ %d for channel %d\n",
+					i, irq_cnt);
+				chan_irq[irq_cnt++] = i;
+			}
+
+			if (irq_cnt >= SHDESC_DMAE_MAX_CHANNELS)
+				break;
+
+			chanirq_res = platform_get_resource(pdev,
+						IORESOURCE_IRQ, ++irqres);
+		} while (irq_cnt < pdata->channel_num && chanirq_res);
+	}
+
+	/* Create DMA Channel */
+	for (i = 0; i < irq_cnt; i++) {
+		err = sh_dmae_chan_probe(shdev, i, chan_irq[i], chan_flag[i]);
+		if (err)
+			goto chan_probe_err;
+	}
+
+	if (irq_cap)
+		dev_notice(&pdev->dev, "Attempting to register %d DMA "\
+			   "channels when a maximum of %d are supported.\n",
+			   pdata->channel_num, SHDESC_DMAE_MAX_CHANNELS);
+
+	pm_runtime_put(&pdev->dev);
+
+	/* reset dma controller - only needed as a test */
+	err = sh_dmae_rst(shdev);
+	if (err)
+		goto rst_err;
+
+	err = dma_async_device_register(&shdev->shdma_dev.dma_dev);
+	if (err < 0)
+		goto edmadevreg;
+
+	return err;
+
+edmadevreg:
+	pm_runtime_get(&pdev->dev);
+
+chan_probe_err:
+	sh_dmae_chan_remove(shdev);
+
+#if defined(CONFIG_CPU_SH4) || defined(CONFIG_ARCH_SHMOBILE)
+	free_irq(errirq, shdev);
+eirq_err:
+#endif
+rst_err:
+	spin_lock_irq(&sh_dmae_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_dmae_lock);
+
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	platform_set_drvdata(pdev, NULL);
+	shdma_cleanup(&shdev->shdma_dev);
+eshdma:
+	iounmap(shdev->chan_reg);
+	synchronize_rcu();
+emapchan:
+	kfree(shdev);
+ealloc:
+	release_mem_region(chan->start, resource_size(chan));
+
+	return err;
+}
+
+static int __devexit sh_dmae_remove(struct platform_device *pdev)
+{
+	struct sh_dmadesc_device *shdev = platform_get_drvdata(pdev);
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct resource *res;
+	int errirq = platform_get_irq(pdev, 0);
+
+	dma_async_device_unregister(dma_dev);
+
+	if (errirq > 0)
+		free_irq(errirq, shdev);
+
+	spin_lock_irq(&sh_dmae_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_dmae_lock);
+
+	pm_runtime_disable(&pdev->dev);
+
+	sh_dmae_chan_remove(shdev);
+	shdma_cleanup(&shdev->shdma_dev);
+
+	if (shdev->dmars)
+		iounmap(shdev->dmars);
+	iounmap(shdev->chan_reg);
+
+	platform_set_drvdata(pdev, NULL);
+
+	synchronize_rcu();
+	kfree(shdev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+static struct platform_driver shdesc_dmae_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.pm	= &sh_dmae_desc_pm,
+		.name	= SH_DMAE_DRV_NAME,
+	},
+	.remove		= __devexit_p(sh_dmae_remove),
+	.shutdown	= sh_dmae_shutdown,
+};
+
+static int __init sh_dmae_init(void)
+{
+	return platform_driver_probe(&shdesc_dmae_driver, sh_dmae_probe);
+}
+module_init(sh_dmae_init);
+
+static void __exit sh_dmae_exit(void)
+{
+	platform_driver_unregister(&shdesc_dmae_driver);
+}
+module_exit(sh_dmae_exit);
+
+MODULE_AUTHOR("Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>");
+MODULE_DESCRIPTION("Renesas SH DMA Engine driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" SH_DMAE_DRV_NAME);
diff --git a/drivers/dma/sh/shdma-desc.h b/drivers/dma/sh/shdma-desc.h
new file mode 100644
index 0000000..2063fc7
--- /dev/null
+++ b/drivers/dma/sh/shdma-desc.h
@@ -0,0 +1,99 @@
+/*
+ * drivers/dma/sh/shdma-desc.h
+ *     This file is header file for SYS-DMAC/Audio-DMAC peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.h
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __DMA_SHDMADESC_H
+#define __DMA_SHDMADESC_H
+
+#include <linux/sh_dma-desc.h>
+#include <linux/shdma-base.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+
+#define SHDESC_DMAE_MAX_CHANNELS 26
+#define SHDESC_DMAE_TCR_MAX 0x00FFFFFF	/* 16MB */
+
+struct device;
+
+struct sh_dmadesc_chan {
+	struct shdma_chan shdma_chan;
+	const struct sh_dmadesc_slave_config *config;
+	int xmit_shift;			/* log_2(bytes_per_xfer) */
+	u32 __iomem *base;
+	char dev_id[16];		/* unique name per DMAC of channel */
+	int pm_error;
+};
+
+struct sh_dmadesc_device {
+	struct shdma_dev shdma_dev;
+	struct sh_dmadesc_chan *chan[SHDESC_DMAE_MAX_CHANNELS];
+	struct sh_dmadesc_pdata *pdata;
+	struct list_head node;
+	u32 __iomem *chan_reg;
+	u16 __iomem *dmars;
+	unsigned int chcr_offset;
+	u32 chcr_ie_bit;
+};
+
+struct sh_dmadesc_regs {
+	u32 sar; /* SAR / source address */
+	u32 dar; /* DAR / destination address */
+	u32 tcr; /* TCR / transfer count */
+};
+
+struct sh_dmadesc_desc {
+	struct sh_dmadesc_regs hw;
+	struct shdma_desc shdma_desc;
+};
+
+#define to_sh_chan(chan) container_of(chan, struct sh_dmadesc_chan, shdma_chan)
+#define to_sh_desc(lh) container_of(lh, struct sh_desc, node)
+#define tx_to_sh_desc(tx) container_of(tx, struct sh_desc, async_tx)
+#define to_sh_dev(chan) container_of(chan->shdma_chan.dma_chan.device,\
+				struct sh_dmadesc_device, shdma_dev.dma_dev)
+
+/* DMA register */
+#define SAR	0x00
+#define DAR	0x04
+#define TCR	0x08
+#define CHCR	0x0C
+#define DMAOR	0x60
+
+#define TEND	0x18 /* USB-DMAC */
+
+/* DMAOR definitions */
+#define DMAOR_AE	0x00000004
+#define DMAOR_DME	0x00000001
+
+/* CHCR definitions */
+#define DM_INC	0x00004000
+#define DM_DEC	0x00008000
+#define DM_FIX	0x0000c000
+#define SM_INC	0x00001000
+#define SM_DEC	0x00002000
+#define SM_FIX	0x00003000
+#define RS_IN	0x00000200
+#define RS_OUT	0x00000300
+#define TS_BLK	0x00000040
+#define TM_BUR	0x00000020
+#define CHCR_DE	0x00000001
+#define CHCR_TE	0x00000002
+#define CHCR_IE	0x00000004
+
+#endif	/* __DMA_SHDMADESC_H */
diff --git a/drivers/dma/sh/shdmapp-base.c b/drivers/dma/sh/shdmapp-base.c
new file mode 100644
index 0000000..8be8b3e
--- /dev/null
+++ b/drivers/dma/sh/shdmapp-base.c
@@ -0,0 +1,245 @@
+/*
+ * drivers/dma/sh/shdmapp-base.c
+ *     This file is DMA Engine driver base library for DMAC that is
+ *     transferred between peripheral and peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.c
+ *
+ * Dmaengine driver base library for DMA controllers, found on SH-based SoCs
+ *
+ * extracted from shdma.c
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/shdma-base.h>
+#include <linux/dmaengine.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "../dmaengine.h"
+
+#define to_shdma_chan(c) container_of(c, struct shdma_chan, dma_chan)
+#define to_shdma_dev(d) container_of(d, struct shdma_dev, dma_dev)
+
+/*
+ * For slave DMA we assume, that there is a finite number of DMA slaves in the
+ * system, and that each such slave can only use a finite number of channels.
+ * We use slave channel IDs to make sure, that no such slave channel ID is
+ * allocated more than once.
+ */
+static unsigned int slave_num = 256;
+
+/* A bitmask with slave_num bits */
+static unsigned long *shdma_slave_used;
+
+static int shdmapp_setup_slave(struct shdma_chan *schan, int slave_id)
+{
+	struct shdma_dev *sdev = to_shdma_dev(schan->dma_chan.device);
+	const struct shdma_ops *ops = sdev->ops;
+	int ret;
+
+	if (slave_id < 0 || slave_id >= slave_num)
+		return -EINVAL;
+
+	if (test_and_set_bit(slave_id, shdma_slave_used))
+		return -EBUSY;
+
+	ret = ops->set_slave(schan, slave_id, false);
+	if (ret < 0) {
+		clear_bit(slave_id, shdma_slave_used);
+		return ret;
+	}
+
+	schan->slave_id = slave_id;
+
+	return 0;
+}
+
+static int shdmapp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct shdma_chan *schan = to_shdma_chan(chan);
+	struct shdma_slave *slave = chan->private;
+	int ret;
+
+	/*
+	 * This relies on the guarantee from dmaengine that alloc_chan_resources
+	 * never runs concurrently with itself or free_chan_resources.
+	 */
+	if (slave) {
+		/* Legacy mode: .private is set in filter */
+		ret = shdmapp_setup_slave(schan, slave->slave_id);
+		if (ret < 0)
+			goto esetslave;
+	} else {
+		schan->slave_id = -EINVAL;
+	}
+
+	return 0;
+
+esetslave:
+	clear_bit(slave->slave_id, shdma_slave_used);
+	chan->private = NULL;
+	return ret;
+}
+
+static void shdmapp_free_chan_resources(struct dma_chan *chan)
+{
+	struct shdma_chan *schan = to_shdma_chan(chan);
+	struct shdma_dev *sdev = to_shdma_dev(chan->device);
+	const struct shdma_ops *ops = sdev->ops;
+	LIST_HEAD(list);
+
+	/* Protect against ISR */
+	spin_lock_irq(&schan->chan_lock);
+	ops->halt_channel(schan);
+	spin_unlock_irq(&schan->chan_lock);
+
+	if (schan->slave_id >= 0) {
+		/* The caller is holding dma_list_mutex */
+		clear_bit(schan->slave_id, shdma_slave_used);
+		chan->private = NULL;
+	}
+
+	spin_lock_irq(&schan->chan_lock);
+
+	list_splice_init(&schan->ld_free, &list);
+	schan->desc_num = 0;
+
+	spin_unlock_irq(&schan->chan_lock);
+
+	kfree(schan->desc);
+}
+
+static struct dma_async_tx_descriptor *shdmapp_prep_slave_sg(
+	struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
+	enum dma_transfer_direction direction, unsigned long flags,
+	void *context)
+{
+	return NULL;
+}
+
+static int shdmapp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			  unsigned long arg)
+{
+	return 0;
+}
+
+static void shdmapp_issue_pending(struct dma_chan *chan)
+{
+	return;
+}
+
+static enum dma_status shdmapp_tx_status(struct dma_chan *chan,
+			dma_cookie_t cookie, struct dma_tx_state *txstate)
+{
+	return DMA_IN_PROGRESS;
+}
+
+void shdmapp_chan_probe(struct shdma_dev *sdev,
+			   struct shdma_chan *schan, int id)
+{
+	schan->pm_state = SHDMA_PM_ESTABLISHED;
+
+	/* reference struct dma_device */
+	schan->dma_chan.device = &sdev->dma_dev;
+	dma_cookie_init(&schan->dma_chan);
+
+	schan->dev = sdev->dma_dev.dev;
+	schan->id = id;
+
+	if (!schan->max_xfer_len)
+		schan->max_xfer_len = PAGE_SIZE;
+
+	spin_lock_init(&schan->chan_lock);
+
+	/* Init descripter manage list */
+	INIT_LIST_HEAD(&schan->ld_queue);
+	INIT_LIST_HEAD(&schan->ld_free);
+
+	/* Add the channel to DMA device channel list */
+	list_add_tail(&schan->dma_chan.device_node,
+			&sdev->dma_dev.channels);
+	sdev->schan[sdev->dma_dev.chancnt++] = schan;
+}
+EXPORT_SYMBOL(shdmapp_chan_probe);
+
+void shdmapp_chan_remove(struct shdma_chan *schan)
+{
+	list_del(&schan->dma_chan.device_node);
+}
+EXPORT_SYMBOL(shdmapp_chan_remove);
+
+int shdmapp_init(struct device *dev, struct shdma_dev *sdev,
+		    int chan_num)
+{
+	struct dma_device *dma_dev = &sdev->dma_dev;
+
+	/*
+	 * Require all call-backs for now, they can trivially be made optional
+	 * later as required
+	 */
+	if (!sdev->ops || !sdev->ops->set_slave || !sdev->ops->halt_channel)
+		return -EINVAL;
+
+	sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL);
+	if (!sdev->schan)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&dma_dev->channels);
+
+	/* Common and MEMCPY operations */
+	dma_dev->device_alloc_chan_resources = shdmapp_alloc_chan_resources;
+	dma_dev->device_free_chan_resources = shdmapp_free_chan_resources;
+	dma_dev->device_tx_status = shdmapp_tx_status;
+	dma_dev->device_issue_pending = shdmapp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma_dev->device_prep_slave_sg = shdmapp_prep_slave_sg;
+	dma_dev->device_control = shdmapp_control;
+
+	dma_dev->dev = dev;
+
+	return 0;
+}
+EXPORT_SYMBOL(shdmapp_init);
+
+void shdmapp_cleanup(struct shdma_dev *sdev)
+{
+	kfree(sdev->schan);
+}
+EXPORT_SYMBOL(shdmapp_cleanup);
+
+static int __init shdmapp_enter(void)
+{
+	shdma_slave_used = kzalloc(DIV_ROUND_UP(slave_num, BITS_PER_LONG) *
+				    sizeof(long), GFP_KERNEL);
+	if (!shdma_slave_used)
+		return -ENOMEM;
+	return 0;
+}
+module_init(shdmapp_enter);
+
+static void __exit shdmapp_exit(void)
+{
+	kfree(shdma_slave_used);
+}
+module_exit(shdmapp_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("SH-DMA driver base library");
+MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
diff --git a/drivers/gpu/drm/drm_fb_cma_helper.c b/drivers/gpu/drm/drm_fb_cma_helper.c
index 09e11a5..3bd3aa1 100644
--- a/drivers/gpu/drm/drm_fb_cma_helper.c
+++ b/drivers/gpu/drm/drm_fb_cma_helper.c
@@ -33,6 +33,7 @@ struct drm_fb_cma {
 struct drm_fbdev_cma {
 	struct drm_fb_helper	fb_helper;
 	struct drm_fb_cma	*fb;
+	unsigned int		fb_size_mult;
 };
 
 static inline struct drm_fbdev_cma *to_fbdev_cma(struct drm_fb_helper *helper)
@@ -189,6 +190,7 @@ static struct fb_ops drm_fbdev_cma_ops = {
 	.fb_set_par	= drm_fb_helper_set_par,
 	.fb_blank	= drm_fb_helper_blank,
 	.fb_pan_display	= drm_fb_helper_pan_display,
+	.fb_ioctl	= drm_fb_helper_ioctl,
 	.fb_setcmap	= drm_fb_helper_setcmap,
 };
 
@@ -213,7 +215,7 @@ static int drm_fbdev_cma_create(struct drm_fb_helper *helper,
 	bytes_per_pixel = DIV_ROUND_UP(sizes->surface_bpp, 8);
 
 	mode_cmd.width = sizes->surface_width;
-	mode_cmd.height = sizes->surface_height;
+	mode_cmd.height = sizes->surface_height * fbdev_cma->fb_size_mult;
 	mode_cmd.pitches[0] = sizes->surface_width * bytes_per_pixel;
 	mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,
 		sizes->surface_depth);
@@ -252,7 +254,8 @@ static int drm_fbdev_cma_create(struct drm_fb_helper *helper,
 	}
 
 	drm_fb_helper_fill_fix(fbi, fb->pitches[0], fb->depth);
-	drm_fb_helper_fill_var(fbi, helper, fb->width, fb->height);
+	drm_fb_helper_fill_var(fbi, helper, sizes->surface_width,
+			       sizes->surface_height);
 
 	offset = fbi->var.xoffset * bytes_per_pixel;
 	offset += fbi->var.yoffset * fb->pitches[0];
@@ -299,12 +302,13 @@ static struct drm_fb_helper_funcs drm_fb_cma_helper_funcs = {
  * @preferred_bpp: Preferred bits per pixel for the device
  * @num_crtc: Number of CRTCs
  * @max_conn_count: Maximum number of connectors
+ * @fb_size_mult: Frame buffer height size multiplier
  *
  * Returns a newly allocated drm_fbdev_cma struct or a ERR_PTR.
  */
 struct drm_fbdev_cma *drm_fbdev_cma_init(struct drm_device *dev,
 	unsigned int preferred_bpp, unsigned int num_crtc,
-	unsigned int max_conn_count)
+	unsigned int max_conn_count, unsigned int fb_size_mult)
 {
 	struct drm_fbdev_cma *fbdev_cma;
 	struct drm_fb_helper *helper;
@@ -316,6 +320,7 @@ struct drm_fbdev_cma *drm_fbdev_cma_init(struct drm_device *dev,
 		return ERR_PTR(-ENOMEM);
 	}
 
+	fbdev_cma->fb_size_mult = fb_size_mult;
 	fbdev_cma->fb_helper.funcs = &drm_fb_cma_helper_funcs;
 	helper = &fbdev_cma->fb_helper;
 
diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 50d60d9..d82be0f 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -723,6 +723,35 @@ int drm_fb_helper_pan_display(struct fb_var_screeninfo *var,
 }
 EXPORT_SYMBOL(drm_fb_helper_pan_display);
 
+static int drm_fb_helper_wait_for_vsync(struct drm_fb_helper *fb_helper)
+{
+	struct drm_device *dev = fb_helper->dev;
+	union drm_wait_vblank vblwait;
+
+	/* Waiting for VSYNC on multiple CRTCs doesn't make sense. Use the first
+	 * CRTC only.
+	 */
+	vblwait.request.type = _DRM_VBLANK_RELATIVE;
+	vblwait.request.sequence = 1;
+
+	return drm_wait_vblank(dev, &vblwait, NULL);
+}
+
+int drm_fb_helper_ioctl(struct fb_info *info, unsigned int cmd,
+			unsigned long arg)
+{
+	struct drm_fb_helper *fb_helper = info->par;
+
+	switch (cmd) {
+	case FBIO_WAITFORVSYNC:
+		return drm_fb_helper_wait_for_vsync(fb_helper);
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+EXPORT_SYMBOL(drm_fb_helper_ioctl);
+
 int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,
 				  int preferred_bpp)
 {
@@ -852,7 +881,7 @@ void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,
 	info->fix.type_aux = 0;
 	info->fix.xpanstep = 1; /* doing it in hw */
 	info->fix.ypanstep = 1; /* doing it in hw */
-	info->fix.ywrapstep = 0;
+	info->fix.ywrapstep = 1;
 	info->fix.accel = FB_ACCEL_NONE;
 	info->fix.type_aux = 0;
 
diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c
index b031fcd..126cf69 100644
--- a/drivers/gpu/drm/drm_irq.c
+++ b/drivers/gpu/drm/drm_irq.c
@@ -1267,6 +1267,7 @@ done:
 	drm_vblank_put(dev, crtc);
 	return ret;
 }
+EXPORT_SYMBOL(drm_wait_vblank);
 
 void drm_handle_vblank_events(struct drm_device *dev, int crtc)
 {
diff --git a/drivers/gpu/drm/rcar-du/Kconfig b/drivers/gpu/drm/rcar-du/Kconfig
index 2eb7d23..0566ef1 100644
--- a/drivers/gpu/drm/rcar-du/Kconfig
+++ b/drivers/gpu/drm/rcar-du/Kconfig
@@ -7,3 +7,24 @@ config DRM_RCAR_DU
 	help
 	  Choose this option if you have an R-Car chipset.
 	  If M is selected the module will be called rcar-du-drm.
+
+config ANALOG_RGB_CH
+	int "Display analog RGB output channel"
+	range 0 1
+	default 0
+	depends on DRM_RCAR_DU
+	help
+	  This option is selection of DU channel for analog RGB
+	  output.
+	  if you want to set Analog RGB output to DU0, you set "0".
+	  if you want to set Analog RGB output to DU1, you set "1".
+
+config LVDS_CH
+	int "Display LVDS output channel"
+	range 1 1
+	default 1
+	depends on DRM_RCAR_DU
+	help
+	  This option is selection of DU channel for LVDS
+	  output.
+	  if you want to set LVDS output to DU1, you set "1".
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index 1b49b54..dd043df 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -29,6 +29,7 @@
 #include "rcar_du_vga.h"
 
 #define to_rcar_crtc(c)	container_of(c, struct rcar_du_crtc, crtc)
+#define WORK_AROUND
 
 static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)
 {
@@ -69,6 +70,118 @@ static void rcar_du_crtc_clr_set(struct rcar_du_crtc *rcrtc, u32 reg,
 	rcar_du_write(rcdu, rcrtc->mmio_offset + reg, (value & ~clr) | set);
 }
 
+static inline u32 rcar_du_lvds0_read(struct rcar_du_device *rcdu, u32 reg)
+{
+	return ioread32(rcdu->lvds0_mmio + reg);
+}
+
+static inline void rcar_du_lvds0_write(struct rcar_du_device *rcdu,
+				 u32 reg, u32 data)
+{
+	iowrite32(data, rcdu->lvds0_mmio + reg);
+}
+
+static inline u32 rcar_du_lvds1_read(struct rcar_du_device *rcdu, u32 reg)
+{
+	return ioread32(rcdu->lvds1_mmio + reg);
+}
+
+static inline void rcar_du_lvds1_write(struct rcar_du_device *rcdu,
+				 u32 reg, u32 data)
+{
+	iowrite32(data, rcdu->lvds1_mmio + reg);
+}
+
+static void rcar_du_lvds0_setting(struct rcar_du_device *rcdu)
+{
+	u32 set_clock;
+
+	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
+
+	/* 3. PLL, CTR, CH register setting */
+	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000577B);
+	else if ((set_clock > (38 * 1000 * 1000))
+		 && (set_clock <= (60 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000569A);
+	else if ((set_clock > (61 * 1000 * 1000))
+		 && (set_clock <= (121 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000522C);
+	else if ((set_clock > (121 * 1000 * 1000))
+		 && (set_clock <= (150 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x000001C7);
+	else
+		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
+
+#ifdef WORK_AROUND /* work around */
+	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00002020); /* work around */
+#else
+	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00000000);
+#endif
+
+	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000005));
+
+	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
+	rcar_du_lvds0_write(rcdu, LVDCR1,
+		 (rcar_du_lvds0_read(rcdu, LVDCR1) | 0x000003FF));
+
+	/* 6. Set LVDCR0.PLLON=1 PLL ON */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000010));
+	udelay(100); /* wait for 100us */
+
+	/* 7. Set LVDCR.LVRES=1 */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000002));
+}
+
+static void rcar_du_lvds1_setting(struct rcar_du_device *rcdu)
+{
+	u32 set_clock;
+
+	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
+
+	/* 3. PLL, CTR, CH register setting */
+	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000577B);
+	else if ((set_clock > (38 * 1000 * 1000))
+		 && (set_clock <= (60 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000569A);
+	else if ((set_clock > (61 * 1000 * 1000))
+		 && (set_clock <= (121 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000522C);
+	else if ((set_clock > (121 * 1000 * 1000))
+		 && (set_clock <= (150 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x000001C7);
+	else
+		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
+
+#ifdef WORK_AROUND /* work around */
+	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00002020); /* work around */
+#else
+	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00000000);
+#endif
+
+	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000005));
+
+	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
+	rcar_du_lvds1_write(rcdu, LVDCR1,
+		 (rcar_du_lvds1_read(rcdu, LVDCR1) | 0x000003FF));
+
+	/* 6. Set LVDCR0.PLLON=1 PLL ON */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000010));
+	udelay(100); /* wait for 100us */
+
+	/* 7. Set LVDCR.LVRES=1 */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000002));
+}
+
 static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 {
 	struct drm_crtc *crtc = &rcrtc->crtc;
@@ -285,6 +398,9 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 
 	rcar_du_start_stop(rcdu, true);
 
+	rcar_du_lvds0_setting(rcdu);
+	rcar_du_lvds1_setting(rcdu);
+
 	rcrtc->started = true;
 }
 
@@ -412,8 +528,8 @@ static int rcar_du_crtc_mode_set(struct drm_crtc *crtc,
 
 	rcrtc->plane->src_x = x;
 	rcrtc->plane->src_y = y;
-	rcrtc->plane->width = crtc->fb->width;
-	rcrtc->plane->height = crtc->fb->height;
+	rcrtc->plane->width = mode->hdisplay;
+	rcrtc->plane->height = mode->vdisplay;
 
 	rcar_du_plane_compute_base(rcrtc->plane, crtc->fb);
 
@@ -445,6 +561,11 @@ static void rcar_du_crtc_mode_commit(struct drm_crtc *crtc)
 static int rcar_du_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
 				      struct drm_framebuffer *old_fb)
 {
+	struct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);
+
+	rcrtc->plane->src_x = x;
+	rcrtc->plane->src_y = y;
+
 	rcar_du_crtc_update_base(to_rcar_crtc(crtc));
 
 	return 0;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index 813d48c..161913c 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -55,11 +55,31 @@ int rcar_du_get(struct rcar_du_device *rcdu)
 	if (ret < 0)
 		return ret;
 
+	ret = clk_enable(rcdu->clock_du1);
+	if (ret < 0)
+		return ret;
+
+	ret = clk_enable(rcdu->clock_lvds0);
+	if (ret < 0)
+		return ret;
+
+	ret = clk_enable(rcdu->clock_lvds1);
+	if (ret < 0)
+		return ret;
+
 	/* Enable extended features */
 	rcar_du_write(rcdu, DEFR, DEFR_CODE | DEFR_DEFE);
 	rcar_du_write(rcdu, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);
 	rcar_du_write(rcdu, DEFR3, DEFR3_CODE | DEFR3_DEFE3);
 	rcar_du_write(rcdu, DEFR4, DEFR4_CODE);
+	rcar_du_write(rcdu, DEFR5, DEFR5_CODE | DEFR5_DEFE5);
+
+	if (CONFIG_ANALOG_RGB_CH == 2)
+		rcar_du_write(rcdu, DEFR8, DEFR8_CODE | DEFR8_DRGBS_DU2);
+	else if (CONFIG_ANALOG_RGB_CH == 1)
+		rcar_du_write(rcdu, DEFR8, DEFR8_CODE | DEFR8_DRGBS_DU1);
+	else
+		rcar_du_write(rcdu, DEFR8, DEFR8_CODE | DEFR8_DRGBS_DU0);
 
 	/* Use DS1PR and DS2PR to configure planes priorities and connects the
 	 * superposition 0 to DU0 pins. DU1 pins will be configured dynamically.
@@ -84,6 +104,9 @@ void rcar_du_put(struct rcar_du_device *rcdu)
 		return;
 
 	clk_disable_unprepare(rcdu->clock);
+	clk_disable(rcdu->clock_du1);
+	clk_disable(rcdu->clock_lvds0);
+	clk_disable(rcdu->clock_lvds1);
 }
 
 /* -----------------------------------------------------------------------------
@@ -113,7 +136,11 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 	struct rcar_du_platform_data *pdata = pdev->dev.platform_data;
 	struct rcar_du_device *rcdu;
 	struct resource *ioarea;
+	struct resource *lvds0_ioarea;
+	struct resource *lvds1_ioarea;
 	struct resource *mem;
+	struct resource *lvds0_mem;
+	struct resource *lvds1_mem;
 	int ret;
 
 	if (pdata == NULL) {
@@ -156,6 +183,54 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		goto done;
 	}
 
+	/* LVDS0 */
+	lvds0_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (lvds0_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory lvds0 resource\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	lvds0_ioarea = devm_request_mem_region(&pdev->dev, lvds0_mem->start,
+					 resource_size(lvds0_mem), pdev->name);
+	if (lvds0_ioarea == NULL) {
+		dev_err(&pdev->dev, "failed to request memory lvds0 region\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	rcdu->lvds0_mmio = devm_ioremap_nocache(&pdev->dev, lvds0_ioarea->start,
+					  resource_size(lvds0_ioarea));
+	if (rcdu->lvds0_mmio == NULL) {
+		dev_err(&pdev->dev, "failed to remap memory lvds0 resource\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* LVDS1 */
+	lvds1_mem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (lvds1_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory lvds1 resource\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	lvds1_ioarea = devm_request_mem_region(&pdev->dev, lvds1_mem->start,
+					 resource_size(lvds1_mem), pdev->name);
+	if (lvds1_ioarea == NULL) {
+		dev_err(&pdev->dev, "failed to request memory lvds1 region\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	rcdu->lvds1_mmio = devm_ioremap_nocache(&pdev->dev, lvds1_ioarea->start,
+					  resource_size(lvds1_ioarea));
+	if (rcdu->lvds1_mmio == NULL) {
+		dev_err(&pdev->dev, "failed to remap memory lvds1 resource\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
 	rcdu->clock = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(rcdu->clock)) {
 		dev_err(&pdev->dev, "failed to get clock\n");
@@ -163,6 +238,27 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		goto done;
 	}
 
+	rcdu->clock_du1 = clk_get(NULL, "rcar-du.1");
+	if (IS_ERR(rcdu->clock_du1)) {
+		dev_err(&pdev->dev, "failed to get rcar-du.1 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
+	rcdu->clock_lvds0 = clk_get(NULL, "lvds.0");
+	if (IS_ERR(rcdu->clock_lvds0)) {
+		dev_err(&pdev->dev, "failed to get lvds.0 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
+	rcdu->clock_lvds1 = clk_get(NULL, "lvds.1");
+	if (IS_ERR(rcdu->clock_lvds1)) {
+		dev_err(&pdev->dev, "failed to get lvds.1 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
 	/* DRM/KMS objects */
 	ret = rcar_du_modeset_init(rcdu);
 	if (ret < 0) {
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index e761b27..f0d6254 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -31,7 +31,12 @@ struct rcar_du_device {
 	const struct rcar_du_platform_data *pdata;
 
 	void __iomem *mmio;
+	void __iomem *lvds0_mmio;
+	void __iomem *lvds1_mmio;
 	struct clk *clock;
+	struct clk *clock_du1;
+	struct clk *clock_lvds0;
+	struct clk *clock_lvds1;
 	unsigned int use_count;
 
 	struct drm_device *ddev;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_kms.c b/drivers/gpu/drm/rcar-du/rcar_du_kms.c
index 1cc27bb..3060ab7 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_kms.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_kms.c
@@ -11,6 +11,8 @@
  * (at your option) any later version.
  */
 
+#include <linux/moduleparam.h>
+
 #include <drm/drmP.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
@@ -24,6 +26,9 @@
 #include "rcar_du_regs.h"
 #include "rcar_du_vga.h"
 
+static bool rcar_du_fbdev_pan = true;
+module_param_named(fb_cma_pan, rcar_du_fbdev_pan, bool, 0444);
+
 /* -----------------------------------------------------------------------------
  * Format helpers
  */
@@ -245,7 +250,8 @@ int rcar_du_modeset_init(struct rcar_du_device *rcdu)
 	drm_helper_disable_unused_functions(dev);
 
 	fbdev = drm_fbdev_cma_init(dev, 32, dev->mode_config.num_crtc,
-				   dev->mode_config.num_connector);
+				   dev->mode_config.num_connector,
+				   rcar_du_fbdev_pan ? 3 : 1);
 	if (IS_ERR(fbdev))
 		return PTR_ERR(fbdev);
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvds.c b/drivers/gpu/drm/rcar-du/rcar_du_lvds.c
index 8a3ef36..7aefe72 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvds.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvds.c
@@ -166,9 +166,15 @@ static bool rcar_du_lvds_encoder_mode_fixup(struct drm_encoder *encoder,
 		return false;
 	}
 
-	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
 	panel_mode = list_first_entry(&connector->modes,
 				      struct drm_display_mode, head);
+
+	/* We're not allowed to modify the resolution. */
+	if (mode->hdisplay != panel_mode->hdisplay ||
+	    mode->vdisplay != panel_mode->vdisplay)
+		return false;
+
+	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
 	drm_mode_copy(adjusted_mode, panel_mode);
 
 	return true;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_plane.c b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
index 8cbd293..9292c7a 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_plane.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
@@ -103,15 +103,22 @@ void rcar_du_plane_update_base(struct rcar_du_plane *plane)
 	struct rcar_du_device *rcdu = plane->dev;
 	unsigned int index = plane->hwindex;
 
+	/* According to the datasheet the Y position is expressed in raster line
+	 * units. However, 32bpp formats seem to require a doubled Y position
+	 * value. Similarly, for the second plane, NV12 and NV21 formats seem to
+	 * require a halved Y position value.
+	 */
 	rcar_du_plane_write(rcdu, index, PnSPXR, plane->src_x);
-	rcar_du_plane_write(rcdu, index, PnSPYR, plane->src_y);
+	rcar_du_plane_write(rcdu, index, PnSPYR, plane->src_y *
+			    (plane->format->bpp == 32 ? 2 : 1));
 	rcar_du_plane_write(rcdu, index, PnDSA0R, plane->dma[0]);
 
 	if (plane->format->planes == 2) {
 		index = (index + 1) % 8;
 
 		rcar_du_plane_write(rcdu, index, PnSPXR, plane->src_x);
-		rcar_du_plane_write(rcdu, index, PnSPYR, plane->src_y);
+		rcar_du_plane_write(rcdu, index, PnSPYR, plane->src_y *
+				    (plane->format->bpp == 16 ? 2 : 1) / 2);
 		rcar_du_plane_write(rcdu, index, PnDSA0R, plane->dma[1]);
 	}
 }
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_regs.h b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
index 69f21f1..5703744 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
@@ -204,6 +204,14 @@
 #define DEFR6_MLOS1		(1 << 2)
 #define DEFR6_DEFAULT		(DEFR6_CODE | DEFR6_TCNE2)
 
+#define DEFR8			0x20020
+#define DEFR8_CODE		(0x7790 << 16)
+#define DEFR8_VSCS		(1 << 6)
+#define DEFR8_DRGBS_DU2		(2 << 4)
+#define DEFR8_DRGBS_DU1		(1 << 4)
+#define DEFR8_DRGBS_DU0		(0 << 4)
+#define DEFR8_DEFE8		(1 << 0)
+
 /* -----------------------------------------------------------------------------
  * Display Timing Generation Registers
  */
@@ -442,4 +450,15 @@
 #define GCBCR			0x11098
 #define BCBCR			0x1109c
 
+/* -----------------------------------------------------------------------------
+ * LVDS registers
+ */
+
+#define LVDCR0		0x0000
+#define LVDCR1		0x0004
+#define LVDPLLCR	0x0008
+#define LVDCTRCR	0x000C
+#define LVDCHCR		0x0010
+
+
 #endif /* __RCAR_DU_REGS_H__ */
diff --git a/drivers/i2c/busses/i2c-rcar.c b/drivers/i2c/busses/i2c-rcar.c
index 72a8071..bc3c7ab 100644
--- a/drivers/i2c/busses/i2c-rcar.c
+++ b/drivers/i2c/busses/i2c-rcar.c
@@ -1,6 +1,8 @@
 /*
  *  drivers/i2c/busses/i2c-rcar.c
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
  * Copyright (C) 2012 Renesas Solutions Corp.
  * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
  *
@@ -221,15 +223,20 @@ static int rcar_i2c_clock_calculate(struct rcar_i2c_priv *priv,
 				    struct device *dev)
 {
 	struct clk *clkp = clk_get(NULL, "peripheral_clk");
+	struct i2c_rcar_platform_data *pdata = dev->platform_data;
 	u32 scgd, cdf;
 	u32 round, ick;
 	u32 scl;
+	u32 cdf_width = 0;
 
 	if (!clkp) {
 		dev_err(dev, "there is no peripheral_clk\n");
 		return -EIO;
 	}
 
+	if (pdata && pdata->icccr_cdf_width)
+		cdf_width = pdata->icccr_cdf_width;
+
 	/*
 	 * calculate SCL clock
 	 * see
@@ -245,7 +252,7 @@ static int rcar_i2c_clock_calculate(struct rcar_i2c_priv *priv,
 	 * clkp : peripheral_clk
 	 * F[]  : integer up-valuation
 	 */
-	for (cdf = 0; cdf < 4; cdf++) {
+	for (cdf = 0; cdf < (4 << cdf_width); cdf++) {
 		ick = clk_get_rate(clkp) / (1 + cdf);
 		if (ick < 20000000)
 			goto ick_find;
@@ -287,7 +294,7 @@ scgd_find:
 	/*
 	 * keep icccr value
 	 */
-	priv->icccr = (scgd << 2 | cdf);
+	priv->icccr = (scgd << (2 + cdf_width) | cdf);
 
 	return 0;
 }
diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index a32e0d5..3507a60 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -424,6 +424,8 @@ static void __cpuinit gic_cpu_init(struct gic_chip_data *gic)
 	 */
 	BUG_ON(cpu >= NR_GIC_CPU_IF);
 	cpu_mask = gic_get_cpumask(gic);
+	cpu_mask |= cpu_mask << 8;
+	cpu_mask |= cpu_mask << 16;
 	gic_cpu_map[cpu] = cpu_mask;
 
 	/*
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 6352aea..ddc5664 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1,6 +1,7 @@
 /*
  * Block driver for media (i.e., flash cards)
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright 2002 Hewlett-Packard Company
  * Copyright 2005-2008 Pierre Ossman
  *
@@ -1138,6 +1139,11 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		if (card->host->caps2 & MMC_CAP2_NO_MULTI_READ &&
 		    rq_data_dir(req) == READ)
 			brq->data.blocks = 1;
+		/* Some controllers can't do multiblock reads for 2 blocks
+		 due to hw bugs */
+		if (card->host->caps2 & MMC_CAP2_NO_2BLKS_READ &&
+		    rq_data_dir(req) == READ && brq->data.blocks == 2)
+			brq->data.blocks = 1;
 	}
 
 	if (brq->data.blocks > 1 || do_rel_wr) {
diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index ef10387..91f9bbb 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -27,3 +27,17 @@ config MMC_CLKGATE
 	  support handling this in order for it to be of any use.
 
 	  If unsure, say N.
+
+config MMC_PASSWORDS
+	boolean "MMC card lock/unlock passwords (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select KEYS
+	help
+	  Say Y here to enable the use of passwords to lock and unlock
+	  MMC cards. This uses the access key retention support, using
+	  request_key to look up the key associated with each card.
+
+	  For example, if you have an MMC card that was locked using
+	  Symbian OS on your cell phone, you won't be able to read it
+	  on Linux without this support.
+
diff --git a/drivers/mmc/core/Makefile b/drivers/mmc/core/Makefile
index 38ed210..05f5e6c 100644
--- a/drivers/mmc/core/Makefile
+++ b/drivers/mmc/core/Makefile
@@ -10,3 +10,4 @@ mmc_core-y			:= core.o bus.o host.o \
 				   quirks.o slot-gpio.o
 
 mmc_core-$(CONFIG_DEBUG_FS)	+= debugfs.o
+mmc_core-$(CONFIG_MMC_PASSWORDS) += lock.o
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index c60cee9..5e8a791 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -24,6 +24,7 @@
 #include "core.h"
 #include "sdio_cis.h"
 #include "bus.h"
+#include "lock.h"
 
 #define to_mmc_driver(d)	container_of(d, struct mmc_driver, drv)
 
@@ -55,9 +56,20 @@ static struct device_attribute mmc_dev_attrs[] = {
  * This currently matches any MMC driver to any MMC card - drivers
  * themselves make the decision whether to drive this card in their
  * probe method.
+ *
+ * We also fail for all locked cards; drivers expect to be able to do block
+ * I/O still on probe(), which is not possible while the card is locked.
+ * Device probing must be triggered sometime later to make the card available
+ * to the block driver.
  */
 static int mmc_bus_match(struct device *dev, struct device_driver *drv)
 {
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	if (mmc_card_locked(card)) {
+		dev_dbg(&card->dev, "card is locked; binding is deferred\n");
+		return 0;
+	}
 	return 1;
 }
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1db77e7..bd58c6e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -40,6 +40,7 @@
 #include "mmc_ops.h"
 #include "sd_ops.h"
 #include "sdio_ops.h"
+#include "lock.h"
 
 static struct workqueue_struct *workqueue;
 
@@ -2450,8 +2451,14 @@ static int __init mmc_init(void)
 	if (ret)
 		goto unregister_host_class;
 
+	ret = mmc_register_key_type();
+	if (ret)
+		goto unregister_sdio;
+
 	return 0;
 
+unregister_sdio:
+	sdio_unregister_bus();
 unregister_host_class:
 	mmc_unregister_host_class();
 unregister_bus:
@@ -2464,6 +2471,7 @@ destroy_workqueue:
 
 static void __exit mmc_exit(void)
 {
+	mmc_unregister_key_type();
 	sdio_unregister_bus();
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
diff --git a/drivers/mmc/core/lock.c b/drivers/mmc/core/lock.c
new file mode 100644
index 0000000..580e31b1
--- /dev/null
+++ b/drivers/mmc/core/lock.c
@@ -0,0 +1,191 @@
+/*
+ * linux/drivers/mmc/core/lock.c
+ *
+ * Copyright 2006 Instituto Nokia de Tecnologia (INdT), All Rights Reserved.
+ * Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * MMC password key handling.
+ */
+
+#include <linux/device.h>
+#include <linux/key-type.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+
+#include "mmc_ops.h"
+#include "lock.h"
+
+#define MMC_KEYLEN_MAXBYTES 32
+
+static int mmc_key_instantiate(struct key *key, const void *data, size_t datalen)
+{
+	struct mmc_key_payload *mpayload;
+	int ret;
+
+	ret = -EINVAL;
+	if (datalen <= 0 || datalen > MMC_KEYLEN_MAXBYTES || !data) {
+		pr_debug("Invalid data\n");
+		goto error;
+	}
+
+	ret = key_payload_reserve(key, datalen);
+	if (ret < 0) {
+		pr_debug("ret = %d\n", ret);
+		goto error;
+	}
+
+	ret = -ENOMEM;
+	mpayload = kmalloc(sizeof(*mpayload) + datalen, GFP_KERNEL);
+	if (!mpayload) {
+		pr_debug("Unable to allocate mpayload structure\n");
+		goto error;
+	}
+	mpayload->datalen = datalen;
+	memcpy(mpayload->data, data, datalen);
+
+	rcu_assign_pointer(key->payload.data, mpayload);
+
+	/* ret = 0 if there is no error */
+	ret = 0;
+
+error:
+	return ret;
+}
+
+static int mmc_key_match(const struct key *key, const void *description)
+{
+	return strcmp(key->description, description) == 0;
+}
+
+/*
+ * dispose of the data dangling from the corpse of a mmc key
+ */
+static void mmc_key_destroy(struct key *key)
+{
+	struct mmc_key_payload *mpayload = key->payload.data;
+
+	kfree(mpayload);
+}
+
+static struct key_type mmc_key_type = {
+	.name = "mmc",
+	.def_datalen = MMC_KEYLEN_MAXBYTES,
+	.instantiate = mmc_key_instantiate,
+	.match = mmc_key_match,
+	.destroy = mmc_key_destroy,
+};
+
+int mmc_register_key_type(void)
+{
+	return register_key_type(&mmc_key_type);
+}
+
+void mmc_unregister_key_type(void)
+{
+	unregister_key_type(&mmc_key_type);
+}
+
+static ssize_t
+mmc_lockable_show(struct device *dev, struct device_attribute *att, char *buf)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	return sprintf(buf, "%slocked\n", mmc_card_locked(card) ? "" : "un");
+}
+
+/*
+ * implement MMC password functions: force erase, remove password, change
+ * password, unlock card and assign password.
+ */
+static ssize_t
+mmc_lockable_store(struct device *dev, struct device_attribute *att,
+ const char *data, size_t len)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+	int ret;
+	struct key *mmc_key;
+
+	WARN_ON(!(mmc_card_mmc(card) || mmc_card_sd(card)));
+	WARN_ON(!(card->csd.cmdclass & CCC_LOCK_CARD));
+
+	if(!data)
+		return -EINVAL;
+	if((card->type != MMC_TYPE_MMC) && (card->type != MMC_TYPE_SD))
+		return -EINVAL;
+	if(!(card->csd.cmdclass & CCC_LOCK_CARD))
+		return -EINVAL;
+
+	mmc_claim_host(card->host);
+
+	ret = -EINVAL;
+	if (mmc_card_locked(card) && !strncmp(data, "erase", 5)) {
+		/* forced erase only works while card is locked */
+		mmc_lock_unlock(card, NULL, MMC_LOCK_MODE_ERASE);
+		ret = len;
+	} else if (!mmc_card_locked(card) && !strncmp(data, "remove", 6)) {
+		/* remove password only works while card is unlocked */
+		mmc_key = request_key(&mmc_key_type, "mmc:key", "remove");
+
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_CLR_PWD);
+			if (!ret)
+				ret = len;
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	} else if (!mmc_card_locked(card) && ((!strncmp(data, "assign", 6)) ||
+				(!strncmp(data, "change", 6)))) {
+		/* assign or change */
+		if(!(strncmp(data, "assign", 6)))
+			mmc_key = request_key(&mmc_key_type, "mmc:key", "assign");
+		else
+			mmc_key = request_key(&mmc_key_type, "mmc:key", "change");
+
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_SET_PWD);
+			if (!ret)
+				ret = len;
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	} else if (mmc_card_locked(card) && !strncmp(data, "unlock", 6)) {
+		/* unlock */
+		mmc_key = request_key(&mmc_key_type, "mmc:key", "unlock");
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_UNLOCK);
+			if (ret) {
+				dev_dbg(&card->dev, "Wrong password\n");
+				ret = -EINVAL;
+			}
+			else {
+				mmc_release_host(card->host);
+				device_release_driver(dev);
+				ret = device_attach(dev);
+				if(!ret)
+					return -EINVAL;
+				else
+					return len;
+			}
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	}
+
+	mmc_release_host(card->host);
+	return ret;
+}
+
+
+DEVICE_ATTR(lockable, S_IWUSR | S_IRUGO, mmc_lockable_show, mmc_lockable_store);
diff --git a/drivers/mmc/core/lock.h b/drivers/mmc/core/lock.h
new file mode 100644
index 0000000..cf05137
--- /dev/null
+++ b/drivers/mmc/core/lock.h
@@ -0,0 +1,42 @@
+/*
+ * linux/drivers/mmc/core/lock.h
+ *
+ * Copyright 2006 Instituto Nokia de Tecnologia (INdT), All Rights Reserved.
+ * Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _MMC_CORE_LOCK_H
+#define _MMC_CORE_LOCK_H
+
+#define dev_to_mmc_card(d) container_of(d, struct mmc_card, dev)
+
+#ifdef CONFIG_MMC_PASSWORDS
+
+/* core-internal data */
+struct mmc_key_payload {
+	struct rcu_head rcu; /* RCU destructor */
+	unsigned short datalen; /* length of this data */
+	char data[0]; /* actual data */
+};
+
+int mmc_register_key_type(void);
+void mmc_unregister_key_type(void);
+extern struct device_attribute dev_attr_lockable;
+
+#else
+
+static inline int mmc_register_key_type(void)
+{
+	return 0;
+}
+
+static inline void mmc_unregister_key_type(void)
+{
+}
+
+#endif
+
+#endif
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 54df5ad..1c2102c 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -20,6 +20,7 @@
 
 #include "core.h"
 #include "bus.h"
+#include "lock.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
@@ -638,6 +639,9 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_serial.attr,
 	&dev_attr_enhanced_area_offset.attr,
 	&dev_attr_enhanced_area_size.attr,
+#ifdef CONFIG_MMC_PASSWORDS
+	&dev_attr_lockable.attr,
+#endif
 	NULL,
 };
 
@@ -827,6 +831,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	unsigned int max_dtr;
 	u32 rocr;
 	u8 *ext_csd = NULL;
+	u32 status;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -904,6 +909,15 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
+	/*
+	* Check if card is locked.
+	*/
+	err = mmc_send_status(card, &status);
+	if (err)
+		goto free_card;
+	if (status & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+
 	if (!oldcard) {
 		/*
 		 * Fetch CSD from card.
@@ -1348,7 +1362,8 @@ static int mmc_suspend(struct mmc_host *host)
 			mmc_card_set_sleep(host->card);
 	} else if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
-	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200
+						   | MMC_STATE_LOCKED);
 	mmc_release_host(host);
 
 	return err;
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 69370f4..b91ea23 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -1,7 +1,10 @@
 /*
  *  linux/drivers/mmc/core/mmc_ops.h
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  *  Copyright 2006-2007 Pierre Ossman
+ * MMC password protection (C) 2006 Instituto Nokia de Tecnologia (INdT),
+ * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -13,12 +16,14 @@
 #include <linux/export.h>
 #include <linux/types.h>
 #include <linux/scatterlist.h>
+#include <linux/key.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/mmc.h>
 
 #include "core.h"
+#include "lock.h"
 #include "mmc_ops.h"
 
 static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
@@ -45,6 +50,129 @@ static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
 	return 0;
 }
 
+#ifdef CONFIG_MMC_PASSWORDS
+
+int mmc_lock_unlock(struct mmc_card *card, struct key *key, int mode)
+{
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	struct scatterlist sg;
+	struct mmc_key_payload *mpayload;
+	unsigned long erase_timeout;
+	int err, data_size;
+	u8 *data_buf;
+
+	mpayload = NULL;
+	data_size = 1;
+	if (!(mode & MMC_LOCK_MODE_ERASE)) {
+		mpayload = rcu_dereference(key->payload.data);
+		data_size = 2 + mpayload->datalen;
+	}
+
+	data_buf = kzalloc(data_size, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	data_buf[0] |= mode;
+	if (mode & MMC_LOCK_MODE_UNLOCK)
+		data_buf[0] &= ~MMC_LOCK_MODE_UNLOCK;
+
+	if (!(mode & MMC_LOCK_MODE_ERASE)) {
+		data_buf[1] = mpayload->datalen;
+		memcpy(data_buf + 2, mpayload->data, mpayload->datalen);
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = data_size;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		goto out;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_LOCK_UNLOCK;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1B | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	data.blksz = data_size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_WRITE;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	mmc_set_data_timeout(&data, card);
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, data_buf, data_size);
+	mmc_wait_for_req(card->host, &mrq);
+	err = cmd.error;
+	if (err)
+		goto out;
+	err = data.error;
+	if (err)
+		goto out;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SEND_STATUS;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	/* set timeout for forced erase operation to 3 min. (see MMC spec) */
+	erase_timeout = jiffies + 180 * HZ;
+	do {
+		/* we cannot use "retries" here because the
+		* R1_LOCK_UNLOCK_FAILED bit is cleared by subsequent reads to
+		* the status register, hiding the error condition */
+		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (err)
+			break;
+		/* the other modes don't need timeout checking */
+		if (!(mode & MMC_LOCK_MODE_ERASE))
+			continue;
+		if (time_after(jiffies, erase_timeout)) {
+			dev_dbg(&card->dev, "forced erase timed out\n");
+			err = -ETIMEDOUT;
+			break;
+		}
+	} while (!(cmd.resp[0] & R1_READY_FOR_DATA));
+	if (cmd.resp[0] & R1_LOCK_UNLOCK_FAILED) {
+		dev_dbg(&card->dev, "LOCK_UNLOCK operation failed\n");
+		err = -EIO;
+	}
+
+	if (cmd.resp[0] & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+	else
+		card->state &= ~MMC_STATE_LOCKED;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = 512;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		goto out;
+
+out:
+	kfree(data_buf);
+
+	return err;
+}
+
+#endif /* CONFIG_MMC_PASSWORDS */
+
 int mmc_select_card(struct mmc_card *card)
 {
 	BUG_ON(!card);
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
index 3dd8941..c5070d4 100644
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@ -2,6 +2,8 @@
  *  linux/drivers/mmc/core/mmc_ops.h
  *
  *  Copyright 2006-2007 Pierre Ossman
+ * MMC password protection (C) 2006 Instituto Nokia de Tecnologia (INdT),
+ * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -12,6 +14,8 @@
 #ifndef _MMC_MMC_OPS_H
 #define _MMC_MMC_OPS_H
 
+struct key;
+
 int mmc_select_card(struct mmc_card *card);
 int mmc_deselect_cards(struct mmc_host *host);
 int mmc_go_idle(struct mmc_host *host);
@@ -27,6 +31,7 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
 int mmc_card_sleepawake(struct mmc_host *host, int sleep);
 int mmc_bus_test(struct mmc_card *card, u8 bus_width);
 int mmc_send_hpi_cmd(struct mmc_card *card, u32 *status);
+int mmc_lock_unlock(struct mmc_card *card, struct key *key, int mode);
 
 #endif
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c272c686..131e151 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -21,6 +21,7 @@
 
 #include "core.h"
 #include "bus.h"
+#include "lock.h"
 #include "mmc_ops.h"
 #include "sd.h"
 #include "sd_ops.h"
@@ -704,6 +705,9 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_oemid.attr,
 	&dev_attr_serial.attr,
+#ifdef CONFIG_MMC_PASSWORDS
+	&dev_attr_lockable.attr,
+#endif
 	NULL,
 };
 
@@ -808,26 +812,32 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	int err;
 
 	if (!reinit) {
-		/*
-		 * Fetch SCR from card.
-		 */
-		err = mmc_app_send_scr(card, card->raw_scr);
-		if (err)
-			return err;
 
-		err = mmc_decode_scr(card);
-		if (err)
-			return err;
+		if (!mmc_card_locked(card)) {
 
-		/*
-		 * Fetch and process SD Status register.
-		 */
-		err = mmc_read_ssr(card);
-		if (err)
-			return err;
+			/*
+			* Fetch SCR from card. But if the card is locked,
+			* this command will fail, then the card will be freed.
+			* So we won't send the scr command while card is locked.
+			*/
+			err = mmc_app_send_scr(card, card->raw_scr);
+			if (err)
+				return err;
 
-		/* Erase init depends on CSD and SSR */
-		mmc_init_erase(card);
+			err = mmc_decode_scr(card);
+			if (err)
+				return err;
+
+			/*
+			 * Fetch and process SD Status register.
+			 */
+			err = mmc_read_ssr(card);
+			if (err)
+				return err;
+
+			/* Erase init depends on CSD and SSR */
+			mmc_init_erase(card);
+		}
 
 		/*
 		 * Fetch switch information from card.
@@ -907,6 +917,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 	u32 cid[4];
 	u32 rocr = 0;
+	u32 status;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -944,6 +955,15 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			return err;
 	}
 
+	/*
+	* Check if card is locked.
+	*/
+	err = mmc_send_status(card, &status);
+	if (err)
+		goto free_card;
+	if (status & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+
 	if (!oldcard) {
 		err = mmc_sd_get_csd(host, card);
 		if (err)
@@ -1081,7 +1101,7 @@ static int mmc_sd_suspend(struct mmc_host *host)
 	mmc_claim_host(host);
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
-	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_LOCKED);
 	mmc_release_host(host);
 
 	return 0;
diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
index 0bdc146..8cff05d 100644
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@ -1,6 +1,7 @@
 /*
  * SuperH Mobile SDHI
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright (C) 2009 Magnus Damm
  *
  * This program is free software; you can redistribute it and/or modify
@@ -28,6 +29,7 @@
 #include <linux/mmc/sh_mobile_sdhi.h>
 #include <linux/mfd/tmio.h>
 #include <linux/sh_dma.h>
+#include <linux/sh_dma-desc.h>
 #include <linux/delay.h>
 
 #include "tmio_mmc.h"
@@ -75,6 +77,14 @@ static int sh_mobile_sdhi_get_cd(struct platform_device *pdev)
 	return p->get_cd(pdev);
 }
 
+static int sh_mobile_sdhi_get_ro(struct platform_device *pdev)
+{
+	struct sh_mobile_sdhi_info *p = pdev->dev.platform_data;
+
+	return p->get_ro(pdev);
+
+}
+
 static int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)
 {
 	int timeout = 1000;
@@ -108,6 +118,23 @@ static int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)
 	return 0;
 }
 
+static bool sh_mobile_sdhi_dma_filter(struct dma_chan *chan, void *arg)
+{
+
+	struct platform_device *pdev = to_platform_device(chan->device->dev);
+	struct sh_dmadesc_pdata *pdata = pdev->dev.platform_data;
+	dev_dbg(chan->device->dev, "%s: slave data %p\n", __func__, arg);
+
+	if (!pdata->dma_filter)
+		return false;
+	if (!pdata->dma_filter(pdev))
+		return false;
+
+	chan->private = arg;
+
+	return true;
+}
+
 static void sh_mobile_sdhi_cd_wakeup(const struct platform_device *pdev)
 {
 	mmc_detect_change(dev_get_drvdata(&pdev->dev), msecs_to_jiffies(100));
@@ -167,6 +194,8 @@ static int __devinit sh_mobile_sdhi_probe(struct platform_device *pdev)
 			mmc_data->set_pwr = sh_mobile_sdhi_set_pwr;
 		if (p->get_cd)
 			mmc_data->get_cd = sh_mobile_sdhi_get_cd;
+		if (p->get_ro)
+			mmc_data->get_ro = sh_mobile_sdhi_get_ro;
 
 		if (p->dma_slave_tx > 0 && p->dma_slave_rx > 0) {
 			priv->param_tx.shdma_slave.slave_id = p->dma_slave_tx;
@@ -174,6 +203,7 @@ static int __devinit sh_mobile_sdhi_probe(struct platform_device *pdev)
 			priv->dma_priv.chan_priv_tx = &priv->param_tx.shdma_slave;
 			priv->dma_priv.chan_priv_rx = &priv->param_rx.shdma_slave;
 			priv->dma_priv.alignment_shift = 1; /* 2-byte alignment */
+			mmc_data->dma_filter = sh_mobile_sdhi_dma_filter;
 			mmc_data->dma = &priv->dma_priv;
 		}
 	}
@@ -193,6 +223,10 @@ static int __devinit sh_mobile_sdhi_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto eprobe;
 
+	/* Set 16bit access */
+	if (mmc_data->flags & TMIO_MMC_BUFF_16BITACC_ACTIVE_HIGH)
+		sd_ctrl_write16(host, 0xe4, 1);
+
 	/*
 	 * Allow one or more specific (named) ISRs or
 	 * one or more multiplexed (un-named) ISRs.
diff --git a/drivers/mmc/host/tmio_mmc_dma.c b/drivers/mmc/host/tmio_mmc_dma.c
index fff9286..7f7ef93 100644
--- a/drivers/mmc/host/tmio_mmc_dma.c
+++ b/drivers/mmc/host/tmio_mmc_dma.c
@@ -74,10 +74,12 @@ static void tmio_mmc_start_dma_rx(struct tmio_mmc_host *host)
 
 	if (sg->length < TMIO_MMC_MIN_DMA_LEN) {
 		host->force_pio = true;
-		return;
+		ret = 0;
+		goto pio;
 	}
 
 	tmio_mmc_disable_mmc_irqs(host, TMIO_STAT_RXRDY);
+	tmio_mmc_enable_dma(host, true);
 
 	/* The only sg element can be unaligned, use our bounce buffer then */
 	if (!aligned) {
@@ -106,6 +108,7 @@ pio:
 		/* DMA failed, fall back to PIO */
 		if (ret >= 0)
 			ret = -EIO;
+		tmio_mmc_enable_dma(host, false);
 		host->chan_rx = NULL;
 		dma_release_channel(chan);
 		/* Free the Tx channel too */
@@ -116,7 +119,6 @@ pio:
 		}
 		dev_warn(&host->pdev->dev,
 			 "DMA failed: %d, falling back to PIO\n", ret);
-		tmio_mmc_enable_dma(host, false);
 	}
 
 	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d, sg[%d]\n", __func__,
@@ -151,10 +153,12 @@ static void tmio_mmc_start_dma_tx(struct tmio_mmc_host *host)
 
 	if (sg->length < TMIO_MMC_MIN_DMA_LEN) {
 		host->force_pio = true;
-		return;
+		ret = 0;
+		goto pio;
 	}
 
 	tmio_mmc_disable_mmc_irqs(host, TMIO_STAT_TXRQ);
+	tmio_mmc_enable_dma(host, true);
 
 	/* The only sg element can be unaligned, use our bounce buffer then */
 	if (!aligned) {
@@ -187,6 +191,7 @@ pio:
 		/* DMA failed, fall back to PIO */
 		if (ret >= 0)
 			ret = -EIO;
+		tmio_mmc_enable_dma(host, false);
 		host->chan_tx = NULL;
 		dma_release_channel(chan);
 		/* Free the Rx channel too */
@@ -197,16 +202,53 @@ pio:
 		}
 		dev_warn(&host->pdev->dev,
 			 "DMA failed: %d, falling back to PIO\n", ret);
-		tmio_mmc_enable_dma(host, false);
 	}
 
 	dev_dbg(&host->pdev->dev, "%s(): desc %p, cookie %d\n", __func__,
 		desc, cookie);
 }
 
+static bool tmio_mmc_filter(struct dma_chan *chan, void *arg);
+
 void tmio_mmc_start_dma(struct tmio_mmc_host *host,
 			       struct mmc_data *data)
 {
+	struct tmio_mmc_data *pdata = host->pdata;
+	dma_cap_mask_t mask;
+	struct dma_chan *chan;
+
+	if (pdata->dma && (!host->chan_rx || !host->chan_tx)) {
+		if (host->chan_rx) {
+			chan = host->chan_rx;
+			host->chan_rx = NULL;
+			dma_release_channel(chan);
+		}
+		if (host->chan_tx) {
+			chan = host->chan_tx;
+			host->chan_tx = NULL;
+			dma_release_channel(chan);
+		}
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+
+		if (pdata->dma_filter) {
+			host->chan_rx = dma_request_channel(mask,
+						pdata->dma_filter,
+						pdata->dma->chan_priv_rx);
+
+			host->chan_tx = dma_request_channel(mask,
+						pdata->dma_filter,
+						pdata->dma->chan_priv_tx);
+		} else {
+			host->chan_rx = dma_request_channel(mask,
+						tmio_mmc_filter,
+						pdata->dma->chan_priv_rx);
+
+			host->chan_tx = dma_request_channel(mask,
+						tmio_mmc_filter,
+						pdata->dma->chan_priv_tx);
+		}
+	}
 	if (data->flags & MMC_DATA_READ) {
 		if (host->chan_rx)
 			tmio_mmc_start_dma_rx(host);
@@ -281,7 +323,13 @@ void tmio_mmc_request_dma(struct tmio_mmc_host *host, struct tmio_mmc_data *pdat
 		dma_cap_zero(mask);
 		dma_cap_set(DMA_SLAVE, mask);
 
-		host->chan_tx = dma_request_channel(mask, tmio_mmc_filter,
+		if (pdata->dma_filter)
+			host->chan_tx = dma_request_channel(mask,
+						pdata->dma_filter,
+						    pdata->dma->chan_priv_tx);
+		else
+			host->chan_tx = dma_request_channel(mask,
+						tmio_mmc_filter,
 						    pdata->dma->chan_priv_tx);
 		dev_dbg(&host->pdev->dev, "%s: TX: got channel %p\n", __func__,
 			host->chan_tx);
@@ -289,7 +337,13 @@ void tmio_mmc_request_dma(struct tmio_mmc_host *host, struct tmio_mmc_data *pdat
 		if (!host->chan_tx)
 			return;
 
-		host->chan_rx = dma_request_channel(mask, tmio_mmc_filter,
+		if (pdata->dma_filter)
+			host->chan_rx = dma_request_channel(mask,
+						pdata->dma_filter,
+						    pdata->dma->chan_priv_rx);
+		else
+			host->chan_rx = dma_request_channel(mask,
+						tmio_mmc_filter,
 						    pdata->dma->chan_priv_rx);
 		dev_dbg(&host->pdev->dev, "%s: RX: got channel %p\n", __func__,
 			host->chan_rx);
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index 0d8a9bb..8f9acf8 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -1,6 +1,7 @@
 /*
  * linux/drivers/mmc/host/tmio_mmc_pio.c
  *
+ * Copyright (C) 2013 Renesas Electronics Corporation
  * Copyright (C) 2011 Guennadi Liakhovetski
  * Copyright (C) 2007 Ian Molton
  * Copyright (C) 2004 Ian Molton
@@ -160,45 +161,56 @@ static void tmio_mmc_set_clock(struct tmio_mmc_host *host, int new_clock)
 static void tmio_mmc_clk_stop(struct tmio_mmc_host *host)
 {
 	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
+	struct tmio_mmc_data *pdata = host->pdata;
 
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100) {
+	if (!(pdata->flags & TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL)
+		&& resource_size(res) > 0x100) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0000);
-		msleep(10);
+		if (!(pdata->flags & TMIO_MMC_CLK_NO_SLEEP))
+			msleep(10);
 	}
 
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 &
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
-	msleep(10);
+	if (!(pdata->flags & TMIO_MMC_CLK_NO_SLEEP))
+		msleep(10);
 }
 
 static void tmio_mmc_clk_start(struct tmio_mmc_host *host)
 {
 	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
+	struct tmio_mmc_data *pdata = host->pdata;
 
 	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 |
 		sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
-	msleep(10);
+	if (!(pdata->flags & TMIO_MMC_CLK_NO_SLEEP))
+		msleep(10);
 
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100) {
+	if (!(pdata->flags & TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL)
+		&& resource_size(res) > 0x100) {
 		sd_ctrl_write16(host, CTL_CLK_AND_WAIT_CTL, 0x0100);
-		msleep(10);
+		if (!(pdata->flags & TMIO_MMC_CLK_NO_SLEEP))
+			msleep(10);
 	}
 }
 
 static void tmio_mmc_reset(struct tmio_mmc_host *host)
 {
 	struct resource *res = platform_get_resource(host->pdev, IORESOURCE_MEM, 0);
+	struct tmio_mmc_data *pdata = host->pdata;
 
 	/* FIXME - should we set stop clock reg here */
 	sd_ctrl_write16(host, CTL_RESET_SD, 0x0000);
 	/* implicit BUG_ON(!res) */
-	if (resource_size(res) > 0x100)
+	if (!(pdata->flags & TMIO_MMC_NO_CTL_RESET_SDIO)
+		&& resource_size(res) > 0x100)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0000);
 	msleep(10);
 	sd_ctrl_write16(host, CTL_RESET_SD, 0x0001);
-	if (resource_size(res) > 0x100)
+	if (!(pdata->flags & TMIO_MMC_NO_CTL_RESET_SDIO)
+		&& resource_size(res) > 0x100)
 		sd_ctrl_write16(host, CTL_RESET_SDIO, 0x0001);
 	msleep(10);
 }
@@ -384,9 +396,11 @@ static void tmio_mmc_pio_irq(struct tmio_mmc_host *host)
 
 	/* Transfer the data */
 	if (data->flags & MMC_DATA_READ)
-		sd_ctrl_read16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+		sd_ctrl_read16_rep(host,
+			CTL_SD_DATA_PORT, buf, (count + 1) >> 1);
 	else
-		sd_ctrl_write16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+		sd_ctrl_write16_rep(host,
+			CTL_SD_DATA_PORT, buf, (count + 1) >> 1);
 
 	host->sg_off += count;
 
@@ -462,6 +476,7 @@ void tmio_mmc_do_data_irq(struct tmio_mmc_host *host)
 static void tmio_mmc_data_irq(struct tmio_mmc_host *host)
 {
 	struct mmc_data *data;
+	struct tmio_mmc_data *pdata = host->pdata;
 	spin_lock(&host->lock);
 	data = host->data;
 
@@ -477,9 +492,20 @@ static void tmio_mmc_data_irq(struct tmio_mmc_host *host)
 		 * DATAEND interrupt with the BUSY bit set, in this cases
 		 * waiting for one more interrupt fixes the problem.
 		 */
-		if (!(sd_ctrl_read32(host, CTL_STATUS) & TMIO_STAT_CMD_BUSY)) {
-			tmio_mmc_disable_mmc_irqs(host, TMIO_STAT_DATAEND);
-			tasklet_schedule(&host->dma_complete);
+		if (pdata->flags & TMIO_MMC_CHECK_ILL_FUNC) {
+			if ((sd_ctrl_read32(host, CTL_STATUS)
+			& TMIO_STAT_ILL_FUNC)) {
+				tmio_mmc_disable_mmc_irqs(host,
+					TMIO_STAT_DATAEND);
+				tasklet_schedule(&host->dma_complete);
+			}
+		} else {
+			if (!(sd_ctrl_read32(host, CTL_STATUS)
+			& TMIO_STAT_CMD_BUSY)) {
+				tmio_mmc_disable_mmc_irqs(host,
+					TMIO_STAT_DATAEND);
+				tasklet_schedule(&host->dma_complete);
+			}
 		}
 	} else if (host->chan_rx && (data->flags & MMC_DATA_READ) && !host->force_pio) {
 		tmio_mmc_disable_mmc_irqs(host, TMIO_STAT_DATAEND);
@@ -561,6 +587,9 @@ static void tmio_mmc_card_irq_status(struct tmio_mmc_host *host,
 
 	pr_debug_status(*status);
 	pr_debug_status(*ireg);
+
+	/* Clear the status except the interrupt status */
+	sd_ctrl_write32(host, CTL_STATUS, TMIO_MASK_IRQ);
 }
 
 static bool __tmio_mmc_card_detect_irq(struct tmio_mmc_host *host,
@@ -878,6 +907,8 @@ static int tmio_mmc_get_ro(struct mmc_host *mmc)
 	int ret = mmc_gpio_get_ro(mmc);
 	if (ret >= 0)
 		return ret;
+	if (pdata->get_ro)
+		return pdata->get_ro(host->pdev);
 
 	return !((pdata->flags & TMIO_MMC_WRPROTECT_DISABLE) ||
 		 (sd_ctrl_read32(host, CTL_STATUS) & TMIO_STAT_WRPROTECT));
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 4cdb2af..ef2f97a 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -96,13 +96,28 @@ config MTD_M25P80
 	  if you want to specify device partitioning or to use a device which
 	  doesn't support the JEDEC ID instruction.
 
+choice
+	prompt "Choice Read/Write OPCode"
+	depends on MTD_M25P80
+	default M25PXX_USE_QUAD_READ
+
 config M25PXX_USE_FAST_READ
 	bool "Use FAST_READ OPCode allowing SPI CLK <= 50MHz"
-	depends on MTD_M25P80
-	default y
 	help
 	  This option enables FAST_READ access supported by ST M25Pxx.
 
+config M25PXX_USE_DUAL_READ
+	bool "Use DUAL_READ OPCode"
+	help
+	  This option enables DUAL_READ access supported by Spansion S25FLxx.
+
+config M25PXX_USE_QUAD_READ
+	bool "Use QUAD_READ and QUAD_PAGE_PROGRAM OPCodes"
+	help
+	  This option enables QUAD_READ and QUAD_PAGE_PROGRAM access supported by Spansion S25FLxx.
+
+endchoice
+
 config MTD_SPEAR_SMI
 	tristate "SPEAR MTD NOR Support through SMI controller"
 	depends on PLAT_SPEAR
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 1924d24..93f4368 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -1,4 +1,8 @@
 /*
+ * drivers/mtd/devices/m25p80.c
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
  * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
  *
  * Author: Mike Lavender, mike@steroidmicros.com
@@ -39,9 +43,13 @@
 #define	OPCODE_WREN		0x06	/* Write enable */
 #define	OPCODE_RDSR		0x05	/* Read status register */
 #define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_RDCR		0x35	/* Read configuration register */
 #define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
 #define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_DUAL_READ	0x3b	/* Read data bytes (dual output read) */
+#define	OPCODE_QUAD_READ	0x6b	/* Read data bytes (quad output read) */
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_QPP		0x32	/* Quad Page program */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
@@ -73,14 +81,30 @@
 #define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
 #define	MAX_CMD_SIZE		5
 
-#ifdef CONFIG_M25PXX_USE_FAST_READ
-#define OPCODE_READ 	OPCODE_FAST_READ
-#define FAST_READ_DUMMY_BYTE 1
+/* Needs 8 dummy cycles (8 bits) before read for fast/dual/quad reads */
+#ifdef CONFIG_M25PXX_USE_QUAD_READ
+	#define OPCODE_READ	OPCODE_QUAD_READ
+	#define OPCODE_WRITE	OPCODE_QPP
+	#define READ_DUMMY_BYTE 1
 #else
-#define OPCODE_READ 	OPCODE_NORM_READ
-#define FAST_READ_DUMMY_BYTE 0
+	#ifdef CONFIG_M25PXX_USE_DUAL_READ
+		#define OPCODE_READ	OPCODE_DUAL_READ
+		#define READ_DUMMY_BYTE 1
+	#else
+		#ifdef CONFIG_M25PXX_USE_FAST_READ
+			#define OPCODE_READ	OPCODE_FAST_READ
+			#define READ_DUMMY_BYTE 1
+		#else
+			#define OPCODE_READ	OPCODE_NORM_READ
+			#define READ_DUMMY_BYTE 0
+		#endif
+	#endif
+	#define OPCODE_WRITE	OPCODE_PP
 #endif
 
+
+
+
 #define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
 
 /****************************************************************************/
@@ -141,6 +165,41 @@ static int write_sr(struct m25p *flash, u8 val)
 }
 
 /*
+ * Read the configuration register, returning its value in the location
+ * Return the configuration register value.
+ * Returns negative if error occurred.
+ */
+static int read_cr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RDCR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading CR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
+ * Write status and configuration register 2 bytes
+ * Returns negative if error occurred.
+ */
+static int write_srcr(struct m25p *flash, u8 sr, u8 cr)
+{
+	flash->command[0] = OPCODE_WRSR;
+	flash->command[1] = sr;
+	flash->command[2] = cr;
+
+	return spi_write(flash->spi, flash->command, 3);
+}
+
+/*
  * Set write enable latch with Write Enable command.
  * Returns negative if error occurred.
  */
@@ -354,7 +413,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	 * Should add 1 byte DUMMY_BYTE.
 	 */
 	t[0].tx_buf = flash->command;
-	t[0].len = m25p_cmdsz(flash) + FAST_READ_DUMMY_BYTE;
+	t[0].len = m25p_cmdsz(flash) + READ_DUMMY_BYTE;
 	spi_message_add_tail(&t[0], &m);
 
 	t[1].rx_buf = buf;
@@ -381,7 +440,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 
 	spi_sync(flash->spi, &m);
 
-	*retlen = m.actual_length - m25p_cmdsz(flash) - FAST_READ_DUMMY_BYTE;
+	*retlen = m.actual_length - m25p_cmdsz(flash) - READ_DUMMY_BYTE;
 
 	mutex_unlock(&flash->lock);
 
@@ -425,7 +484,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	write_enable(flash);
 
 	/* Set up the opcode in the write buffer. */
-	flash->command[0] = OPCODE_PP;
+	flash->command[0] = OPCODE_WRITE;
 	m25p_addr2cmd(flash, to, flash->command);
 
 	page_offset = to & (flash->page_size - 1);
@@ -846,12 +905,13 @@ static int __devinit m25p_probe(struct spi_device *spi)
 	flash = kzalloc(sizeof *flash, GFP_KERNEL);
 	if (!flash)
 		return -ENOMEM;
-	flash->command = kmalloc(MAX_CMD_SIZE + FAST_READ_DUMMY_BYTE, GFP_KERNEL);
+	flash->command = kmalloc(MAX_CMD_SIZE + READ_DUMMY_BYTE, GFP_KERNEL);
 	if (!flash->command) {
 		kfree(flash);
 		return -ENOMEM;
 	}
 
+	memset(flash->command, 0x00, MAX_CMD_SIZE + READ_DUMMY_BYTE);
 	flash->spi = spi;
 	mutex_init(&flash->lock);
 	dev_set_drvdata(&spi->dev, flash);
@@ -868,6 +928,29 @@ static int __devinit m25p_probe(struct spi_device *spi)
 		write_sr(flash, 0);
 	}
 
+	/*
+	 * Spansion S25FL512S
+	 */
+	if ((info->jedec_id >> 8) == P_ID_SST_PAGE) {
+		int cr, sr;
+
+		cr = read_cr(flash);
+		write_enable(flash);
+		sr = read_sr(flash);
+#ifdef CONFIG_M25PXX_USE_QUAD_READ
+		cr |= 0x02;
+#else
+		cr &= ~0x02;
+#endif
+		write_srcr(flash, sr, cr);
+
+		while (1) {
+			sr = read_sr(flash);
+			if ((sr & 0x01) == 0)
+				break;
+		}
+	}
+
 	if (data && data->name)
 		flash->mtd.name = data->name;
 	else
diff --git a/drivers/net/ethernet/renesas/Kconfig b/drivers/net/ethernet/renesas/Kconfig
index 24c2305..07bad49 100644
--- a/drivers/net/ethernet/renesas/Kconfig
+++ b/drivers/net/ethernet/renesas/Kconfig
@@ -8,7 +8,8 @@ config SH_ETH
 		(CPU_SUBTYPE_SH7710 || CPU_SUBTYPE_SH7712 || \
 		 CPU_SUBTYPE_SH7763 || CPU_SUBTYPE_SH7619 || \
 		 CPU_SUBTYPE_SH7724 || CPU_SUBTYPE_SH7734 || \
-		 CPU_SUBTYPE_SH7757 || ARCH_R8A7740 || ARCH_R8A7779)
+		 CPU_SUBTYPE_SH7757 || ARCH_R8A7740 || ARCH_R8A7779 || \
+		 ARCH_R8A7790 )
 	select CRC32
 	select NET_CORE
 	select MII
diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index bad8f2e..c64e290 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -1,6 +1,7 @@
 /*
  *  SuperH Ethernet device driver
  *
+ *  Copyright (C) 2013 Renesas Electronics Corporation
  *  Copyright (C) 2006-2012 Nobuhiro Iwamatsu
  *  Copyright (C) 2008-2012 Renesas Solutions Corp.
  *
@@ -78,7 +79,8 @@ static void sh_eth_select_mii(struct net_device *ndev)
 #endif
 
 /* There is CPU dependent code */
-#if defined(CONFIG_CPU_SUBTYPE_SH7724) || defined(CONFIG_ARCH_R8A7779)
+#if defined(CONFIG_CPU_SUBTYPE_SH7724) || defined(CONFIG_ARCH_R8A7779) \
+	|| defined(CONFIG_ARCH_R8A7790)
 #define SH_ETH_RESET_DEFAULT	1
 static void sh_eth_set_duplex(struct net_device *ndev)
 {
@@ -95,7 +97,7 @@ static void sh_eth_set_rate(struct net_device *ndev)
 	struct sh_eth_private *mdp = netdev_priv(ndev);
 	unsigned int bits = ECMR_RTM;
 
-#if defined(CONFIG_ARCH_R8A7779)
+#if defined(CONFIG_ARCH_R8A7779) || defined(CONFIG_ARCH_R8A7790)
 	bits |= ECMR_ELB;
 #endif
 
@@ -976,6 +978,8 @@ static int sh_eth_dev_init(struct net_device *ndev, bool start)
 	if (ret)
 		goto out;
 
+	sh_eth_write(ndev, 0x1, RMIIMODE);
+
 	/* Descriptor format */
 	sh_eth_ring_format(ndev);
 	if (mdp->cd->rpadir)
@@ -1448,6 +1452,14 @@ static int sh_eth_phy_start(struct net_device *ndev)
 
 	/* reset phy - this also wakes it from PDOWN */
 	phy_write(mdp->phydev, MII_BMCR, BMCR_RESET);
+
+#if defined(CONFIG_ARCH_R8A7790)
+	ret = phy_read(mdp->phydev, 0x1e);
+	ret &= ~0xc000;
+	ret |= 0x4000;
+	phy_write(mdp->phydev, 0x1e, ret);
+#endif
+
 	phy_start(mdp->phydev);
 
 	return 0;
diff --git a/drivers/net/ethernet/renesas/sh_eth.h b/drivers/net/ethernet/renesas/sh_eth.h
index bae84fd..2026fc6 100644
--- a/drivers/net/ethernet/renesas/sh_eth.h
+++ b/drivers/net/ethernet/renesas/sh_eth.h
@@ -1,6 +1,7 @@
 /*
  *  SuperH Ethernet device driver
  *
+ *  Copyright (C) 2013 Renesas Electronics Corporation
  *  Copyright (C) 2006-2012 Nobuhiro Iwamatsu
  *  Copyright (C) 2008-2012 Renesas Solutions Corp.
  *
@@ -60,6 +61,9 @@ enum {
 	EDOCR,
 	TFUCR,
 	RFOCR,
+#if defined(CONFIG_ARCH_R8A7790)
+	RMIIMODE,
+#endif
 	FCFTR,
 	RPADIR,
 	TRIMD,
@@ -297,6 +301,9 @@ static const u16 sh_eth_offset_fast_sh4[SH_ETH_MAX_REGISTER_OFFSET] = {
 	[RMCR]	= 0x0058,
 	[TFUCR]	= 0x0064,
 	[RFOCR]	= 0x0068,
+#if defined(CONFIG_ARCH_R8A7790)
+	[RMIIMODE]	= 0x006c,
+#endif
 	[FCFTR]	= 0x0070,
 	[RPADIR]	= 0x0078,
 	[TRIMD]	= 0x007c,
diff --git a/drivers/pinctrl/sh-pfc/pfc-r8a7790.c b/drivers/pinctrl/sh-pfc/pfc-r8a7790.c
index 1656915..a73d735 100644
--- a/drivers/pinctrl/sh-pfc/pfc-r8a7790.c
+++ b/drivers/pinctrl/sh-pfc/pfc-r8a7790.c
@@ -2342,6 +2342,130 @@ static const unsigned int scifb2_data_c_pins[] = {
 static const unsigned int scifb2_data_c_mux[] = {
 	SCIFB2_RXD_C_MARK, SCIFB2_TXD_C_MARK,
 };
+/* - SDHI0 ----------------------------------------------------------------- */
+static const unsigned int sdhi0_ctrl_pins[] = {
+	/* CMD, CLK */
+	RCAR_GP_PIN(3, 1), RCAR_GP_PIN(3, 0),
+};
+static const unsigned int sdhi0_ctrl_mux[] = {
+	SD0_CMD_MARK, SD0_CLK_MARK,
+};
+static const unsigned int sdhi0_data4_pins[] = {
+	/* DAT0, DAT1, DAT2, DAT3 */
+	RCAR_GP_PIN(3, 2), RCAR_GP_PIN(3, 3),
+	RCAR_GP_PIN(3, 4), RCAR_GP_PIN(3, 5),
+};
+static const unsigned int sdhi0_data4_mux[] = {
+	SD0_DAT0_MARK, SD0_DAT1_MARK,
+	SD0_DAT2_MARK, SD0_DAT3_MARK,
+};
+static const unsigned int sdhi0_cd_pins[] = {
+	/* CD */
+	RCAR_GP_PIN(3, 6),
+};
+static const unsigned int sdhi0_cd_mux[] = {
+	SD0_CD_MARK,
+};
+static const unsigned int sdhi0_wp_pins[] = {
+	/* WP */
+	RCAR_GP_PIN(3, 7),
+};
+static const unsigned int sdhi0_wp_mux[] = {
+	SD0_WP_MARK,
+};
+/* - SDHI1 ----------------------------------------------------------------- */
+static const unsigned int sdhi1_ctrl_pins[] = {
+	/* CMD, CLK */
+	RCAR_GP_PIN(3, 9), RCAR_GP_PIN(3, 8),
+};
+static const unsigned int sdhi1_ctrl_mux[] = {
+	SD1_CMD_MARK, SD1_CLK_MARK,
+};
+static const unsigned int sdhi1_data4_pins[] = {
+	/* DAT0, DAT1, DAT2, DAT3 */
+	RCAR_GP_PIN(3, 10), RCAR_GP_PIN(3, 11),
+	RCAR_GP_PIN(3, 12), RCAR_GP_PIN(3, 13),
+};
+static const unsigned int sdhi1_data4_mux[] = {
+	SD1_DAT0_MARK, SD1_DAT1_MARK,
+	SD1_DAT2_MARK, SD1_DAT3_MARK,
+};
+static const unsigned int sdhi1_cd_pins[] = {
+	/* CD */
+	RCAR_GP_PIN(3, 14),
+};
+static const unsigned int sdhi1_cd_mux[] = {
+	SD1_CD_MARK,
+};
+static const unsigned int sdhi1_wp_pins[] = {
+	/* WP */
+	RCAR_GP_PIN(3, 15),
+};
+static const unsigned int sdhi1_wp_mux[] = {
+	SD1_WP_MARK,
+};
+/* - SDHI2 ----------------------------------------------------------------- */
+static const unsigned int sdhi2_ctrl_pins[] = {
+	/* CMD, CLK */
+	RCAR_GP_PIN(3, 17), RCAR_GP_PIN(3, 16),
+};
+static const unsigned int sdhi2_ctrl_mux[] = {
+	SD2_CMD_MARK, SD2_CLK_MARK,
+};
+static const unsigned int sdhi2_data4_pins[] = {
+	/* DAT0, DAT1, DAT2, DAT3 */
+	RCAR_GP_PIN(3, 18), RCAR_GP_PIN(3, 19),
+	RCAR_GP_PIN(3, 20), RCAR_GP_PIN(3, 21),
+};
+static const unsigned int sdhi2_data4_mux[] = {
+	SD2_DAT0_MARK, SD2_DAT1_MARK,
+	SD2_DAT2_MARK, SD2_DAT3_MARK,
+};
+static const unsigned int sdhi2_cd_pins[] = {
+	/* CD */
+	RCAR_GP_PIN(3, 22),
+};
+static const unsigned int sdhi2_cd_mux[] = {
+	SD2_CD_MARK,
+};
+static const unsigned int sdhi2_wp_pins[] = {
+	/* WP */
+	RCAR_GP_PIN(3, 23),
+};
+static const unsigned int sdhi2_wp_mux[] = {
+	SD2_WP_MARK,
+};
+/* - SDHI3 ----------------------------------------------------------------- */
+static const unsigned int sdhi3_ctrl_pins[] = {
+	/* CMD, CLK */
+	RCAR_GP_PIN(3, 25), RCAR_GP_PIN(3, 24),
+};
+static const unsigned int sdhi3_ctrl_mux[] = {
+	SD3_CMD_MARK, SD3_CLK_MARK,
+};
+static const unsigned int sdhi3_data4_pins[] = {
+	/* DAT0, DAT1, DAT2, DAT3 */
+	RCAR_GP_PIN(3, 26), RCAR_GP_PIN(3, 27),
+	RCAR_GP_PIN(3, 28), RCAR_GP_PIN(3, 29),
+};
+static const unsigned int sdhi3_data4_mux[] = {
+	SD3_DAT0_MARK, SD3_DAT1_MARK,
+	SD3_DAT2_MARK, SD3_DAT3_MARK,
+};
+static const unsigned int sdhi3_cd_pins[] = {
+	/* CD */
+	RCAR_GP_PIN(3, 30),
+};
+static const unsigned int sdhi3_cd_mux[] = {
+	SD3_CD_MARK,
+};
+static const unsigned int sdhi3_wp_pins[] = {
+	/* WP */
+	RCAR_GP_PIN(3, 31),
+};
+static const unsigned int sdhi3_wp_mux[] = {
+	SD3_WP_MARK,
+};
 
 static const struct sh_pfc_pin_group pinmux_groups[] = {
 	SH_PFC_PIN_GROUP(eth_link),
@@ -2416,6 +2540,22 @@ static const struct sh_pfc_pin_group pinmux_groups[] = {
 	SH_PFC_PIN_GROUP(scifb2_clk_b),
 	SH_PFC_PIN_GROUP(scifb2_ctrl_b),
 	SH_PFC_PIN_GROUP(scifb2_data_c),
+	SH_PFC_PIN_GROUP(sdhi0_ctrl),
+	SH_PFC_PIN_GROUP(sdhi0_data4),
+	SH_PFC_PIN_GROUP(sdhi0_cd),
+	SH_PFC_PIN_GROUP(sdhi0_wp),
+	SH_PFC_PIN_GROUP(sdhi1_ctrl),
+	SH_PFC_PIN_GROUP(sdhi1_data4),
+	SH_PFC_PIN_GROUP(sdhi1_cd),
+	SH_PFC_PIN_GROUP(sdhi1_wp),
+	SH_PFC_PIN_GROUP(sdhi2_ctrl),
+	SH_PFC_PIN_GROUP(sdhi2_data4),
+	SH_PFC_PIN_GROUP(sdhi2_cd),
+	SH_PFC_PIN_GROUP(sdhi2_wp),
+	SH_PFC_PIN_GROUP(sdhi3_ctrl),
+	SH_PFC_PIN_GROUP(sdhi3_data4),
+	SH_PFC_PIN_GROUP(sdhi3_cd),
+	SH_PFC_PIN_GROUP(sdhi3_wp),
 };
 
 static const char * const eth_groups[] = {
@@ -2520,6 +2660,34 @@ static const char * const scifb2_groups[] = {
 	"scifb2_data_c",
 };
 
+static const char * const sdhi0_groups[] = {
+	"sdhi0_ctrl",
+	"sdhi0_data4",
+	"sdhi0_cd",
+	"sdhi0_wp",
+};
+
+static const char * const sdhi1_groups[] = {
+	"sdhi1_ctrl",
+	"sdhi1_data4",
+	"sdhi1_cd",
+	"sdhi1_wp",
+};
+
+static const char * const sdhi2_groups[] = {
+	"sdhi2_ctrl",
+	"sdhi2_data4",
+	"sdhi2_cd",
+	"sdhi2_wp",
+};
+
+static const char * const sdhi3_groups[] = {
+	"sdhi3_ctrl",
+	"sdhi3_data4",
+	"sdhi3_cd",
+	"sdhi3_wp",
+};
+
 static const struct sh_pfc_function pinmux_functions[] = {
 	SH_PFC_FUNCTION(eth),
 	SH_PFC_FUNCTION(intc),
@@ -2531,6 +2699,10 @@ static const struct sh_pfc_function pinmux_functions[] = {
 	SH_PFC_FUNCTION(scifb0),
 	SH_PFC_FUNCTION(scifb1),
 	SH_PFC_FUNCTION(scifb2),
+	SH_PFC_FUNCTION(sdhi0),
+	SH_PFC_FUNCTION(sdhi1),
+	SH_PFC_FUNCTION(sdhi2),
+	SH_PFC_FUNCTION(sdhi3),
 };
 
 static struct pinmux_cfg_reg pinmux_config_regs[] = {
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 00c0240..30d7d0f 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -342,6 +342,11 @@ config SPI_SH_HSPI
 	help
 	  SPI driver for SuperH HSPI blocks.
 
+config SPI_QSPI
+	tristate "QSPI controller"
+	help
+	  SPI driver for QSPI blocks.
+
 config SPI_SIRF
 	tristate "CSR SiRFprimaII SPI controller"
 	depends on ARCH_PRIMA2
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 9d75d21..8f7b2e7 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -52,6 +52,7 @@ spi-s3c24xx-hw-$(CONFIG_SPI_S3C24XX_FIQ) += spi-s3c24xx-fiq.o
 obj-$(CONFIG_SPI_S3C64XX)		+= spi-s3c64xx.o
 obj-$(CONFIG_SPI_SH)			+= spi-sh.o
 obj-$(CONFIG_SPI_SH_HSPI)		+= spi-sh-hspi.o
+obj-$(CONFIG_SPI_QSPI)			+= spi-qspi.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi-sh-msiof.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi-sh-sci.o
 obj-$(CONFIG_SPI_SIRF)		+= spi-sirf.o
diff --git a/drivers/spi/spi-qspi.c b/drivers/spi/spi-qspi.c
new file mode 100644
index 0000000..af46d84
--- /dev/null
+++ b/drivers/spi/spi-qspi.c
@@ -0,0 +1,1279 @@
+/*
+ * drivers/spi/spi-qspi.c
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * spi-qspi.c QSPI bus driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+
+/* SPI transfer mode definition */
+#define	QSPI_NON_SEQUENTIAL	0	/* non sequential transfer mode */
+#define	QSPI_SINGLE_RW_MODE	1	/* single transfer R/W mode */
+#define	QSPI_DUAL_RW_MODE	2	/* dual transfer R/W mode */
+#define	QSPI_QUAD_RW_MODE	4	/* quad transfer R/W mode */
+
+/* timeout value for sending/receiving data */
+#define QSPI_TIMEOUT		(3 * HZ)
+
+/****************************************/
+/* QSPI register address                */
+/****************************************/
+
+#define	QSPI_BASE	0xE6B10000	/* Base register */
+
+#define QSPI_SPCR	0x00	/* Control register */
+#define	QSPI_SSLP	0x01	/* Slave select polarity register */
+#define	QSPI_SPPCR	0x02	/* Pin control register */
+#define	QSPI_SPSR	0x03	/* Status register */
+#define	QSPI_SPDR	0x04	/* Data register */
+#define	QSPI_SPSCR	0x08	/* Sequence control register */
+#define	QSPI_SPSSR	0x09	/* Sequence status register */
+#define	QSPI_SPBR	0x0A	/* Bit rate register */
+#define	QSPI_SPDCR	0x0B	/* Data control register */
+#define	QSPI_SPCKD	0x0C	/* Clock delay register */
+#define	QSPI_SSLND	0x0D	/* Slave select negation delay register */
+#define	QSPI_SPND	0x0E	/* Next-access delay register */
+#define	QSPI_SPCMD0	0x10	/* Command register 0 */
+#define	QSPI_SPCMD1	0x12	/* Command register 1 */
+#define	QSPI_SPCMD2	0x14	/* Command register 2 */
+#define	QSPI_SPCMD3	0x16	/* Command register 3 */
+#define	QSPI_SPBFCR	0x18	/* Buffer control register */
+#define	QSPI_SPBDCR	0x1A	/* Buffer data count register */
+#define	QSPI_SPBMUL0	0x1C	/* Multiplier setting register 0 */
+#define	QSPI_SPBMUL1	0x20	/* Multiplier setting register 1 */
+#define	QSPI_SPBMUL2	0x24	/* Multiplier setting register 2 */
+#define	QSPI_SPBMUL3	0x28	/* Multiplier setting register 3 */
+
+
+/* SPCR */
+#define QSPI_SPCR_SPRIE		0x80	/* receive interrupt enable */
+#define QSPI_SPCR_SPE		0x40	/* SPI function enable */
+#define QSPI_SPCR_SPTIE		0x20	/* transmit interrupt enable */
+#define QSPI_SPCR_SPEIE		0x10	/* error interrupt enable */
+#define QSPI_SPCR_MSTR		0x08	/* master/slave mode select */
+
+/* SPSR */
+#define QSPI_SPSR_SPRFF_MASK	0x80	/* receive buffer full flag mask */
+#define QSPI_SPSR_SPRFF_FULL	0x80	/* receive buffer is full */
+#define QSPI_SPSR_SPRFF_LESS	0x00	/* receive buffer is not full */
+
+#define QSPI_SPSR_TEND_MASK	0x40	/* transmit end flag mask */
+#define QSPI_SPSR_TEND_COMP	0x40	/* transmission is completed */
+#define QSPI_SPSR_TEND_NCOMP	0x00	/* transmission is not completed */
+
+#define QSPI_SPSR_SPTEF_MASK	0x20	/* transmit buffer empty flag */
+#define QSPI_SPSR_SPTEF_EMPTY	0x20	/* transmit buffer is empty */
+#define QSPI_SPSR_SPTEF_	0x00	/* transmit buffer is not empty */
+
+/* SPCMD */
+#define QSPI_SPCMD_SXXDEN	0xE000	/* delay setting enable */
+#define QSPI_SPCMD_SCKDEN	0x8000	/* clock delay setting enable */
+#define QSPI_SPCMD_SLNDEN	0x4000	/* SSL Negation Delay setting enable */
+#define QSPI_SPCMD_SPNDEN	0x2000	/* next access delay setting enable */
+#define QSPI_SPCMD_LSBF		0x1000	/* LSB first */
+#define QSPI_SPCMD_SSLKP	0x0080	/* SSL signal level keeping */
+#define QSPI_SPCMD_SPB_MASK	0x0F00	/* transfer data length setting mask */
+#define QSPI_SPCMD_SPB_8	0x0000	/* transfer data length is 8 */
+#define QSPI_SPCMD_SPB_16	0x0100	/* transfer data length is 16 */
+#define QSPI_SPCMD_SPB_32	0x0200	/* transfer data length is 32 */
+
+#define QSPI_SPCMD_MOD_SINGLE	0x0000	/* single mode */
+#define QSPI_SPCMD_MOD_DUAL	0x0020	/* dual mode */
+#define QSPI_SPCMD_MOD_QUAD	0x0040	/* quad mode */
+
+#define QSPI_SPCMD_SPRW_MASK	0x0010	/* spi read/write access */
+#define QSPI_SPCMD_SPRW_WRITE	0x0000	/* write operation */
+#define QSPI_SPCMD_SPRW_READ	0x0010	/* read operation */
+
+#define QSPI_SPCMD_CPOL		0x0002	/* negative polarity */
+#define QSPI_SPCMD_CPHA		0x0001	/* data shift on odd edge */
+
+/* SPBFCR */
+#define QSPI_SPBFCR_TXRST	0x80	/* transmit buffer data reset */
+#define QSPI_SPBFCR_RXRST	0x40	/* receive buffer data reset */
+
+#define QSPI_SPBFCR_TXTRG_MASK	0x30	/* transmit buffer triggering number */
+#define QSPI_SPBFCR_TXTRG_31B	0x00	/*   31 bytes (1 byte available) */
+#define QSPI_SPBFCR_TXTRG_0B	0x30	/*   0 byte (32 bytes available) */
+#define QSPI_SPBFCR_RXTRG_MASK	0x07	/* receive buffer triggering number */
+#define QSPI_SPBFCR_RXTRG_1B	0x00	/*   1 byte (31 bytes available) */
+#define QSPI_SPBFCR_RXTRG_2B	0x01	/*   2 bytes (30 bytes available) */
+#define QSPI_SPBFCR_RXTRG_4B	0x02	/*   4 bytes (28 bytes available) */
+#define QSPI_SPBFCR_RXTRG_8B	0x04	/*   8 bytes (24 bytes available) */
+#define QSPI_SPBFCR_RXTRG_32B	0x07	/*   32 bytes (0 byte avaliable) */
+
+#define QSPI_BUFFER_SIZE	32u	/* transmit and receive buffer size */
+
+
+/****************************************/
+/* SPI Flash memory command definitions */
+/****************************************/
+
+#define SPI_FLASH_READ_COM		0x03	/* Read Data */
+#define SPI_FLASH_4READ_COM		0x13	/* Read Data */
+#define SPI_FLASH_FAST_READ_COM		0x0B	/* Read Data at Fast Speed */
+#define SPI_FLASH_4FAST_READ_COM	0x0C	/* Read Data at Fast Speed */
+#define SPI_FLASH_DDRFAST_READ_COM	0x0D	/* DDR Fast Read */
+#define SPI_FLASH_4DDRFAST_READ_COM	0x0E	/* DDR Fast Read */
+#define	SPI_FLASH_DUAL_READ_COM		0x3B	/* Dual Output Read */
+#define	SPI_FLASH_4DUAL_READ_COM	0x3C	/* Dual Output Read */
+#define	SPI_FLASH_QUAD_READ_COM		0x6B	/* Quad Output Read */
+#define	SPI_FLASH_4QUAD_READ_COM	0x6C	/* Quad Output Read */
+#define	SPI_FLASH_DIO_READ_COM		0xBB	/* Dual I/O High Perf. Read */
+#define	SPI_FLASH_4DIO_READ_COM		0xBC	/* Dual I/O High Perf. Read */
+#define	SPI_FLASH_DDRDIO_READ_COM	0xBD	/* DDR Dual I/O Read */
+#define	SPI_FLASH_4DDRDIO_READ_COM	0xBE	/* DDR Dual I/O Read */
+#define	SPI_FLASH_QIO_READ_COM		0xEB	/* Quad I/O High Perf. Read */
+#define	SPI_FLASH_4QIO_READ_COM		0xEC	/* Quad I/O High Perf. Read */
+#define	SPI_FLASH_DDRQIO_READ_COM	0xED	/* DDR Quad I/O Read */
+#define	SPI_FLASH_4DDRQIO_READ_COM	0xEE	/* DDR Quad I/O Read */
+
+#define	SPI_FLASH_PAGE_COM		0x02	/* Page Program */
+#define	SPI_FLASH_4PAGE_COM		0x12	/* Page Program */
+#define	SPI_FLASH_QUAD_PAGE_COM		0x32	/* Quad Page Program */
+#define	SPI_FLASH_QUAD_PAGE2_COM	0x38	/* Quad Page Program */
+#define	SPI_FLASH_4QUAD_PAGE_COM	0x34	/* Quad Page Program */
+
+
+/* device private data */
+struct qspi_priv {
+	void __iomem *addr;
+	u32 max_speed_hz;
+	struct spi_master *master;
+	struct spi_device *spi;
+	struct device *dev;
+	wait_queue_head_t wait;
+	struct clk *clk;
+	unsigned char spsr;
+};
+
+
+/*
+ *		basic function
+ */
+static void qspi_write8(struct qspi_priv *qspi, int reg, u8 val)
+{
+	iowrite8(val, qspi->addr + reg);
+}
+
+static void qspi_write16(struct qspi_priv *qspi, int reg, u16 val)
+{
+	iowrite16(val, qspi->addr + reg);
+}
+
+static void qspi_write32(struct qspi_priv *qspi, int reg, u32 val)
+{
+	iowrite32(val, qspi->addr + reg);
+}
+
+static u8 qspi_read8(struct qspi_priv *qspi, int reg)
+{
+	return ioread8(qspi->addr + reg);
+}
+
+static u16 qspi_read16(struct qspi_priv *qspi, int reg)
+{
+	return ioread16(qspi->addr + reg);
+}
+
+static u32 qspi_read32(struct qspi_priv *qspi, int reg)
+{
+	return ioread32(qspi->addr + reg);
+}
+
+#define qspi_update8(spi, reg, mask, val) \
+	qspi_write8(spi, reg, (qspi_read8(qspi, reg) & ~mask) | val);
+
+static void qspi_enable_irq(struct qspi_priv *qspi, u8 enable)
+{
+	qspi_write8(qspi, QSPI_SPCR, qspi_read8(qspi, QSPI_SPCR) | enable);
+}
+
+static void qspi_disable_irq(struct qspi_priv *qspi, u8 disable)
+{
+	qspi_write8(qspi, QSPI_SPCR, qspi_read8(qspi, QSPI_SPCR) & ~disable);
+}
+
+static unsigned char qspi_calc_spbr(struct qspi_priv *qspi,
+					struct spi_transfer *t)
+{
+	u32 target_rate;
+	int spbr;
+
+	target_rate = t ? t->speed_hz : 0;
+	if (!target_rate)
+		target_rate = qspi->max_speed_hz;
+
+	/* BRDV0 and BRDV1 bits in SPCMD register should be 0 */
+	spbr = DIV_ROUND_UP(clk_get_rate(qspi->clk), 2 * target_rate) - 1;
+	spbr = clamp(spbr, 0, 255);
+
+	return (unsigned char)spbr;
+}
+
+static int qspi_wait_for_interrupt(struct qspi_priv *qspi, u8 wait_mask,
+				   u8 enable_bit)
+{
+	int ret;
+
+	qspi_enable_irq(qspi, enable_bit);
+	ret = wait_event_timeout(qspi->wait,
+		qspi_read8(qspi, QSPI_SPSR) & wait_mask, QSPI_TIMEOUT);
+	if (ret == 0) {
+		dev_err(&qspi->master->dev, "interrupt timeout\n");
+		ret = -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+#define qspi_wait_tr(spi) \
+	qspi_wait_for_interrupt(spi, QSPI_SPSR_SPTEF_MASK, QSPI_SPCR_SPTIE)
+
+#define qspi_wait_rc(spi) \
+	qspi_wait_for_interrupt(spi, QSPI_SPSR_SPRFF_MASK, QSPI_SPCR_SPRIE)
+
+static irqreturn_t qspi_irq(int irq, void *_sr)
+{
+	struct qspi_priv *qspi = (struct qspi_priv *)_sr;
+	unsigned long spsr;
+	irqreturn_t ret = IRQ_NONE;
+	unsigned char disable_irq = 0;
+
+	spsr = qspi_read8(qspi, QSPI_SPSR);
+	if (spsr & QSPI_SPSR_SPRFF_FULL)
+		disable_irq |= QSPI_SPCR_SPRIE;
+	if (spsr & QSPI_SPSR_SPTEF_EMPTY)
+		disable_irq |= QSPI_SPCR_SPTIE;
+
+	if (disable_irq) {
+		ret = IRQ_HANDLED;
+		qspi_disable_irq(qspi, disable_irq);
+		wake_up(&qspi->wait);
+	}
+
+	return ret;
+}
+
+static void qspi_hw_setup(struct qspi_priv *qspi)
+{
+	u16 spcmd;
+
+	/* Disables SPI function */
+	qspi_write8(qspi, QSPI_SPCR, QSPI_SPCR_MSTR);
+
+	/* SSL signal low-active (default values) */
+	qspi_write8(qspi, QSPI_SSLP, 0x00);
+
+	/* Sets output values equal to previous transfer,
+	 * and normal mode (default values) */
+	qspi_write8(qspi, QSPI_SPPCR, 0x06);
+
+	/* Sets the transfer bit rate */
+	qspi_write8(qspi, QSPI_SPBR, qspi_calc_spbr(qspi, NULL));
+
+	/* Disables dummy data transmission (default values) */
+	qspi_write8(qspi, QSPI_SPDCR, 0x00);
+
+	/* Sets the clock delay to 1.5 SPCLK cycles (default values) */
+	qspi_write8(qspi, QSPI_SPCKD, 0x00);
+
+	/* Sets 1 SPCLK cycles (default values) */
+	qspi_write8(qspi, QSPI_SSLND, 0x00);
+
+	/* Sets the next-access delay to 1 SPCLK cycles (default values) */
+	qspi_write8(qspi, QSPI_SPND, 0x00);
+
+	/* Sets the command register */
+	/* Enables delay settings, keeps SSL signal */
+	spcmd = QSPI_SPCMD_SXXDEN | QSPI_SPCMD_SSLKP;
+	if (qspi->spi->mode & SPI_CPHA)
+		/* data shift on odd edge, data latch on even edge */
+		spcmd |= QSPI_SPCMD_CPHA;
+	if (qspi->spi->mode & SPI_CPOL)
+		/* negative polarity */
+		spcmd |= QSPI_SPCMD_CPOL;
+
+	qspi_write16(qspi, QSPI_SPCMD0, spcmd);
+	qspi_write16(qspi, QSPI_SPCMD1, spcmd);
+	/* Resets transfer data length */
+	qspi_write32(qspi, QSPI_SPBMUL0, 0);
+	qspi_write32(qspi, QSPI_SPBMUL1, 0);
+
+	/* Resets transmit and receive buffer */
+	qspi_write8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_TXRST | QSPI_SPBFCR_RXRST);
+	/* Sets transmit and receive buffer to allow normal operation */
+	qspi_write8(qspi, QSPI_SPBFCR, 0x00);
+
+	/* Sets sequence control to 0 (default values) */
+	qspi_write8(qspi, QSPI_SPSCR, 0x00);
+
+	/* Enables SPI function in a master mode */
+	qspi_write8(qspi, QSPI_SPCR, QSPI_SPCR_SPE | QSPI_SPCR_MSTR);
+}
+
+static int qspi_init(struct qspi_priv *qspi,
+			  struct spi_message *msg)
+{
+	struct device *dev = qspi->dev;
+	struct spi_transfer *t = NULL, *t0 = NULL, *t1 = NULL;
+	u16 spclk = 0;
+	u16 spcmd0 = 0, spcmd1 = 0;
+	u32 spbmul0 = 0, spbmul1 = 0;
+	int seqno = 0;	int spi_mode = 0;
+
+	/* Gets spi_transfer pointers */
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+		if (seqno == 0)
+			t0 = t;
+		else if (seqno == 1)
+			t1 = t;
+		else
+			dev_err(dev, "too many sequences\n");
+		seqno++;
+	}
+
+	/* Disables SPI function */
+	qspi_write8(qspi, QSPI_SPCR, QSPI_SPCR_MSTR);
+
+	/* Sets SPCLK phase and polarity settings */
+	if (qspi->spi->mode & SPI_CPHA)
+		/* data shift on odd edge, data latch on even edge */
+		spclk |= QSPI_SPCMD_CPHA;
+	if (qspi->spi->mode & SPI_CPOL)
+		/* negative polarity */
+		spclk |= QSPI_SPCMD_CPOL;
+
+	/**************************************/
+	/* Sets the command register 0 and 1  */
+	/* These depend on SPI Flash memory   */
+	/**************************************/
+
+	/* Checks the instruction/command code */
+	if (t0 && t0->tx_buf) {
+		switch (*(u8 *)(t0->tx_buf)) {
+		case SPI_FLASH_READ_COM:
+		case SPI_FLASH_4READ_COM:
+		case SPI_FLASH_FAST_READ_COM:
+		case SPI_FLASH_4FAST_READ_COM:
+		case SPI_FLASH_PAGE_COM:
+		case SPI_FLASH_4PAGE_COM:
+			spi_mode = QSPI_SINGLE_RW_MODE;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd0 = QSPI_SPCMD_SCKDEN | QSPI_SPCMD_SSLKP | spclk;
+			/* Negates all SSL signal */
+			spcmd1 = QSPI_SPCMD_SLNDEN | QSPI_SPCMD_SPNDEN | spclk;
+			spcmd1 |= QSPI_SPCMD_MOD_SINGLE;
+			break;
+		case SPI_FLASH_DUAL_READ_COM:
+		case SPI_FLASH_4DUAL_READ_COM:
+			spi_mode = QSPI_DUAL_RW_MODE;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd0 = QSPI_SPCMD_SCKDEN | QSPI_SPCMD_SSLKP | spclk;
+			/* Negates all SSL signal */
+			spcmd1 = QSPI_SPCMD_SLNDEN | QSPI_SPCMD_SPNDEN | spclk;
+			spcmd1 |= QSPI_SPCMD_MOD_DUAL | QSPI_SPCMD_SPRW_READ;
+			break;
+		case SPI_FLASH_QUAD_READ_COM:
+		case SPI_FLASH_4QUAD_READ_COM:
+			spi_mode = QSPI_QUAD_RW_MODE;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd0 = QSPI_SPCMD_SCKDEN | QSPI_SPCMD_SSLKP | spclk;
+			/* Negates all SSL signal */
+			spcmd1 = QSPI_SPCMD_SXXDEN | spclk;
+			spcmd1 |= QSPI_SPCMD_MOD_QUAD | QSPI_SPCMD_SPRW_READ;
+			break;
+		case SPI_FLASH_QUAD_PAGE_COM:
+		case SPI_FLASH_QUAD_PAGE2_COM:
+		case SPI_FLASH_4QUAD_PAGE_COM:
+			spi_mode = QSPI_QUAD_RW_MODE;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd0 = QSPI_SPCMD_SXXDEN | QSPI_SPCMD_SSLKP | spclk;
+			/* Negates all SSL signal */
+			spcmd1 = QSPI_SPCMD_SLNDEN | QSPI_SPCMD_SPNDEN | spclk;
+			spcmd1 |= QSPI_SPCMD_MOD_QUAD | QSPI_SPCMD_SPRW_WRITE;
+			break;
+		/* These commands are not supported */
+		case SPI_FLASH_DIO_READ_COM:
+		case SPI_FLASH_4DIO_READ_COM:
+		case SPI_FLASH_DDRDIO_READ_COM:
+		case SPI_FLASH_4DDRDIO_READ_COM:
+		case SPI_FLASH_QIO_READ_COM:
+		case SPI_FLASH_4QIO_READ_COM:
+		case SPI_FLASH_DDRQIO_READ_COM:
+		case SPI_FLASH_4DDRQIO_READ_COM:
+			dev_err(&qspi->master->dev,
+				"not supported spi flash command (%x)\n",
+				*(u8 *)(t0->tx_buf));
+			spi_mode = -EINVAL;
+		default:
+			spi_mode = QSPI_NON_SEQUENTIAL;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd0 = QSPI_SPCMD_SXXDEN | QSPI_SPCMD_SSLKP | spclk;
+			/* Enables clock delay setting, keeps SSL signal */
+			spcmd1 = QSPI_SPCMD_SCKDEN | QSPI_SPCMD_SSLKP | spclk;
+			spcmd1 |= QSPI_SPCMD_MOD_SINGLE;
+			break;
+		}
+		spbmul0 = t0->len;
+	}
+
+	/* Gets number of data to be read/write */
+	if (t1) {
+		if (t1->bits_per_word == 32) {
+			spcmd1 |= QSPI_SPCMD_SPB_32;
+			spbmul1 = t1->len/4;
+		} else if (t1->bits_per_word == 16) {
+			spcmd1 |= QSPI_SPCMD_SPB_16;
+			spbmul1 = t1->len/2;
+		} else {
+			spcmd1 |= QSPI_SPCMD_SPB_8;
+			spbmul1 = t1->len;
+		}
+	}
+
+	if (spi_mode == QSPI_NON_SEQUENTIAL) {
+		/* Sets sequence control to 0 */
+		qspi_write8(qspi, QSPI_SPSCR, 0x00);
+	} else {
+		/* Sets sequence control to 1 */
+		qspi_write8(qspi, QSPI_SPSCR, 0x01);
+	}
+
+	/* First command register is used to transfer command and address */
+	/* It is always in single SPI mode */
+	qspi_write16(qspi, QSPI_SPCMD0, spcmd0);
+	/* Transfer data length */
+	qspi_write32(qspi, QSPI_SPBMUL0, spbmul0);
+
+	/* Second command register is used to transfer or receive data */
+	qspi_write16(qspi, QSPI_SPCMD1, spcmd1);
+	/* Transfer data length */
+	qspi_write32(qspi, QSPI_SPBMUL1, spbmul1);
+
+	dev_dbg(qspi->dev,
+		"spimode=%d, cmd0=%04x, mul0=%d, cmd1=%04x, mul1=%d\n",
+		spi_mode, spcmd0, spbmul0, spcmd1, spbmul1);
+
+	/* Resets transmit and receive buffer */
+	qspi_write8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_TXRST | QSPI_SPBFCR_RXRST);
+	/* Sets transmit and receive buffer to allow normal operation */
+	/* transmit buffer data triggering number set to 0 bytes */
+	/* receive buffer data triggering number set to 32 bytes */
+	qspi_write8(qspi, QSPI_SPBFCR,
+		QSPI_SPBFCR_TXTRG_0B | QSPI_SPBFCR_RXTRG_32B);
+
+	/* Enables SPI function in a master mode */
+	qspi_write8(qspi, QSPI_SPCR, QSPI_SPCR_SPE | QSPI_SPCR_MSTR);
+
+	return spi_mode;
+}
+
+static int qspi_single_tx_msg8(struct qspi_priv *qspi, unsigned count,
+				  const u8 *txbuf, u8 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	remain = count;
+	while (remain) {
+
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			ret = -ETIMEDOUT;
+			break;
+		}
+
+		n = min(remain, QSPI_BUFFER_SIZE);
+
+		if (n >= QSPI_BUFFER_SIZE) {
+			/* sets triggering number to 32 bytes */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_32B);
+		} else {
+			/* sets triggering number to 1 byte */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_1B);
+		}
+
+		for (i = 0; i < n; i++) {
+			/* if tranmit data available */
+			if (txbuf) {
+				qspi_write8(qspi, QSPI_SPDR, *txbuf++);
+			} else {
+				/* dummy write to generate clock */
+				qspi_write8(qspi, QSPI_SPDR, 0x00);
+			}
+		}
+
+		if (n >= QSPI_BUFFER_SIZE) {
+			/* Wait receive */
+			if (qspi_wait_rc(qspi) < 0) {
+				dev_err(dev, "rx full timeout\n");
+				ret = -ETIMEDOUT;
+				break;
+			}
+
+			for (i = 0; i < n; i++) {
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read8(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read8(qspi, QSPI_SPDR);
+				}
+			}
+		} else {
+			for (i = 0; i < n; i++) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read8(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read8(qspi, QSPI_SPDR);
+				}
+			}
+		}
+		remain -= n;
+	}
+
+	return ret;
+}
+
+static int qspi_single_tx_msg16(struct qspi_priv *qspi, unsigned count,
+				  const u16 *txbuf, u16 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	remain = count;
+	while (remain) {
+
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			ret = -ETIMEDOUT;
+			break;
+		}
+
+		n = min(remain, QSPI_BUFFER_SIZE/2);
+
+		if (n >= (QSPI_BUFFER_SIZE/2)) {
+			/* sets triggering number to 32 bytes */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_32B);
+		} else {
+			/* sets triggering number to 2 bytes */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_2B);
+		}
+
+		for (i = 0; i < n; i++) {
+			/* if tranmit data available */
+			if (txbuf) {
+				qspi_write16(qspi, QSPI_SPDR, *txbuf++);
+			} else {
+				/* dummy write to generate clock */
+				qspi_write16(qspi, QSPI_SPDR, 0x00);
+			}
+		}
+
+		if (n >= (QSPI_BUFFER_SIZE/2)) {
+			/* Wait receive */
+			if (qspi_wait_rc(qspi) < 0) {
+				dev_err(dev, "rx full timeout\n");
+				ret = -ETIMEDOUT;
+				break;
+			}
+
+			for (i = 0; i < n; i++) {
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read16(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read16(qspi, QSPI_SPDR);
+				}
+			}
+		} else {
+			for (i = 0; i < n; i++) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read16(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read16(qspi, QSPI_SPDR);
+				}
+			}
+		}
+		remain -= n;
+	}
+
+	return ret;
+}
+
+static int qspi_single_tx_msg32(struct qspi_priv *qspi, unsigned count,
+				  const u32 *txbuf, u32 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	remain = count;
+	while (remain) {
+
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			ret = -ETIMEDOUT;
+			break;
+		}
+
+		n = min(remain, QSPI_BUFFER_SIZE/4);
+
+		if (n >= (QSPI_BUFFER_SIZE/4)) {
+			/* sets triggering number to 32 bytes */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_32B);
+		} else {
+			/* sets triggering number to 4 bytes */
+			qspi_update8(qspi, QSPI_SPBFCR, QSPI_SPBFCR_RXTRG_MASK,
+				QSPI_SPBFCR_RXTRG_4B);
+		}
+
+		for (i = 0; i < n; i++) {
+			/* if tranmit data available */
+			if (txbuf) {
+				qspi_write32(qspi, QSPI_SPDR, *txbuf++);
+			} else {
+				/* dummy write to generate clock */
+				qspi_write32(qspi, QSPI_SPDR, 0x00);
+			}
+		}
+
+		if (n >= (QSPI_BUFFER_SIZE/4)) {
+			/* Wait receive */
+			if (qspi_wait_rc(qspi) < 0) {
+				dev_err(dev, "rx full timeout\n");
+				ret = -ETIMEDOUT;
+				break;
+			}
+
+			for (i = 0; i < n; i++) {
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read32(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read32(qspi, QSPI_SPDR);
+				}
+			}
+		} else {
+
+			for (i = 0; i < n; i++) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+
+				/* if need to read */
+				if (rxbuf) {
+					*rxbuf++ = qspi_read32(qspi, QSPI_SPDR);
+				} else {
+					/* dummy read */
+					qspi_read32(qspi, QSPI_SPDR);
+				}
+			}
+		}
+		remain -= n;
+	}
+
+	return ret;
+}
+
+static int qspi_quad_tx_msg8(struct qspi_priv *qspi, unsigned count,
+				  const u8 *txbuf, u8 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	/* if tranmit data available */
+	if (txbuf) {
+		remain = count;
+		while (remain) {
+
+			/* Wait transmit */
+			if (qspi_wait_tr(qspi) < 0) {
+				dev_err(dev, "tx empty timeout\n");
+				return -ETIMEDOUT;
+			}
+
+			n = min(remain, QSPI_BUFFER_SIZE);
+
+			for (i = 0; i < n; i++)
+				qspi_write8(qspi, QSPI_SPDR, *txbuf++);
+			remain -= n;
+		}
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* if need to read */
+	if (rxbuf) {
+		remain = count;
+		while (remain) {
+
+			n = min(remain, QSPI_BUFFER_SIZE);
+
+			if (n >= QSPI_BUFFER_SIZE) {
+				/* sets triggering number to 32 bytes */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_32B);
+			} else {
+				/* sets triggering number to 1 byte */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_1B);
+			}
+
+			if (n >= QSPI_BUFFER_SIZE) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+
+				for (i = 0; i < n; i++)
+					*rxbuf++ = qspi_read8(qspi, QSPI_SPDR);
+			} else {
+				for (i = 0; i < n; i++) {
+					/* Wait receive */
+					if (qspi_wait_rc(qspi) < 0) {
+						dev_err(dev, "rx full timeout\n");
+						ret = -ETIMEDOUT;
+						break;
+					}
+					*rxbuf++ = qspi_read8(qspi, QSPI_SPDR);
+				}
+			}
+			remain -= n;
+		}
+	}
+
+	return ret;
+}
+
+static int qspi_quad_tx_msg16(struct qspi_priv *qspi, unsigned count,
+				  const u16 *txbuf, u16 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	/* if tranmit data available */
+	if (txbuf) {
+		remain = count;
+		while (remain) {
+
+			/* Wait transmit */
+			if (qspi_wait_tr(qspi) < 0) {
+				dev_err(dev, "tx empty timeout\n");
+				return -ETIMEDOUT;
+			}
+
+			n = min(remain, QSPI_BUFFER_SIZE/2);
+
+			for (i = 0; i < n; i++)
+				qspi_write16(qspi, QSPI_SPDR, *txbuf++);
+
+			remain -= n;
+		}
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* if need to read */
+	if (rxbuf) {
+		remain = count;
+		while (remain) {
+
+			n = min(remain, QSPI_BUFFER_SIZE/2);
+
+			if (n >= (QSPI_BUFFER_SIZE/2)) {
+				/* sets triggering number to 32 bytes */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_32B);
+			} else {
+				/* sets triggering number to 2 bytes */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_2B);
+			}
+
+			if (n >= (QSPI_BUFFER_SIZE/2)) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+
+				for (i = 0; i < n; i++)
+					*rxbuf++ = qspi_read16(qspi, QSPI_SPDR);
+			} else {
+				for (i = 0; i < n; i++) {
+					/* Wait receive */
+					if (qspi_wait_rc(qspi) < 0) {
+						dev_err(dev, "rx full timeout\n");
+						ret = -ETIMEDOUT;
+						break;
+					}
+					*rxbuf++ = qspi_read16(qspi, QSPI_SPDR);
+				}
+			}
+			remain -= n;
+		}
+	}
+
+	return ret;
+}
+
+static int qspi_quad_tx_msg32(struct qspi_priv *qspi, unsigned count,
+				  const u32 *txbuf, u32 *rxbuf)
+{
+	struct device *dev = &qspi->master->dev;
+	unsigned remain, i, n;
+	int ret = 0;
+
+	dev_dbg(qspi->dev, "%s count=%d, txbuf=%lx, rxbuf=%lx\n",
+		__func__, count, (ulong)txbuf, (ulong)rxbuf);
+
+	/* if tranmit data available */
+	if (txbuf) {
+		remain = count;
+		while (remain) {
+
+			/* Wait transmit */
+			if (qspi_wait_tr(qspi) < 0) {
+				dev_err(dev, "tx empty timeout\n");
+				return -ETIMEDOUT;
+			}
+
+			n = min(remain, QSPI_BUFFER_SIZE/4);
+
+			for (i = 0; i < n; i++)
+				qspi_write32(qspi, QSPI_SPDR, *txbuf++);
+
+			remain -= n;
+		}
+		/* Wait transmit */
+		if (qspi_wait_tr(qspi) < 0) {
+			dev_err(dev, "tx empty timeout\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* if need to read */
+	if (rxbuf) {
+		remain = count;
+		while (remain) {
+
+			n = min(remain, QSPI_BUFFER_SIZE/4);
+
+			if (n >= (QSPI_BUFFER_SIZE/4)) {
+				/* sets triggering number to 32 bytes */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_32B);
+			} else {
+				/* sets triggering number to 4 bytes */
+				qspi_update8(qspi, QSPI_SPBFCR,
+					QSPI_SPBFCR_RXTRG_MASK,
+					QSPI_SPBFCR_RXTRG_4B);
+			}
+
+			if (n >= (QSPI_BUFFER_SIZE/4)) {
+				/* Wait receive */
+				if (qspi_wait_rc(qspi) < 0) {
+					dev_err(dev, "rx full timeout\n");
+					ret = -ETIMEDOUT;
+					break;
+				}
+
+				for (i = 0; i < n; i++)
+					*rxbuf++ = qspi_read32(qspi, QSPI_SPDR);
+			} else {
+				for (i = 0; i < n; i++) {
+					/* Wait receive */
+					if (qspi_wait_rc(qspi) < 0) {
+						dev_err(dev, "rx full timeout\n");
+						ret = -ETIMEDOUT;
+						break;
+					}
+					*rxbuf++ = qspi_read32(qspi, QSPI_SPDR);
+				}
+			}
+			remain -= n;
+		}
+	}
+
+	return ret;
+}
+
+
+/*
+ *		spi master function
+ */
+static int qspi_prepare_transfer(struct spi_master *master)
+{
+	struct qspi_priv *qspi = spi_master_get_devdata(master);
+
+	pm_runtime_get_sync(qspi->dev);
+	return 0;
+}
+
+static int qspi_unprepare_transfer(struct spi_master *master)
+{
+	struct qspi_priv *qspi = spi_master_get_devdata(master);
+
+	pm_runtime_put_sync(qspi->dev);
+	return 0;
+}
+
+static int qspi_transfer_one_message(struct spi_master *master,
+				     struct spi_message *msg)
+{
+	struct qspi_priv *qspi = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	int spi_mode = 0;
+	int seqno;
+	int ret;
+
+	dev_dbg(qspi->dev, "%s\n", __func__);
+
+	spi_mode = qspi_init(qspi, msg);
+	if (spi_mode < 0)
+		return spi_mode;
+
+	seqno = 0;
+	ret = 0;
+	list_for_each_entry(t, &msg->transfers, transfer_list) {
+
+		/* single mode transfer */
+		if (spi_mode == QSPI_NON_SEQUENTIAL
+			|| spi_mode == QSPI_SINGLE_RW_MODE
+			|| seqno == 0) {
+			if (t->bits_per_word == 32)
+				ret = qspi_single_tx_msg32(qspi, t->len / 4,
+					t->tx_buf, t->rx_buf);
+			else if (t->bits_per_word == 16)
+				ret = qspi_single_tx_msg16(qspi, t->len / 2,
+					t->tx_buf, t->rx_buf);
+			else
+				ret = qspi_single_tx_msg8(qspi, t->len,
+					t->tx_buf, t->rx_buf);
+		} else {
+		/* dual and quad modes are same transfer procedure */
+			if (t->bits_per_word == 32)
+				ret = qspi_quad_tx_msg32(qspi, t->len / 4,
+					t->tx_buf, t->rx_buf);
+			else if (t->bits_per_word == 16)
+				ret = qspi_quad_tx_msg16(qspi, t->len / 2,
+					t->tx_buf, t->rx_buf);
+			else
+				ret = qspi_quad_tx_msg8(qspi, t->len,
+					t->tx_buf, t->rx_buf);
+		}
+
+		if (ret)
+			break;
+
+		msg->actual_length += t->len;
+
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+
+		seqno++;
+	}
+
+	msg->status = ret;
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+static int qspi_setup(struct spi_device *spi)
+{
+	struct qspi_priv *qspi = spi_master_get_devdata(spi->master);
+	struct device *dev = qspi->dev;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	if ((spi->bits_per_word < 8) || (spi->bits_per_word > 32)) {
+		dev_err(dev, "%d bits_per_word is not supported\n",
+			spi->bits_per_word);
+		return -EIO;
+	}
+
+	qspi->spi = spi;
+	qspi->max_speed_hz = spi->max_speed_hz;
+
+	qspi_hw_setup(qspi);
+
+	dev_dbg(dev, "%s setup\n", spi->modalias);
+
+	return 0;
+}
+
+static void qspi_cleanup(struct spi_device *spi)
+{
+	struct qspi_priv *qspi = spi_master_get_devdata(spi->master);
+	struct device *dev = qspi->dev;
+
+	dev_dbg(dev, "%s cleanup\n", spi->modalias);
+}
+
+
+static int __devinit qspi_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct spi_master *master;
+	struct qspi_priv *qspi;
+	struct clk *clk;
+	int ret, irq;
+
+	/* get base addr */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "invalid resource\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "platform_get_irq failed\n");
+		return -ENODEV;
+	}
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*qspi));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_alloc_master error.\n");
+		return -ENOMEM;
+	}
+
+	clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "qspi is required\n");
+		ret = PTR_ERR(clk);
+		goto error0;
+	}
+
+	qspi = spi_master_get_devdata(master);
+	dev_set_drvdata(&pdev->dev, qspi);
+
+	/* init qspi */
+	qspi->master	= master;
+	qspi->dev	= &pdev->dev;
+	qspi->clk	= clk;
+	qspi->addr	= devm_ioremap(qspi->dev,
+				       res->start, resource_size(res));
+	if (!qspi->addr) {
+		dev_err(&pdev->dev, "ioremap error.\n");
+		ret = -ENOMEM;
+		goto error1;
+	}
+	init_waitqueue_head(&qspi->wait);
+
+	master->num_chipselect	= 1;
+	master->bus_num		= pdev->id;
+	master->setup		= qspi_setup;
+	master->cleanup		= qspi_cleanup;
+	master->mode_bits	= SPI_CPOL | SPI_CPHA;
+	master->prepare_transfer_hardware	= qspi_prepare_transfer;
+	master->transfer_one_message		= qspi_transfer_one_message;
+	master->unprepare_transfer_hardware	= qspi_unprepare_transfer;
+
+	ret = request_irq(irq, qspi_irq, 0, dev_name(&pdev->dev), qspi);
+	if (ret) {
+		dev_dbg(&pdev->dev, "request_irq failed\n");
+		goto error2;
+	}
+
+	ret = spi_register_master(master);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_register_master error.\n");
+		goto error3;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	dev_info(&pdev->dev, "probed\n");
+
+	return 0;
+
+ error3:
+	free_irq(irq, qspi);
+ error2:
+	devm_iounmap(qspi->dev, qspi->addr);
+ error1:
+	clk_put(clk);
+ error0:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int __devexit qspi_remove(struct platform_device *pdev)
+{
+	struct qspi_priv *qspi = dev_get_drvdata(&pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	clk_put(qspi->clk);
+	free_irq(platform_get_irq(pdev, 0), qspi);
+	spi_unregister_master(qspi->master);
+	devm_iounmap(qspi->dev, qspi->addr);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int qspi_suspend(struct device *dev)
+{
+	struct qspi_priv *qspi = dev_get_drvdata(dev);
+	int ret;
+
+	ret = spi_master_suspend(qspi->master);
+	if (ret) {
+		dev_warn(dev, "cannot suspend master\n");
+		return ret;
+	}
+
+	dev_dbg(dev, "suspended\n");
+	return 0;
+}
+
+static int qspi_resume(struct device *dev)
+{
+	struct qspi_priv *qspi = dev_get_drvdata(dev);
+	int ret;
+
+	/* Start the queue running */
+	ret = spi_master_resume(qspi->master);
+	if (ret)
+		dev_err(dev, "problem starting queue (%d)\n", ret);
+	else
+		dev_dbg(dev, "resumed\n");
+
+	return ret;
+}
+#endif	/* CONFIG_PM */
+
+#ifdef CONFIG_PM_RUNTIME
+static int qspi_runtime_suspend(struct device *dev)
+{
+	struct qspi_priv *qspi = dev_get_drvdata(dev);
+
+	clk_disable(qspi->clk);
+
+	return 0;
+}
+
+static int qspi_runtime_resume(struct device *dev)
+{
+	struct qspi_priv *qspi = dev_get_drvdata(dev);
+
+	clk_enable(qspi->clk);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops qspi_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(qspi_suspend, qspi_resume)
+	SET_RUNTIME_PM_OPS(qspi_runtime_suspend, qspi_runtime_resume, NULL)
+};
+
+static struct platform_driver qspi_driver = {
+	.probe = qspi_probe,
+	.remove = __devexit_p(qspi_remove),
+	.driver = {
+		.name = "qspi",
+		.owner = THIS_MODULE,
+		.pm = &qspi_dev_pm_ops,
+	},
+};
+module_platform_driver(qspi_driver);
+
+MODULE_DESCRIPTION("qspi bus driver");
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 76316a3..74c4a56 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -20,6 +20,7 @@ config USB_ARCH_HAS_OHCI
 	default y if ARCH_CNS3XXX
 	default y if PLAT_SPEAR
 	default y if ARCH_EXYNOS
+	default y if ARCH_R8A7790
 	# PPC:
 	default y if STB03xxx
 	default y if PPC_MPC52xx
@@ -48,6 +49,7 @@ config USB_ARCH_HAS_EHCI
 	default y if SPARC_LEON
 	default y if ARCH_MMP
 	default y if MACH_LOONGSON1
+	default y if ARCH_R8A7790
 	default PCI
 
 # some non-PCI HCDs implement xHCI
diff --git a/include/drm/drm_fb_cma_helper.h b/include/drm/drm_fb_cma_helper.h
index 76c7098..e31a936 100644
--- a/include/drm/drm_fb_cma_helper.h
+++ b/include/drm/drm_fb_cma_helper.h
@@ -11,7 +11,7 @@ struct drm_mode_fb_cmd2;
 
 struct drm_fbdev_cma *drm_fbdev_cma_init(struct drm_device *dev,
 	unsigned int preferred_bpp, unsigned int num_crtc,
-	unsigned int max_conn_count);
+	unsigned int max_conn_count, unsigned int fb_size_mult);
 void drm_fbdev_cma_fini(struct drm_fbdev_cma *fbdev_cma);
 
 void drm_fbdev_cma_restore_mode(struct drm_fbdev_cma *fbdev_cma);
diff --git a/include/drm/drm_fb_helper.h b/include/drm/drm_fb_helper.h
index 5120b01..929f663 100644
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
@@ -92,6 +92,8 @@ void drm_fb_helper_fini(struct drm_fb_helper *helper);
 int drm_fb_helper_blank(int blank, struct fb_info *info);
 int drm_fb_helper_pan_display(struct fb_var_screeninfo *var,
 			      struct fb_info *info);
+int drm_fb_helper_ioctl(struct fb_info *info, unsigned int cmd,
+			unsigned long arg);
 int drm_fb_helper_set_par(struct fb_info *info);
 int drm_fb_helper_check_var(struct fb_var_screeninfo *var,
 			    struct fb_info *info);
diff --git a/include/linux/i2c/i2c-rcar.h b/include/linux/i2c/i2c-rcar.h
index 496f5c2..6bf5b89 100644
--- a/include/linux/i2c/i2c-rcar.h
+++ b/include/linux/i2c/i2c-rcar.h
@@ -5,6 +5,9 @@
 
 struct i2c_rcar_platform_data {
 	u32 bus_speed;
+	u32 icccr_cdf_width;
+#define I2C_RCAR_ICCCR_IS_2BIT	0
+#define I2C_RCAR_ICCCR_IS_3BIT	1
 };
 
 #endif /* __I2C_R_CAR_H__ */
diff --git a/include/linux/mfd/tmio.h b/include/linux/mfd/tmio.h
index d83af39..9cf576b 100644
--- a/include/linux/mfd/tmio.h
+++ b/include/linux/mfd/tmio.h
@@ -7,6 +7,7 @@
 #include <linux/jiffies.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
+#include <linux/dmaengine.h>
 
 #define tmio_ioread8(addr) readb(addr)
 #define tmio_ioread16(addr) readw(addr)
@@ -82,6 +83,21 @@
  */
 #define TMIO_MMC_USE_GPIO_CD		(1 << 5)
 
+/* Switch the register of controller to access the buffer of 16 bit. */
+#define TMIO_MMC_BUFF_16BITACC_ACTIVE_HIGH	(1 << 6)
+
+/* NO_CTL_RESET_SDIO register don't work. */
+#define TMIO_MMC_NO_CTL_RESET_SDIO	(1 << 7)
+
+/* CTL_CLK_AND_WAIT_CTL register don't work. */
+#define TMIO_MMC_NO_CTL_CLK_AND_WAIT_CTL	(1 << 8)
+
+/* Some controllers check the ILL_FUNC bit. */
+#define TMIO_MMC_CHECK_ILL_FUNC		(1 << 9)
+
+/* The start or stop of SD clock don't wait 10msec. */
+#define TMIO_MMC_CLK_NO_SLEEP		(1 << 10)
+
 int tmio_core_mmc_enable(void __iomem *cnf, int shift, unsigned long base);
 int tmio_core_mmc_resume(void __iomem *cnf, int shift, unsigned long base);
 void tmio_core_mmc_pwr(void __iomem *cnf, int shift, int state);
@@ -110,7 +126,9 @@ struct tmio_mmc_data {
 	void (*set_pwr)(struct platform_device *host, int state);
 	void (*set_clk_div)(struct platform_device *host, int state);
 	int (*get_cd)(struct platform_device *host);
+	int (*get_ro)(struct platform_device *host);
 	int (*write16_hook)(struct tmio_mmc_host *host, int addr);
+	bool (*dma_filter)(struct dma_chan *chan, void *arg);
 	/* clock management callbacks */
 	int (*clk_enable)(struct platform_device *pdev, unsigned int *f);
 	void (*clk_disable)(struct platform_device *pdev);
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index b5292f3..2962734 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -221,6 +221,7 @@ struct mmc_card {
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
 #define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
+#define MMC_STATE_LOCKED	(1<<10)		/* card is currently locked */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -388,6 +389,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
+#define mmc_card_locked(c)	((c)->state & MMC_STATE_LOCKED)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -400,6 +402,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
+#define mmc_card_set_locked(c)	((c)->state |= MMC_STATE_LOCKED)
 
 #define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
 /*
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 65c64ee..b093dd2 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -261,6 +261,7 @@ struct mmc_host {
 #define MMC_CAP2_HC_ERASE_SZ	(1 << 9)	/* High-capacity erase size */
 #define MMC_CAP2_CD_ACTIVE_HIGH	(1 << 10)	/* Card-detect signal active high */
 #define MMC_CAP2_RO_ACTIVE_HIGH	(1 << 11)	/* Write-protect signal active high */
+#define MMC_CAP2_NO_2BLKS_READ	(1 << 12)	/* Singleblock read is only 2 blocks */
 
 	mmc_pm_flag_t		pm_caps;	/* supported pm features */
 	unsigned int        power_notify_type;
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b822a2c..8e6ffb2 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -446,4 +446,12 @@ struct _mmc_csd {
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
+/*
+ * MMC_LOCK_UNLOCK modes
+ */
+#define MMC_LOCK_MODE_ERASE	(1<<3)
+#define MMC_LOCK_MODE_UNLOCK	(1<<2)
+#define MMC_LOCK_MODE_CLR_PWD	(1<<1)
+#define MMC_LOCK_MODE_SET_PWD	(1<<0)
+
 #endif /* LINUX_MMC_MMC_H */
diff --git a/include/linux/mmc/sh_mobile_sdhi.h b/include/linux/mmc/sh_mobile_sdhi.h
index b65679f..8c89212 100644
--- a/include/linux/mmc/sh_mobile_sdhi.h
+++ b/include/linux/mmc/sh_mobile_sdhi.h
@@ -29,6 +29,7 @@ struct sh_mobile_sdhi_info {
 	struct tmio_mmc_data *pdata;
 	void (*set_pwr)(struct platform_device *pdev, int state);
 	int (*get_cd)(struct platform_device *pdev);
+	int (*get_ro)(struct platform_device *pdev);
 
 	/* callbacks for board specific setup code */
 	int (*init)(struct platform_device *pdev,
diff --git a/include/linux/sh_audma-pp.h b/include/linux/sh_audma-pp.h
new file mode 100644
index 0000000..16dc7ba
--- /dev/null
+++ b/include/linux/sh_audma-pp.h
@@ -0,0 +1,58 @@
+/*
+ * include/linux/sh_audma-pp.h
+ *     This file is header file for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the include/linux/sh_dma.h
+ *
+ * Header for the new SH dmaengine driver
+ *
+ * Copyright (C) 2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef SH_AUDMAPP_H
+#define SH_AUDMAPP_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/shdma-base.h>
+#include <linux/types.h>
+
+struct device;
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct sh_audmapp_slave {
+	struct shdma_slave	shdma_slave;	/* Set by the platform */
+};
+
+struct sh_audmapp_slave_config {
+	int		slave_id;
+	dma_addr_t	sar;
+	dma_addr_t	dar;
+	u32		chcr;
+};
+
+struct sh_audmapp_channel {
+	unsigned int	offset;
+};
+
+struct sh_audmapp_pdata {
+	const struct sh_audmapp_slave_config *slave;
+	int slave_num;
+	const struct sh_audmapp_channel *channel;
+	int channel_num;
+};
+
+/* DMA register */
+#define PDMASAR		0x00
+#define PDMADAR		0x04
+#define PDMACHCR	0x0c
+
+/* PDMACHCR definitions */
+#define PDMACHCR_DE		(1<<0)
+
+#endif /* SH_AUDMAPP_H */
diff --git a/include/linux/sh_dma-desc.h b/include/linux/sh_dma-desc.h
new file mode 100644
index 0000000..398ff76
--- /dev/null
+++ b/include/linux/sh_dma-desc.h
@@ -0,0 +1,75 @@
+/*
+ * include/linux/sh_dma-desc.h
+ *     This file is header file for SYS-DMAC/Audio-DMAC peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the include/linux/sh_dma.h
+ *
+ * Header for the new SH dmaengine driver
+ *
+ * Copyright (C) 2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef SH_DMA_DESC_H
+#define SH_DMA_DESC_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/shdma-base.h>
+#include <linux/types.h>
+
+struct device;
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct sh_dmadesc_slave {
+	struct shdma_slave	shdma_slave;	/* Set by the platform */
+};
+
+/*
+ * Supplied by platforms to specify, how a DMA channel has to be configured for
+ * a certain peripheral
+ */
+struct sh_dmadesc_slave_config {
+	int		slave_id;
+	dma_addr_t	addr;
+	u32		chcr;
+	char		mid_rid;
+};
+
+struct sh_dmadesc_channel {
+	unsigned int	offset;
+	unsigned int	dmars;
+	unsigned int	dmars_bit;
+	unsigned int	chclr_offset;
+};
+
+struct sh_dmadesc_pdata {
+	const struct sh_dmadesc_slave_config *slave;
+	int slave_num;
+	const struct sh_dmadesc_channel *channel;
+	int channel_num;
+	unsigned int ts_low_shift;
+	unsigned int ts_low_mask;
+	unsigned int ts_high_shift;
+	unsigned int ts_high_mask;
+	const unsigned int *ts_shift;
+	int ts_shift_num;
+	u16 dmaor_init;
+	unsigned int chcr_offset;
+	u32 chcr_ie_bit;
+
+	unsigned int dmaor_is_32bit:1;
+	unsigned int needs_tend_set:1;
+	unsigned int no_dmars:1;
+	unsigned int chclr_present:1;
+	unsigned int slave_only:1;
+
+	bool (*dma_filter)(struct platform_device *pdev);
+	struct clk *(*clk_get)(struct platform_device *pdev);
+};
+
+#endif	/* SH_DMA_DESC_H */
diff --git a/include/linux/shdmapp-base.h b/include/linux/shdmapp-base.h
new file mode 100644
index 0000000..ee2806e
--- /dev/null
+++ b/include/linux/shdmapp-base.h
@@ -0,0 +1,35 @@
+/*
+ * include/linux/shdmapp-base.h
+ *     This file is header file for DMA Engine driver base library of
+ *     DMAC that is transferred between peripheral and peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the include/linux/shdma-base.h
+ *
+ * Dmaengine driver base library for DMA controllers, found on SH-based SoCs
+ *
+ * extracted from shdma.c and headers
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SHDMAPP_BASE_H
+#define SHDMAPP_BASE_H
+
+#include <linux/shdma-base.h>
+
+void shdmapp_chan_probe(struct shdma_dev *sdev,
+			   struct shdma_chan *schan, int id);
+void shdmapp_chan_remove(struct shdma_chan *schan);
+int shdmapp_init(struct device *dev, struct shdma_dev *sdev, int chan_num);
+void shdmapp_cleanup(struct shdma_dev *sdev);
+
+#endif /* SHDMAPP_BASE_H */
diff --git a/include/sound/sh_scu.h b/include/sound/sh_scu.h
new file mode 100644
index 0000000..9e6ae85
--- /dev/null
+++ b/include/sound/sh_scu.h
@@ -0,0 +1,2086 @@
+/*
+ * include/sound/sh_scu.h
+ *     This file is header file for SCU peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef SH_SCU_H
+#define SH_SCU_H
+
+#include <linux/sh_dma-desc.h>
+#include <mach/r8a7790.h>
+
+/************************************************************************
+
+	define
+
+************************************************************************/
+/*
+ *	ALSA
+ */
+/* buffer information */
+#define SCU_PERIOD_BYTES_MIN	(16 * 1024)
+#define SCU_PERIOD_BYTES_MAX	(16 * 1024)
+#define SCU_PERIODS_MIN		4
+#define SCU_PERIODS_MAX		4
+#define SCU_BUFFER_BYTES_MAX	(SCU_PERIOD_BYTES_MAX * SCU_PERIODS_MAX)
+
+/* scu dapm route information */
+/* playback route */
+#define	W_SSI0			0x00000001
+#define	W_SRC0			0x00000002
+#define	W_DVC0			0x00000004
+#define RP_MEM_SSI0		W_SSI0
+#define RP_MEM_SRC0_SSI0	(W_SSI0 | W_SRC0)
+#define RP_MEM_SRC0_DVC0_SSI0	(W_SSI0 | W_SRC0 | W_DVC0)
+/* capture route */
+#define	W_SSI1			0x00000001
+#define	W_SRC1			0x00000002
+#define	W_DVC1			0x00000004
+#define RC_SSI1_MEM		W_SSI1
+#define RC_SSI1_SRC1_MEM	(W_SSI1 | W_SRC1)
+#define RC_SSI1_SRC1_DVC1_MEM	(W_SSI1 | W_SRC1 | W_DVC1)
+
+/* dma direction */
+#define	DMA_DIR(d)	((d == 0) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
+
+/* IP channel */
+#define	MAXCH_SRC	10
+#define	MAXCH_CTU	8
+#define	MAXCH_CMD	2
+#define	MAXCH_SSI	10
+#define	MAXCH_SSIDATA	22	/* SSI0,1,2,9=4ch, SSI3-8=1ch */
+
+/*
+ *	SCU
+ */
+/* register offset */
+#define	SRC0IN_BUSIF_MODE	0x0000
+#define	SRC0OUT_BUSIF_MODE	0x0004
+#define	SRC0_BUSIF_DALIGN	0x0008
+#define	SRC0_MODE		0x000c
+#define	SRC0_CONTROL		0x0010
+#define	SRC0_STATUS		0x0014
+#define	SRC0_INT_ENABLE0	0x0018
+#define	SRC1IN_BUSIF_MODE	0x0020
+#define	SRC1OUT_BUSIF_MODE	0x0024
+#define	SRC1_BUSIF_DALIGN	0x0028
+#define	SRC1_MODE		0x002c
+#define	SRC1_CONTROL		0x0030
+#define	SRC1_STATUS		0x0034
+#define	SRC1_INT_ENABLE0	0x0038
+#define	SRC2IN_BUSIF_MODE	0x0040
+#define	SRC2OUT_BUSIF_MODE	0x0044
+#define	SRC2_BUSIF_DALIGN	0x0048
+#define	SRC2_MODE		0x004c
+#define	SRC2_CONTROL		0x0050
+#define	SRC2_STATUS		0x0054
+#define	SRC2_INT_ENABLE0	0x0058
+#define	SRC3IN_BUSIF_MODE	0x0060
+#define	SRC3OUT_BUSIF_MODE	0x0064
+#define	SRC3_BUSIF_DALIGN	0x0068
+#define	SRC3_MODE		0x006c
+#define	SRC3_CONTROL		0x0070
+#define	SRC3_STATUS		0x0074
+#define	SRC3_INT_ENABLE0	0x0078
+#define	SRC4IN_BUSIF_MODE	0x0080
+#define	SRC4OUT_BUSIF_MODE	0x0084
+#define	SRC4_BUSIF_DALIGN	0x0088
+#define	SRC4_MODE		0x008c
+#define	SRC4_CONTROL		0x0090
+#define	SRC4_STATUS		0x0094
+#define	SRC4_INT_ENABLE0	0x0098
+#define	SRC5IN_BUSIF_MODE	0x00a0
+#define	SRC5OUT_BUSIF_MODE	0x00a4
+#define	SRC5_BUSIF_DALIGN	0x00a8
+#define	SRC5_MODE		0x00ac
+#define	SRC5_CONTROL		0x00b0
+#define	SRC5_STATUS		0x00b4
+#define	SRC5_INT_ENABLE0	0x00b8
+#define	SRC6IN_BUSIF_MODE	0x00c0
+#define	SRC6OUT_BUSIF_MODE	0x00c4
+#define	SRC6_BUSIF_DALIGN	0x00c8
+#define	SRC6_MODE		0x00cc
+#define	SRC6_CONTROL		0x00d0
+#define	SRC6_STATUS		0x00d4
+#define	SRC6_INT_ENABLE0	0x00d8
+#define	SRC7IN_BUSIF_MODE	0x00e0
+#define	SRC7OUT_BUSIF_MODE	0x00e4
+#define	SRC7_BUSIF_DALIGN	0x00e8
+#define	SRC7_MODE		0x00ec
+#define	SRC7_CONTROL		0x00f0
+#define	SRC7_STATUS		0x00f4
+#define	SRC7_INT_ENABLE0	0x00f8
+#define	SRC8IN_BUSIF_MODE	0x0100
+#define	SRC8OUT_BUSIF_MODE	0x0104
+#define	SRC8_BUSIF_DALIGN	0x0108
+#define	SRC8_MODE		0x010c
+#define	SRC8_CONTROL		0x0110
+#define	SRC8_STATUS		0x0114
+#define	SRC8_INT_ENABLE0	0x0118
+#define	SRC9IN_BUSIF_MODE	0x0120
+#define	SRC9OUT_BUSIF_MODE	0x0124
+#define	SRC9_BUSIF_DALIGN	0x0128
+#define	SRC9_MODE		0x012c
+#define	SRC9_CONTROL		0x0130
+#define	SRC9_STATUS		0x0134
+#define	SRC9_INT_ENABLE0	0x0138
+#define	CMD0OUT_BUSIF_MODE	0x0184
+#define	CMD0_BUSIF_DALIGN	0x0188
+#define	CMD0_MODE		0x018c
+#define	CMD0_CONTROL		0x0190
+#define	CMD1OUT_BUSIF_MODE	0x01a4
+#define	CMD1_BUSIF_DALIGN	0x01a8
+#define	CMD1_MODE		0x01ac
+#define	CMD1_CONTROL		0x01b0
+#define	SCU_SYSTEM_STATUS0	0x01c8
+#define	SCU_SYSTEM_INT_ENABLE0	0x01cc
+
+/* SRC input/output */
+#define	SRC_INOUT		0
+#define	SRC_IN			1
+#define	SRC_OUT			2
+
+/* SRC_MODE */
+#define	SRC_MODE_UF_DATA_0	(1<<16)
+#define	SRC_MODE_SRCUSE		(1<<0)
+
+/* SRC_CONTROL */
+#define	SRC_MODE_START_OUT	(1<<4)
+#define	SRC_MODE_START_IN	(1<<0)
+
+/*
+ *	SRC
+ */
+/* SRC_ADINR */
+#define	SRCADIN_OTBL_24BIT	(0<<16)
+#define	SRCADIN_OTBL_22BIT	(2<<16)
+#define	SRCADIN_OTBL_20BIT	(4<<16)
+#define	SRCADIN_OTBL_18BIT	(6<<16)
+#define	SRCADIN_OTBL_16BIT	(8<<16)
+#define	SRCADIN_OTBL_8BIT	(16<<16)
+#define	SRCADIN_CHNUM_0		(0<<0)
+#define	SRCADIN_CHNUM_1		(1<<0)
+#define	SRCADIN_CHNUM_2		(2<<0)
+#define	SRCADIN_CHNUM_4		(4<<0)
+#define	SRCADIN_CHNUM_6		(6<<0)
+#define	SRCADIN_CHNUM_8		(8<<0)
+
+/* SRC_IFSVR */
+#define	SRC_IFS_FSO	0x00400000ULL	/* 2^22 */
+#define	SRC_IFS_44KHZ	44100ULL
+#define	SRC_IFS_48KHZ	48000ULL
+
+/*
+ *	SSIU
+ */
+/* register offset */
+#define	SSI0_0_BUSIF_MODE	0x0000
+#define	SSI0_0_BUSIF_ADINR	0x0004
+#define	SSI0_0_BUSIF_DALIGN	0x0008
+#define	SSI0_0_MODE		0x000c
+#define	SSI0_0_CONTROL		0x0010
+#define	SSI0_0_STATUS		0x0014
+#define	SSI0_0_INT_ENABLE_MAIN	0x0018
+#define	SSI0_1_BUSIF_MODE	0x0020
+#define	SSI0_1_BUSIF_ADINR	0x0024
+#define	SSI0_1_BUSIF_DALIGN	0x0028
+#define	SSI0_2_BUSIF_MODE	0x0040
+#define	SSI0_2_BUSIF_ADINR	0x0044
+#define	SSI0_2_BUSIF_DALIGN	0x0048
+#define	SSI0_3_BUSIF_MODE	0x0060
+#define	SSI0_3_BUSIF_ADINR	0x0064
+#define	SSI0_3_BUSIF_DALIGN	0x0068
+#define	SSI1_0_BUSIF_MODE	0x0080
+#define	SSI1_0_BUSIF_ADINR	0x0084
+#define	SSI1_0_BUSIF_DALIGN	0x0088
+#define	SSI1_0_MODE		0x008c
+#define	SSI1_0_CONTROL		0x0090
+#define	SSI1_0_STATUS		0x0094
+#define	SSI1_0_INT_ENABLE_MAIN	0x0098
+#define	SSI1_1_BUSIF_MODE	0x00a0
+#define	SSI1_1_BUSIF_ADINR	0x00a4
+#define	SSI1_1_BUSIF_DALIGN	0x00a8
+#define	SSI1_2_BUSIF_MODE	0x00c0
+#define	SSI1_2_BUSIF_ADINR	0x00c4
+#define	SSI1_2_BUSIF_DALIGN	0x00c8
+#define	SSI1_3_BUSIF_MODE	0x00e0
+#define	SSI1_3_BUSIF_ADINR	0x00e4
+#define	SSI1_3_BUSIF_DALIGN	0x00e8
+#define	SSI2_0_BUSIF_MODE	0x0100
+#define	SSI2_0_BUSIF_ADINR	0x0104
+#define	SSI2_0_BUSIF_DALIGN	0x0108
+#define	SSI2_0_MODE		0x010c
+#define	SSI2_0_CONTROL		0x0110
+#define	SSI2_0_STATUS		0x0114
+#define	SSI2_0_INT_ENABLE_MAIN	0x0118
+#define	SSI2_1_BUSIF_MODE	0x0120
+#define	SSI2_1_BUSIF_ADINR	0x0124
+#define	SSI2_1_BUSIF_DALIGN	0x0128
+#define	SSI2_2_BUSIF_MODE	0x0140
+#define	SSI2_2_BUSIF_ADINR	0x0144
+#define	SSI2_2_BUSIF_DALIGN	0x0148
+#define	SSI2_3_BUSIF_MODE	0x0160
+#define	SSI2_3_BUSIF_ADINR	0x0164
+#define	SSI2_3_BUSIF_DALIGN	0x0168
+#define	SSI3_BUSIF_MODE		0x0180
+#define	SSI3_BUSIF_ADINR	0x0184
+#define	SSI3_BUSIF_DALIGN	0x0188
+#define	SSI3_MODE		0x018c
+#define	SSI3_CONTROL		0x0190
+#define	SSI3_STATUS		0x0194
+#define	SSI3_INT_ENABLE_MAIN	0x0198
+#define	SSI4_BUSIF_MODE		0x0200
+#define	SSI4_BUSIF_ADINR	0x0204
+#define	SSI4_BUSIF_DALIGN	0x0208
+#define	SSI4_MODE		0x020c
+#define	SSI4_CONTROL		0x0210
+#define	SSI4_STATUS		0x0214
+#define	SSI4_INT_ENABLE_MAIN	0x0218
+#define	SSI5_BUSIF_MODE		0x0280
+#define	SSI5_BUSIF_ADINR	0x0284
+#define	SSI5_BUSIF_DALIGN	0x0288
+#define	SSI5_MODE		0x028c
+#define	SSI5_CONTROL		0x0290
+#define	SSI5_STATUS		0x0294
+#define	SSI5_INT_ENABLE_MAIN	0x0298
+#define	SSI6_BUSIF_MODE		0x0300
+#define	SSI6_BUSIF_ADINR	0x0304
+#define	SSI6_BUSIF_DALIGN	0x0308
+#define	SSI6_MODE		0x030c
+#define	SSI6_CONTROL		0x0310
+#define	SSI6_STATUS		0x0314
+#define	SSI6_INT_ENABLE_MAIN	0x0318
+#define	SSI7_BUSIF_MODE		0x0380
+#define	SSI7_BUSIF_ADINR	0x0384
+#define	SSI7_BUSIF_DALIGN	0x0388
+#define	SSI7_MODE		0x038c
+#define	SSI7_CONTROL		0x0390
+#define	SSI7_STATUS		0x0394
+#define	SSI7_INT_ENABLE_MAIN	0x0398
+#define	SSI8_BUSIF_MODE		0x0400
+#define	SSI8_BUSIF_ADINR	0x0404
+#define	SSI8_BUSIF_DALIGN	0x0408
+#define	SSI8_MODE		0x040c
+#define	SSI8_CONTROL		0x0410
+#define	SSI8_STATUS		0x0414
+#define	SSI8_INT_ENABLE_MAIN	0x0418
+#define	SSI9_0_BUSIF_MODE	0x0480
+#define	SSI9_0_BUSIF_ADINR	0x0484
+#define	SSI9_0_BUSIF_DALIGN	0x0488
+#define	SSI9_0_MODE		0x048c
+#define	SSI9_0_CONTROL		0x0490
+#define	SSI9_0_STATUS		0x0494
+#define	SSI9_0_INT_ENABLE_MAIN	0x0498
+#define	SSI9_1_BUSIF_MODE	0x04a0
+#define	SSI9_1_BUSIF_ADINR	0x04a4
+#define	SSI9_1_BUSIF_DALIGN	0x04a8
+#define	SSI9_2_BUSIF_MODE	0x04c0
+#define	SSI9_2_BUSIF_ADINR	0x04c4
+#define	SSI9_2_BUSIF_DALIGN	0x04c8
+#define	SSI9_3_BUSIF_MODE	0x04e0
+#define	SSI9_3_BUSIF_ADINR	0x04e4
+#define	SSI9_3_BUSIF_DALIGN	0x04e8
+#define	SSI_MODE0		0x0800
+#define	SSI_MODE1		0x0804
+#define	SSI_MODE2		0x0808
+#define	SSI_MODE3		0x080c
+#define	SSI_CONTROL		0x0810
+#define	SSI_SYSTEM_STATUS0	0x0840
+#define	SSI_SYSTEM_STATUS1	0x0844
+#define	SSI_SYSTEM_STATUS2	0x0848
+#define	SSI_SYSTEM_STATUS3	0x084c
+#define	SSI_SYSTEM_INT_ENABLE0	0x0850
+#define	SSI_SYSTEM_INT_ENABLE1	0x0854
+#define	SSI_SYSTEM_INT_ENABLE2	0x0858
+#define	SSI_SYSTEM_INT_ENABLE3	0x085c
+
+/* SSI_BUSIF_ADINR bit */
+#define	SSI_ADINR_OTBL_24BIT	(0<<16)
+#define	SSI_ADINR_OTBL_22BIT	(2<<16)
+#define	SSI_ADINR_OTBL_20BIT	(4<<16)
+#define	SSI_ADINR_OTBL_18BIT	(6<<16)
+#define	SSI_ADINR_OTBL_16BIT	(8<<16)
+#define	SSI_ADINR_OTBL_8BIT	(16<<16)
+#define	SSI_ADINR_CHNUM_1CH	(1<<0)
+#define	SSI_ADINR_CHNUM_2CH	(2<<0)
+#define	SSI_ADINR_CHNUM_4CH	(4<<0)
+#define	SSI_ADINR_CHNUM_6CH	(6<<0)
+#define	SSI_ADINR_CHNUM_8CH	(8<<0)
+
+/* SSI_CONTROL */
+#define	SSI_CTRL_4CH_START3	(1<<12)
+#define	SSI_CTRL_4CH_START2	(1<<8)
+#define	SSI_CTRL_4CH_START1	(1<<4)
+#define	SSI_CTRL_4CH_START0	(1<<0)
+#define	SSI_CTRL_1CH_START	(1<<0)
+
+/* SSI_MODE0 bit */
+#define	SSI_MODE0_SWAP9	(1<<25)
+#define	SSI_MODE0_SWAP8	(1<<24)
+#define	SSI_MODE0_SWAP7	(1<<23)
+#define	SSI_MODE0_SWAP6	(1<<22)
+#define	SSI_MODE0_SWAP5	(1<<21)
+#define	SSI_MODE0_SWAP4	(1<<20)
+#define	SSI_MODE0_SWAP3	(1<<19)
+#define	SSI_MODE0_SWAP2	(1<<18)
+#define	SSI_MODE0_SWAP1	(1<<17)
+#define	SSI_MODE0_SWAP0	(1<<16)
+#define	SSI_MODE0_IND9	(1<<9)
+#define	SSI_MODE0_IND8	(1<<8)
+#define	SSI_MODE0_IND7	(1<<7)
+#define	SSI_MODE0_IND6	(1<<6)
+#define	SSI_MODE0_IND5	(1<<5)
+#define	SSI_MODE0_IND4	(1<<4)
+#define	SSI_MODE0_IND3	(1<<3)
+#define	SSI_MODE0_IND2	(1<<2)
+#define	SSI_MODE0_IND1	(1<<1)
+#define	SSI_MODE0_IND0	(1<<0)
+
+/* SSI_MODE1 bit */
+#define	SSI_MODE1_SSI34_SYNC	(1<<20)
+#define	SSI_MODE1_SSI4_IND	(0<<16)	/* SSI4 independent        */
+#define	SSI_MODE1_SSI4_SLAVE	(1<<16)	/* SSI4 slave, SSI3 slave  */
+#define	SSI_MODE1_SSI4_MASTER	(2<<16)	/* SSI4 slave, SSI3 master */
+#define	SSI_MODE1_SSI012_3MOD	(1<<4)
+#define	SSI_MODE1_SSI2_IND	(0<<2)	/* SSI2 independent        */
+#define	SSI_MODE1_SSI2_SLAVE	(1<<2)	/* SSI2 slave, SSI0 slave  */
+#define	SSI_MODE1_SSI2_MASTER	(2<<2)	/* SSI2 slave, SSI0 master */
+#define	SSI_MODE1_SSI1_IND	(0<<0)	/* SSI1 independent        */
+#define	SSI_MODE1_SSI1_SLAVE	(1<<0)	/* SSI1 slave, SSI0 slave  */
+#define	SSI_MODE1_SSI1_MASTER	(2<<0)	/* SSI1 slave, SSI0 master */
+
+/* SSI_MODE2 bit */
+#define	SSI_MODE2_SSI0129_4MOD	(1<<4)
+#define	SSI_MODE2_SSI9_IND	(0<<0)	/* SSI9 independent        */
+#define	SSI_MODE2_SSI9_SLAVE0	(1<<0)	/* SSI9 slave, SSI0 slave  */
+#define	SSI_MODE2_SSI9_MASTER0	(2<<0)	/* SSI9 slave, SSI0 master */
+#define	SSI_MODE2_SSI9_SLAVE3	(5<<0)	/* SSI9 slave, SSI3 slave  */
+#define	SSI_MODE2_SSI9_MASTER3	(6<<0)	/* SSI9 slave, SSI3 master */
+
+/* SSI_MODE3 bit */
+#define	SSI_MODE3_SSI3_IND	(0<<0)	/* SSI9 independent        */
+#define	SSI_MODE3_SSI3_SLAVE	(1<<0)	/* SSI9 slave, SSI0 slave  */
+#define	SSI_MODE3_SSI3_MASTER	(2<<0)	/* SSI9 slave, SSI0 master */
+
+/*
+ *	SSI
+ */
+/* SSICRn bit */
+#define	SSICR_EN	(1<<0)
+#define	SSICR_TRMD_RX	(0<<1)
+#define	SSICR_TRMD_TX	(1<<1)
+#define	SSICR_CPEN	(1<<2)
+#define	SSICR_MUEN	(1<<3)
+#define	SSICR_CKDV_1	(0<<4)
+#define	SSICR_CKDV_2	(1<<4)
+#define	SSICR_CKDV_4	(2<<4)
+#define	SSICR_CKDV_8	(3<<4)
+#define	SSICR_CKDV_16	(4<<4)
+#define	SSICR_CKDV_6	(5<<4)
+#define	SSICR_CKDV_12	(6<<4)
+#define	SSICR_BREN	(1<<7)
+#define	SSICR_DEL	(1<<8)
+#define	SSICR_PDTA	(1<<9)
+#define	SSICR_SDTA	(1<<10)
+#define	SSICR_SPDP	(1<<11)
+#define	SSICR_SWSP	(1<<12)
+#define	SSICR_SCKP	(1<<13)
+#define	SSICR_M_SLAVE	(0<<14)
+#define	SSICR_M_MASTER	(3<<14)
+#define	SSICR_SWSD	(1<<14)
+#define	SSICR_SCKD	(1<<15)
+#define	SSICR_SWL_ST8	(0<<16)
+#define	SSICR_SWL_ST16	(1<<16)
+#define	SSICR_SWL_ST24	(2<<16)
+#define	SSICR_SWL_ST32	(3<<16)
+#define	SSICR_SWL_ST48	(4<<16)
+#define	SSICR_SWL_ST64	(5<<16)
+#define	SSICR_SWL_ST128	(6<<16)
+#define	SSICR_SWL_ST256	(7<<16)
+#define	SSICR_SWL_MN16	(0<<16)
+#define	SSICR_SWL_MN32	(1<<16)
+#define	SSICR_SWL_MN48	(2<<16)
+#define	SSICR_SWL_MN64	(3<<16)
+#define	SSICR_SWL_MN96	(4<<16)
+#define	SSICR_SWL_MN128	(5<<16)
+#define	SSICR_SWL_MN256	(6<<16)
+#define	SSICR_SWL_MN512	(7<<16)
+#define	SSICR_DWL_ST8	(0<<19)
+#define	SSICR_DWL_ST16	(1<<19)
+#define	SSICR_DWL_ST18	(2<<19)
+#define	SSICR_DWL_ST20	(3<<19)
+#define	SSICR_DWL_ST22	(4<<19)
+#define	SSICR_DWL_ST24	(5<<19)
+#define	SSICR_DWL_ST32	(6<<19)
+#define	SSICR_DWL_MN8	(0<<19)
+#define	SSICR_DWL_MN16	(1<<19)
+#define	SSICR_CHNL_ST1	(0<<22)
+#define	SSICR_CHNL_ST2	(1<<22)
+#define	SSICR_CHNL_ST3	(2<<22)
+#define	SSICR_CHNL_ST4	(3<<22)
+#define	SSICR_CHNL_MN	(0<<22)
+#define	SSICR_DIEN	(1<<24)
+#define	SSICR_IIEN	(1<<25)
+#define	SSICR_OIEN	(1<<26)
+#define	SSICR_UIEN	(1<<27)
+#define	SSICR_DMEN	(1<<28)
+#define	SSICR_FORCE	(1<<31)
+
+/*
+ * SSICR setting for AK4643
+ *   playback, master, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_P4643_ST	(SSICR_FORCE    | \
+			 SSICR_CHNL_ST1 | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST16 | \
+			 SSICR_M_MASTER | \
+			 SSICR_CKDV_8   | \
+			 SSICR_TRMD_TX)
+
+/*
+ * SSICR setting for AK4643
+ *   capture, slave, 16bit, stereo
+ *   SCLK=256fs(MCLK)/8=32fs
+ */
+#define	SSICR_C4643_ST	(SSICR_FORCE    | \
+			 SSICR_CHNL_ST1 | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST16 | \
+			 SSICR_M_SLAVE  | \
+			 SSICR_TRMD_RX)
+
+/* for SSI start */
+#define	SSICR_ENABLE	(SSICR_EN	| \
+			 SSICR_OIEN	| \
+			 SSICR_UIEN	| \
+			 SSICR_DMEN)
+
+/* SSISRn bit */
+#define	SSISR_IDST	(1<<0)
+#define	SSISR_SWNO	(1<<1)
+#define	SSISR_CHNO0	(1<<2)
+#define	SSISR_CHNO1	(1<<3)
+#define	SSISR_DIRQ	(1<<24)
+#define	SSISR_IIRQ	(1<<25)
+#define	SSISR_OIRQ	(1<<26)
+#define	SSISR_UIRQ	(1<<27)
+#define	SSISR_DMRQ	(1<<28)
+
+/* SSIWSRn bit */
+#define	SSIWSR_MODE_ST	(0<<0)
+#define	SSIWSR_MODE_MN	(1<<0)
+#define	SSIWSR_MONO	(1<<1)
+#define	SSIWSR_CONT	(1<<8)
+#define	SSIWSR_WIDTH_1	(1<<16)
+#define	SSIWSR_WIDTH_2	(2<<16)
+#define	SSIWSR_WIDTH_3	(3<<16)
+#define	SSIWSR_WIDTH_4	(4<<16)
+#define	SSIWSR_WIDTH_5	(5<<16)
+#define	SSIWSR_WIDTH_6	(6<<16)
+#define	SSIWSR_WIDTH_7	(7<<16)
+#define	SSIWSR_WIDTH_8	(8<<16)
+#define	SSIWSR_WIDTH_9	(9<<16)
+#define	SSIWSR_WIDTH_10	(10<<16)
+#define	SSIWSR_WIDTH_11	(11<<16)
+#define	SSIWSR_WIDTH_12	(12<<16)
+#define	SSIWSR_WIDTH_13	(13<<16)
+#define	SSIWSR_WIDTH_14	(14<<16)
+#define	SSIWSR_WIDTH_15	(15<<16)
+#define	SSIWSR_WIDTH_16	(16<<16)
+#define	SSIWSR_WIDTH_17	(17<<16)
+#define	SSIWSR_WIDTH_18	(18<<16)
+#define	SSIWSR_WIDTH_19	(19<<16)
+#define	SSIWSR_WIDTH_20	(20<<16)
+#define	SSIWSR_WIDTH_21	(21<<16)
+#define	SSIWSR_WIDTH_22	(22<<16)
+#define	SSIWSR_WIDTH_23	(23<<16)
+#define	SSIWSR_WIDTH_24	(24<<16)
+#define	SSIWSR_WIDTH_25	(25<<16)
+#define	SSIWSR_WIDTH_26	(26<<16)
+#define	SSIWSR_WIDTH_27	(27<<16)
+#define	SSIWSR_WIDTH_28	(28<<16)
+#define	SSIWSR_WIDTH_29	(29<<16)
+#define	SSIWSR_WIDTH_30	(30<<16)
+#define	SSIWSR_WIDTH_31	(31<<16)
+
+/*
+ * SSIWS setting
+ *   playback(master) only, 16bit, stereo
+ */
+#define	SSIWS_ST	SSIWSR_CONT
+
+/*
+ *	ADG information
+ */
+/* ADG register address */
+#define	ADG_BRRA		0x0000	/* BRGA baud rate set              */
+#define	ADG_BRRB		0x0004	/* BRGB baud rate set              */
+#define	ADG_SSICKR		0x0008	/* clock select                    */
+#define	ADG_AUDIO_CLK_SEL0	0x000c	/* AUDIO CLOCK select 0            */
+#define	ADG_AUDIO_CLK_SEL1	0x0010	/* AUDIO CLOCK select 1            */
+#define	ADG_AUDIO_CLK_SEL2	0x0014	/* AUDIO CLOCK select 2            */
+#define	ADG_DIV_EN		0x0030	/* clock frequency division enable */
+#define	ADG_SRCIN_TIMSEL0	0x0034	/* SRC input timing select 0       */
+#define	ADG_SRCIN_TIMSEL1	0x0038	/* SRC input timing select 1       */
+#define	ADG_SRCIN_TIMSEL2	0x003c	/* SRC input timing select 2       */
+#define	ADG_SRCIN_TIMSEL3	0x0040	/* SRC input timing select 3       */
+#define	ADG_SRCIN_TIMSEL4	0x0044	/* SRC input timing select 4       */
+#define	ADG_SRCOUT_TIMSEL0	0x0048	/* SRC output timing select 0      */
+#define	ADG_SRCOUT_TIMSEL1	0x004c	/* SRC output timing select 1      */
+#define	ADG_SRCOUT_TIMSEL2	0x0050	/* SRC output timing select 2      */
+#define	ADG_SRCOUT_TIMSEL3	0x0054	/* SRC output timing select 3      */
+#define	ADG_SRCOUT_TIMSEL4	0x0058	/* SRC output timing select 4      */
+#define	ADG_CMDOUT_TIMSEL	0x005c	/* CMD output timing select        */
+#define	ADG_ADSPOUT_TIMSEL	0x0060	/* ADSP output timing select       */
+#define	ADG_DTCP_TIMSEL		0x0064	/* DTCP timing select              */
+
+/* ADG BRRA bit */
+#define	ADG_BRRA_CKS_ACLKA		(0<<8)
+#define	ADG_BRRA_CKS_ACLKA_DIV4		(1<<8)
+#define	ADG_BRRA_CKS_ACLKA_DIV16	(2<<8)
+#define	ADG_BRRA_CKS_ACLKA_DIV64	(3<<8)
+
+/* ADG BRRB bit */
+#define	ADG_BRRB_CKS_ACLKB		(0<<8)
+#define	ADG_BRRB_CKS_ACLKB_DIV4		(1<<8)
+#define	ADG_BRRB_CKS_ACLKB_DIV16	(2<<8)
+#define	ADG_BRRB_CKS_ACLKB_DIV64	(3<<8)
+
+/* ADG SSICKR bit */
+#define	ADG_SSICK_CLKOUT_BRGA		(0<<31)
+#define	ADG_SSICK_CLKOUT_BRGB		(1<<31)
+#define	ADG_SSICK_BRGA_AUDIO_CLKA	(0<<20)
+#define	ADG_SSICK_BRGA_AUDIO_CLKB	(1<<20)
+#define	ADG_SSICK_BRGA_XM2CK		(2<<20)
+#define	ADG_SSICK_BRGA_AUDIO_CLKC	(4<<20)
+#define	ADG_SSICK_BRGB_AUDIO_CLKA	(0<<16)
+#define	ADG_SSICK_BRGB_AUDIO_CLKB	(1<<16)
+#define	ADG_SSICK_BRGB_XM2CK		(2<<16)
+#define	ADG_SSICK_BRGB_AUDIO_CLKC	(4<<16)
+
+/* ADG AUDIO_CLK_SEL0 bit */
+#define	ADG_SEL0_SSI3_DIV1		(0<<27)		/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV2		(1<<27)		/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV4		(8<<27)		/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV8		(9<<27)		/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV16		(16<<27)	/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV32		(17<<27)	/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_DIV_MASK		(25<<27)	/* bit27,30,31 */
+#define	ADG_SEL0_SSI3_ACLK_DIV		(0<<28)
+#define	ADG_SEL0_SSI3_ACLK_BRGA		(1<<28)
+#define	ADG_SEL0_SSI3_ACLK_BRGB		(2<<28)
+#define	ADG_SEL0_SSI3_DIVCLK_FIX	(0<<24)
+#define	ADG_SEL0_SSI3_DIVCLK_CLKA	(1<<24)
+#define	ADG_SEL0_SSI3_DIVCLK_CLKB	(2<<24)
+#define	ADG_SEL0_SSI3_DIVCLK_CLKC	(3<<24)
+#define	ADG_SEL0_SSI3_DIVCLK_MLPCLK	(4<<24)
+#define	ADG_SEL0_SSI2_DIV1		(0<<19)		/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV2		(1<<19)		/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV4		(8<<19)		/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV8		(9<<19)		/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV16		(16<<19)	/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV32		(17<<19)	/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_DIV_MASK		(25<<19)	/* bit19,22,23 */
+#define	ADG_SEL0_SSI2_ACLK_DIV		(0<<20)
+#define	ADG_SEL0_SSI2_ACLK_BRGA		(1<<20)
+#define	ADG_SEL0_SSI2_ACLK_BRGB		(2<<20)
+#define	ADG_SEL0_SSI2_DIVCLK_FIX	(0<<16)
+#define	ADG_SEL0_SSI2_DIVCLK_CLKA	(1<<16)
+#define	ADG_SEL0_SSI2_DIVCLK_CLKB	(2<<16)
+#define	ADG_SEL0_SSI2_DIVCLK_CLKC	(3<<16)
+#define	ADG_SEL0_SSI2_DIVCLK_MLPCLK	(4<<16)
+#define	ADG_SEL0_SSI1_DIV1		(0<<11)		/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV2		(1<<11)		/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV4		(8<<11)		/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV8		(9<<11)		/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV16		(16<<11)	/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV32		(17<<11)	/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_DIV_MASK		(25<<11)	/* bit11,14,15 */
+#define	ADG_SEL0_SSI1_ACLK_DIV		(0<<12)
+#define	ADG_SEL0_SSI1_ACLK_BRGA		(1<<12)
+#define	ADG_SEL0_SSI1_ACLK_BRGB		(2<<12)
+#define	ADG_SEL0_SSI1_DIVCLK_FIX	(0<<8)
+#define	ADG_SEL0_SSI1_DIVCLK_CLKA	(1<<8)
+#define	ADG_SEL0_SSI1_DIVCLK_CLKB	(2<<8)
+#define	ADG_SEL0_SSI1_DIVCLK_CLKC	(3<<8)
+#define	ADG_SEL0_SSI1_DIVCLK_MLPCLK	(4<<8)
+#define	ADG_SEL0_SSI0_DIV1		(0<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV2		(1<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV4		(8<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV8		(9<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV16		(16<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV32		(17<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_DIV_MASK		(25<<3)		/* bit3,6,7 */
+#define	ADG_SEL0_SSI0_ACLK_DIV		(0<<4)
+#define	ADG_SEL0_SSI0_ACLK_BRGA		(1<<4)
+#define	ADG_SEL0_SSI0_ACLK_BRGB		(2<<4)
+#define	ADG_SEL0_SSI0_DIVCLK_FIX	(0<<0)
+#define	ADG_SEL0_SSI0_DIVCLK_CLKA	(1<<0)
+#define	ADG_SEL0_SSI0_DIVCLK_CLKB	(2<<0)
+#define	ADG_SEL0_SSI0_DIVCLK_CLKC	(3<<0)
+#define	ADG_SEL0_SSI0_DIVCLK_MLPCLK	(4<<0)
+
+/* ADG AUDIO_CLK_SEL1 bit */
+#define	ADG_SEL1_SSI7_DIV1		(0<<27)		/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV2		(1<<27)		/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV4		(8<<27)		/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV8		(9<<27)		/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV16		(16<<27)	/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV32		(17<<27)	/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_DIV_MASK		(25<<27)	/* bit27,30,31 */
+#define	ADG_SEL1_SSI7_ACLK_DIV		(0<<28)
+#define	ADG_SEL1_SSI7_ACLK_BRGA		(1<<28)
+#define	ADG_SEL1_SSI7_ACLK_BRGB		(2<<28)
+#define	ADG_SEL1_SSI7_DIVCLK_FIX	(0<<24)
+#define	ADG_SEL1_SSI7_DIVCLK_CLKA	(1<<24)
+#define	ADG_SEL1_SSI7_DIVCLK_CLKB	(2<<24)
+#define	ADG_SEL1_SSI7_DIVCLK_CLKC	(3<<24)
+#define	ADG_SEL1_SSI7_DIVCLK_MLPCLK	(4<<24)
+#define	ADG_SEL1_SSI6_DIV1		(0<<19)		/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV2		(1<<19)		/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV4		(8<<19)		/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV8		(9<<19)		/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV16		(16<<19)	/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV32		(17<<19)	/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_DIV_MASK		(25<<19)	/* bit19,22,23 */
+#define	ADG_SEL1_SSI6_ACLK_DIV		(0<<20)
+#define	ADG_SEL1_SSI6_ACLK_BRGA		(1<<20)
+#define	ADG_SEL1_SSI6_ACLK_BRGB		(2<<20)
+#define	ADG_SEL1_SSI6_DIVCLK_FIX	(0<<16)
+#define	ADG_SEL1_SSI6_DIVCLK_CLKA	(1<<16)
+#define	ADG_SEL1_SSI6_DIVCLK_CLKB	(2<<16)
+#define	ADG_SEL1_SSI6_DIVCLK_CLKC	(3<<16)
+#define	ADG_SEL1_SSI6_DIVCLK_MLPCLK	(4<<16)
+#define	ADG_SEL1_SSI5_DIV1		(0<<11)		/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV2		(1<<11)		/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV4		(8<<11)		/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV8		(9<<11)		/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV16		(16<<11)	/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV32		(17<<11)	/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_DIV_MASK		(25<<11)	/* bit11,14,15 */
+#define	ADG_SEL1_SSI5_ACLK_DIV		(0<<12)
+#define	ADG_SEL1_SSI5_ACLK_BRGA		(1<<12)
+#define	ADG_SEL1_SSI5_ACLK_BRGB		(2<<12)
+#define	ADG_SEL1_SSI5_DIVCLK_FIX	(0<<8)
+#define	ADG_SEL1_SSI5_DIVCLK_CLKA	(1<<8)
+#define	ADG_SEL1_SSI5_DIVCLK_CLKB	(2<<8)
+#define	ADG_SEL1_SSI5_DIVCLK_CLKC	(3<<8)
+#define	ADG_SEL1_SSI5_DIVCLK_MLPCLK	(4<<8)
+#define	ADG_SEL1_SSI4_DIV1		(0<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV2		(1<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV4		(8<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV8		(9<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV16		(16<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV32		(17<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_DIV_MASK		(25<<3)		/* bit3,6,7 */
+#define	ADG_SEL1_SSI4_ACLK_DIV		(0<<4)
+#define	ADG_SEL1_SSI4_ACLK_BRGA		(1<<4)
+#define	ADG_SEL1_SSI4_ACLK_BRGB		(2<<4)
+#define	ADG_SEL1_SSI4_DIVCLK_FIX	(0<<0)
+#define	ADG_SEL1_SSI4_DIVCLK_CLKA	(1<<0)
+#define	ADG_SEL1_SSI4_DIVCLK_CLKB	(2<<0)
+#define	ADG_SEL1_SSI4_DIVCLK_CLKC	(3<<0)
+#define	ADG_SEL1_SSI4_DIVCLK_MLPCLK	(4<<0)
+
+/* ADG AUDIO_CLK_SEL2 bit */
+#define	ADG_SEL2_SSI9_DIV1		(0<<11)		/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV2		(1<<11)		/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV4		(8<<11)		/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV8		(9<<11)		/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV16		(16<<11)	/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV32		(17<<11)	/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_DIV_MASK		(25<<11)	/* bit11,14,15 */
+#define	ADG_SEL2_SSI9_ACLK_DIV		(0<<12)
+#define	ADG_SEL2_SSI9_ACLK_BRGA		(1<<12)
+#define	ADG_SEL2_SSI9_ACLK_BRGB		(2<<12)
+#define	ADG_SEL2_SSI9_DIVCLK_FIX	(0<<8)
+#define	ADG_SEL2_SSI9_DIVCLK_CLKA	(1<<8)
+#define	ADG_SEL2_SSI9_DIVCLK_CLKB	(2<<8)
+#define	ADG_SEL2_SSI9_DIVCLK_CLKC	(3<<8)
+#define	ADG_SEL2_SSI9_DIVCLK_MLPCLK	(4<<8)
+
+/* ADG DIV_EN bit */
+#define	ADG_DIVEN_BRGB			(1<<5)
+#define	ADG_DIVEN_BRGA			(1<<4)
+#define	ADG_DIVEN_AUDIO_CLKC		(1<<3)
+#define	ADG_DIVEN_AUDIO_CLKB		(1<<2)
+#define	ADG_DIVEN_AUDIO_CLKA		(1<<1)
+#define	ADG_DIVEN_MLP			(1<<0)
+
+/* ADG SRCIN_TIMSEL0 bit */
+#define	ADG_SRCIN0_SRC1_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCIN0_SRC1_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV128		(11<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV192		(12<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV256		(13<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV384		(14<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV512		(15<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV768		(16<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCIN0_SRC1_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCIN0_SRC0_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCIN0_SRC0_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV128		(11<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV192		(12<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV256		(13<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV384		(14<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV512		(15<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV768		(16<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCIN0_SRC0_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCIN_TIMSEL1 bit */
+#define	ADG_SRCIN1_SRC3_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCIN1_SRC3_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV128		(11<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV192		(12<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV256		(13<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV384		(14<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV512		(15<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV768		(16<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCIN1_SRC3_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCIN1_SRC2_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCIN1_SRC2_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV128		(11<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV192		(12<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV256		(13<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV384		(14<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV512		(15<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV768		(16<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCIN1_SRC2_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCIN_TIMSEL2 bit */
+#define	ADG_SRCIN2_SRC5_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCIN2_SRC5_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV128		(11<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV192		(12<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV256		(13<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV384		(14<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV512		(15<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV768		(16<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCIN2_SRC5_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCIN2_SRC4_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCIN2_SRC4_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV128		(11<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV192		(12<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV256		(13<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV384		(14<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV512		(15<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV768		(16<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCIN2_SRC4_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCIN_TIMSEL3 bit */
+#define	ADG_SRCIN3_SRC7_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCIN3_SRC7_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV128		(11<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV192		(12<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV256		(13<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV384		(14<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV512		(15<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV768		(16<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCIN3_SRC7_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCIN3_SRC6_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCIN3_SRC6_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV128		(11<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV192		(12<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV256		(13<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV384		(14<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV512		(15<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV768		(16<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCIN3_SRC6_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCIN_TIMSEL4 bit */
+#define	ADG_SRCIN4_SRC9_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCIN4_SRC9_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV128		(11<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV192		(12<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV256		(13<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV384		(14<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV512		(15<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV768		(16<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCIN4_SRC9_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCIN4_SRC8_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCIN4_SRC8_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV128		(11<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV192		(12<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV256		(13<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV384		(14<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV512		(15<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV768		(16<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCIN4_SRC8_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCOUT_TIMSEL0 bit */
+#define	ADG_SRCOUT0_SRC1_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCOUT0_SRC1_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV128	(11<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV192	(12<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV256	(13<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV384	(14<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV512	(15<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV768	(16<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCOUT0_SRC1_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV128	(11<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV192	(12<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV256	(13<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV384	(14<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV512	(15<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV768	(16<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCOUT0_SRC0_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCOUT_TIMSEL1 bit */
+#define	ADG_SRCOUT1_SRC3_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCOUT1_SRC3_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV128	(11<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV192	(12<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV256	(13<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV384	(14<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV512	(15<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV768	(16<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCOUT1_SRC3_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCOUT1_SRC2_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV128	(11<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV192	(12<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV256	(13<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV384	(14<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV512	(15<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV768	(16<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCOUT1_SRC2_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCOUT_TIMSEL2 bit */
+#define	ADG_SRCOUT2_SRC5_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCOUT2_SRC5_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV128	(11<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV192	(12<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV256	(13<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV384	(14<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV512	(15<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV768	(16<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCOUT2_SRC5_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCOUT2_SRC4_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV128	(11<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV192	(12<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV256	(13<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV384	(14<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV512	(15<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV768	(16<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCOUT2_SRC4_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCOUT_TIMSEL3 bit */
+#define	ADG_SRCOUT3_SRC7_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCOUT3_SRC7_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV128	(11<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV192	(12<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV256	(13<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV384	(14<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV512	(15<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV768	(16<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCOUT3_SRC7_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCOUT3_SRC6_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV128	(11<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV192	(12<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV256	(13<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV384	(14<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV512	(15<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV768	(16<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCOUT3_SRC6_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG SRCOUT_TIMSEL4 bit */
+#define	ADG_SRCOUT4_SRC9_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_BRGA		(3<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_BRGB		(4<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_SRCOUT4_SRC9_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV2		(0<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV4		(1<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV6		(2<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV8		(3<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV12		(4<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV16		(5<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV24		(6<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV32		(7<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV48		(8<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV64		(9<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV96		(10<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV128	(11<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV192	(12<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV256	(13<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV384	(14<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV512	(15<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV768	(16<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_SRCOUT4_SRC9_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_BRGA		(3<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_BRGB		(4<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_SRCOUT4_SRC8_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV2		(0<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV4		(1<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV6		(2<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV8		(3<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV12		(4<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV16		(5<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV24		(6<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV32		(7<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV48		(8<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV64		(9<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV96		(10<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV128	(11<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV192	(12<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV256	(13<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV384	(14<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV512	(15<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV768	(16<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_SRCOUT4_SRC8_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG CMDOUT_TIMSEL bit */
+#define	ADG_CMDOUT_CMD1_DIVCLK_AUDIO_CLKA	(0<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_AUDIO_CLKB	(1<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_AUDIO_CLKC	(2<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_BRGA		(3<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_BRGB		(4<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_CMDOUT_CMD1_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV2		(0<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV4		(1<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV6		(2<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV8		(3<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV12		(4<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV16		(5<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV24		(6<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV32		(7<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV48		(8<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV64		(9<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV96		(10<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV128		(11<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV192		(12<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV256		(13<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV384		(14<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV512		(15<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV768		(16<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV1024	(17<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV1536	(18<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV2048	(19<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV3072	(20<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV4096	(21<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV6144	(22<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV8192	(23<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV12288	(24<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV16384	(25<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV24576	(26<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV32768	(27<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV49152	(28<<16)
+#define	ADG_CMDOUT_CMD1_DIVRATIO_DIV98304	(29<<16)
+#define	ADG_CMDOUT_CMD0_DIVCLK_AUDIO_CLKA	(0<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_AUDIO_CLKB	(1<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_AUDIO_CLKC	(2<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_BRGA		(3<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_BRGB		(4<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_MLPCLK		(5<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS0		(6<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS1		(7<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS2		(8<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS3		(9<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS4		(10<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS5		(11<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS6		(12<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS7		(13<<8)
+#define	ADG_CMDOUT_CMD0_DIVCLK_SSI_WS9		(14<<8)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV2		(0<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV4		(1<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV6		(2<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV8		(3<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV12		(4<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV16		(5<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV24		(6<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV32		(7<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV48		(8<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV64		(9<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV96		(10<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV128		(11<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV192		(12<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV256		(13<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV384		(14<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV512		(15<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV768		(16<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV1024	(17<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV1536	(18<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV2048	(19<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV3072	(20<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV4096	(21<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV6144	(22<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV8192	(23<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV12288	(24<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV16384	(25<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV24576	(26<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV32768	(27<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV49152	(28<<0)
+#define	ADG_CMDOUT_CMD0_DIVRATIO_DIV98304	(29<<0)
+
+/* ADG ADSPOUT_TIMSEL bit */
+#define	ADG_ADSPOUT_DIVCLK_AUDIO_CLKA		(0<<24)
+#define	ADG_ADSPOUT_DIVCLK_AUDIO_CLKB		(1<<24)
+#define	ADG_ADSPOUT_DIVCLK_AUDIO_CLKC		(2<<24)
+#define	ADG_ADSPOUT_DIVCLK_BRGA			(3<<24)
+#define	ADG_ADSPOUT_DIVCLK_BRGB			(4<<24)
+#define	ADG_ADSPOUT_DIVCLK_MLPCLK		(5<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS0		(6<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS1		(7<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS2		(8<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS3		(9<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS4		(10<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS5		(11<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS6		(12<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS7		(13<<24)
+#define	ADG_ADSPOUT_DIVCLK_SSI_WS9		(14<<24)
+#define	ADG_ADSPOUT_DIVRATIO_DIV2		(0<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV4		(1<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV6		(2<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV8		(3<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV12		(4<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV16		(5<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV24		(6<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV32		(7<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV48		(8<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV64		(9<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV96		(10<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV128		(11<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV192		(12<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV256		(13<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV384		(14<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV512		(15<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV768		(16<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV1024		(17<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV1536		(18<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV2048		(19<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV3072		(20<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV4096		(21<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV6144		(22<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV8192		(23<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV12288		(24<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV16384		(25<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV24576		(26<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV32768		(27<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV49152		(28<<16)
+#define	ADG_ADSPOUT_DIVRATIO_DIV98304		(29<<16)
+
+/* ADG DTCP_TIMSEL bit */
+#define	ADG_DTCP_DIVCLK_AUDIO_CLKA		(0<<24)
+#define	ADG_DTCP_DIVCLK_AUDIO_CLKB		(1<<24)
+#define	ADG_DTCP_DIVCLK_AUDIO_CLKC		(2<<24)
+#define	ADG_DTCP_DIVCLK_BRGA			(3<<24)
+#define	ADG_DTCP_DIVCLK_BRGB			(4<<24)
+#define	ADG_DTCP_DIVCLK_MLPCLK			(5<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS0			(6<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS1			(7<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS2			(8<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS3			(9<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS4			(10<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS5			(11<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS6			(12<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS7			(13<<24)
+#define	ADG_DTCP_DIVCLK_SSI_WS9			(14<<24)
+#define	ADG_DTCP_DIVRATIO_DIV2			(0<<16)
+#define	ADG_DTCP_DIVRATIO_DIV4			(1<<16)
+#define	ADG_DTCP_DIVRATIO_DIV6			(2<<16)
+#define	ADG_DTCP_DIVRATIO_DIV8			(3<<16)
+#define	ADG_DTCP_DIVRATIO_DIV12			(4<<16)
+#define	ADG_DTCP_DIVRATIO_DIV16			(5<<16)
+#define	ADG_DTCP_DIVRATIO_DIV24			(6<<16)
+#define	ADG_DTCP_DIVRATIO_DIV32			(7<<16)
+#define	ADG_DTCP_DIVRATIO_DIV48			(8<<16)
+#define	ADG_DTCP_DIVRATIO_DIV64			(9<<16)
+#define	ADG_DTCP_DIVRATIO_DIV96			(10<<16)
+#define	ADG_DTCP_DIVRATIO_DIV128		(11<<16)
+#define	ADG_DTCP_DIVRATIO_DIV192		(12<<16)
+#define	ADG_DTCP_DIVRATIO_DIV256		(13<<16)
+#define	ADG_DTCP_DIVRATIO_DIV384		(14<<16)
+#define	ADG_DTCP_DIVRATIO_DIV512		(15<<16)
+#define	ADG_DTCP_DIVRATIO_DIV768		(16<<16)
+#define	ADG_DTCP_DIVRATIO_DIV1024		(17<<16)
+#define	ADG_DTCP_DIVRATIO_DIV1536		(18<<16)
+#define	ADG_DTCP_DIVRATIO_DIV2048		(19<<16)
+#define	ADG_DTCP_DIVRATIO_DIV3072		(20<<16)
+#define	ADG_DTCP_DIVRATIO_DIV4096		(21<<16)
+#define	ADG_DTCP_DIVRATIO_DIV6144		(22<<16)
+#define	ADG_DTCP_DIVRATIO_DIV8192		(23<<16)
+#define	ADG_DTCP_DIVRATIO_DIV12288		(24<<16)
+#define	ADG_DTCP_DIVRATIO_DIV16384		(25<<16)
+#define	ADG_DTCP_DIVRATIO_DIV24576		(26<<16)
+#define	ADG_DTCP_DIVRATIO_DIV32768		(27<<16)
+#define	ADG_DTCP_DIVRATIO_DIV49152		(28<<16)
+#define	ADG_DTCP_DIVRATIO_DIV98304		(29<<16)
+
+
+/************************************************************************
+
+	structure
+
+************************************************************************/
+struct scu_src_regs {
+	u32	in_busif_mode;
+	u32	out_busif_mode;
+	u32	dalign;
+	u32	mode;
+	u32	control;
+	u32	status;
+	u32	int_enable0;
+};
+
+struct scu_cmd_regs {
+	u32	out_busif_mode;
+	u32	dalign;
+	u32	mode;
+	u32	control;
+};
+
+struct src_regs {
+	u32	swrsr;
+	u32	srcir;
+	u32	rsv1[3];	/* reserved */
+	u32	adinr;
+	u32	rsv2;		/* reserved */
+	u32	ifscr;
+	u32	ifsvr;
+	u32	srccr;
+	u32	mnfsr;
+	u32	bsdsr;
+	u32	rsv3[2];	/* reserved */
+	u32	bsisr;
+};
+
+struct ctu_regs {
+	u32	swrsr;
+	u32	ctuir;
+	u32	adinr;
+	u32	rsv;		/* reserved */
+	u32	cpmdr;
+	u32	scmdr;
+	u32	sv00r;
+	u32	sv01r;
+	u32	sv02r;
+	u32	sv03r;
+	u32	sv04r;
+	u32	sv05r;
+	u32	sv06r;
+	u32	sv07r;
+	u32	sv10r;
+	u32	sv11r;
+	u32	sv12r;
+	u32	sv13r;
+	u32	sv14r;
+	u32	sv15r;
+	u32	sv16r;
+	u32	sv17r;
+	u32	sv20r;
+	u32	sv21r;
+	u32	sv22r;
+	u32	sv23r;
+	u32	sv24r;
+	u32	sv25r;
+	u32	sv26r;
+	u32	sv27r;
+	u32	sv30r;
+	u32	sv31r;
+	u32	sv32r;
+	u32	sv33r;
+	u32	sv34r;
+	u32	sv35r;
+	u32	sv36r;
+	u32	sv37r;
+};
+
+struct mix_regs {
+	u32	swrsr;
+	u32	mixir;
+	u32	adinr;
+	u32	rsv;		/* reserved */
+	u32	mixmr;
+	u32	mvpdr;
+	u32	mdbar;
+	u32	mdbbr;
+	u32	mdbcr;
+	u32	mdbdr;
+	u32	mdber;
+	u32	mixsr;
+};
+
+struct dvc_regs {
+	u32	swrsr;
+	u32	dvuir;
+	u32	adinr;
+	u32	rsv;		/* reserved */
+	u32	dvucr;
+	u32	zcmcr;
+	u32	vrctr;
+	u32	vrpdr;
+	u32	vrdbr;
+	u32	vrwtr;
+	u32	vol0r;
+	u32	vol1r;
+	u32	vol2r;
+	u32	vol3r;
+	u32	vol4r;
+	u32	vol5r;
+	u32	vol6r;
+	u32	vol7r;
+	u32	dvuer;
+	u32	dvusr;
+	u32	dvier;
+};
+
+struct ssi_regs {
+	u32	cr;
+	u32	sr;
+	u32	tdr;
+	u32	rdr;
+	u32	rsv[4];		/* reserved */
+	u32	wsr;
+	u32	fmr;
+	u32	fsr;
+};
+
+struct scu_reg_info {
+	void __iomem		*scureg;
+	struct scu_src_regs	*scusrcreg[MAXCH_SRC];
+	struct scu_cmd_regs	*scucmdreg[MAXCH_CMD];
+	struct src_regs		*srcreg[MAXCH_SRC];
+	struct ctu_regs		*ctureg[MAXCH_CTU];
+	struct mix_regs		*mixreg[MAXCH_CMD];
+	struct dvc_regs		*dvcreg[MAXCH_CMD];
+	void __iomem		*ssiureg;
+	struct ssi_regs		*ssireg[MAXCH_SSI];
+	void __iomem		*adgreg;
+};
+
+struct scu_playback_callback {
+	void (*init_ssi)(void);
+	void (*init_ssi_src)(void);
+	void (*init_ssi_dvc)(void);
+	void (*init_src)(void);
+	void (*init_dvc)(void);
+	void (*deinit_ssi)(void);
+	void (*deinit_ssi_src)(void);
+	void (*deinit_ssi_dvc)(void);
+	void (*deinit_src)(void);
+	void (*deinit_dvc)(void);
+};
+
+struct scu_capture_callback {
+	void (*init_ssi)(void);
+	void (*init_ssi_src)(void);
+	void (*init_ssi_dvc)(void);
+	void (*init_src)(void);
+	void (*init_src_dvc)(void);
+	void (*init_dvc)(void);
+	void (*deinit_ssi)(void);
+	void (*deinit_ssi_src)(void);
+	void (*deinit_ssi_dvc)(void);
+	void (*deinit_src)(void);
+	void (*deinit_src_dvc)(void);
+	void (*deinit_dvc)(void);
+};
+
+struct scu_route_info {
+	int p_route;		/* playback route */
+	int c_route;		/* capture route */
+	/* snd_kcontrol */
+	int route_ssi[MAXCH_SSI];
+	int route_src[MAXCH_SRC];
+	int route_ctu[MAXCH_CMD];
+	int route_mix[MAXCH_CMD];
+	int route_dvc[MAXCH_CMD];
+	/* playback callback */
+	struct scu_playback_callback pcb;
+	/* capture callback */
+	struct scu_capture_callback ccb;
+};
+
+struct scu_clock_info {
+	struct clk *adg_clk;
+	struct clk *scu_clk;
+	struct clk *src0_clk;
+	struct clk *src1_clk;
+	struct clk *dvc0_clk;
+	struct clk *dvc1_clk;
+	struct clk *ssiu_clk;
+	struct clk *ssi0_clk;
+	struct clk *ssi1_clk;
+};
+
+struct scu_audio_info {
+	struct scu_reg_info reginfo;
+	struct scu_route_info routeinfo;
+	struct scu_clock_info clockinfo;
+	spinlock_t scu_lock;		/* for common register */
+};
+
+struct scu_pcm_info {
+	int flag_first;			/* for PCM 1st process */
+	int flag_start;			/* for DMA control */
+	unsigned int period;		/* for buffer control */
+	unsigned int tran_period;	/* A number of transferred period */
+	spinlock_t pcm_lock;		/* for trigger process */
+	struct dma_chan *de_chan[SHDMA_SLAVE_PCM_MAX];
+	struct sh_dmadesc_slave de_param[SHDMA_SLAVE_PCM_MAX];
+	struct work_struct	work;
+	struct scu_route_info *routeinfo;
+	struct snd_pcm_substream *ss;
+};
+
+/************************************************************************
+
+	external prototype declaration
+
+************************************************************************/
+extern struct snd_soc_platform_driver scu_platform;
+
+extern struct scu_route_info *scu_get_route_info(void);
+extern void scu_src_control(int src_ch, struct snd_pcm_substream *ss);
+
+extern void scu_init_ssi0(void);
+extern void scu_init_ssi0_src0(void);
+extern void scu_init_ssi0_dvc0(void);
+extern void scu_init_src0(void);
+extern void scu_init_dvc0(void);
+extern void scu_deinit_ssi0(void);
+extern void scu_deinit_ssi0_src0(void);
+extern void scu_deinit_ssi0_dvc0(void);
+extern void scu_deinit_src0(void);
+extern void scu_deinit_dvc0(void);
+
+extern void scu_init_ssi1(void);
+extern void scu_init_ssi1_src1(void);
+extern void scu_init_ssi1_dvc1(void);
+extern void scu_init_src1(void);
+extern void scu_init_src1_dvc1(void);
+extern void scu_init_dvc1(void);
+extern void scu_deinit_ssi1(void);
+extern void scu_deinit_ssi1_src1(void);
+extern void scu_deinit_ssi1_dvc1(void);
+extern void scu_deinit_src1(void);
+extern void scu_deinit_src1_dvc1(void);
+extern void scu_deinit_dvc1(void);
+
+extern int scu_check_route(int dir, struct scu_route_info *routeinfo);
+
+#endif /* SH_SCU_H */
diff --git a/sound/soc/sh/Kconfig b/sound/soc/sh/Kconfig
index 6bcb116..3d15f58 100644
--- a/sound/soc/sh/Kconfig
+++ b/sound/soc/sh/Kconfig
@@ -34,6 +34,12 @@ config SND_SOC_SH4_SIU
 	select SH_DMAE
 	select FW_LOADER
 
+config SND_SOC_SCU
+	tristate
+	depends on MACH_LAGER
+	select DMA_ENGINE
+	select DMADEVICES
+
 ##
 ## Boards
 ##
@@ -55,4 +61,30 @@ config SND_SIU_MIGOR
 	help
 	  This option enables sound support for the SH7722 Migo-R board
 
+config SND_SCU_LAGER
+	tristate "SCU sound support on LAGER"
+	depends on MACH_LAGER
+	select SND_SOC_SCU
+	select SND_LAGER_AK4643
+	help
+	  Enable sound support for the R8A77900 LAGER board.
+	  This is supported to the Renesas SCU peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SND_LAGER_AK4643
+        tristate "LAGER AK4643 sound support"
+        depends on SND_SCU_LAGER
+        select SND_SOC_AK4642
+        help
+          Enable the sound support for AK4643 on LAGER board.
+	  This option is dependent on SND_SCU_LAGER.
+	  If you will enable, say Y to SND_SCU_LAGER.
+	  This option enables SND_SOC_AK4642.
+
+config SND_SOC_LAGER_AK4643
+        bool
+        depends on SND_LAGER_AK4643
+        default y
+
 endmenu
diff --git a/sound/soc/sh/Makefile b/sound/soc/sh/Makefile
index 849b387..a76aea8 100644
--- a/sound/soc/sh/Makefile
+++ b/sound/soc/sh/Makefile
@@ -7,14 +7,18 @@ snd-soc-hac-objs	:= hac.o
 snd-soc-ssi-objs	:= ssi.o
 snd-soc-fsi-objs	:= fsi.o
 snd-soc-siu-objs	:= siu_pcm.o siu_dai.o
+snd-soc-scu-objs	:= scu_pcm.o scu_dai.o
 obj-$(CONFIG_SND_SOC_SH4_HAC)	+= snd-soc-hac.o
 obj-$(CONFIG_SND_SOC_SH4_SSI)	+= snd-soc-ssi.o
 obj-$(CONFIG_SND_SOC_SH4_FSI)	+= snd-soc-fsi.o
 obj-$(CONFIG_SND_SOC_SH4_SIU)	+= snd-soc-siu.o
+obj-$(CONFIG_SND_SOC_SCU)	+= snd-soc-scu.o
 
 ## boards
 snd-soc-sh7760-ac97-objs	:= sh7760-ac97.o
 snd-soc-migor-objs		:= migor.o
+snd-soc-lager-objs		:= lager.o
 
 obj-$(CONFIG_SND_SH7760_AC97)	+= snd-soc-sh7760-ac97.o
 obj-$(CONFIG_SND_SIU_MIGOR)	+= snd-soc-migor.o
+obj-$(CONFIG_SND_SCU_LAGER)	+= snd-soc-lager.o
diff --git a/sound/soc/sh/lager.c b/sound/soc/sh/lager.c
new file mode 100644
index 0000000..2b177e2
--- /dev/null
+++ b/sound/soc/sh/lager.c
@@ -0,0 +1,682 @@
+/*
+ * sound/soc/sh/lager.c
+ *     This file is ALSA SoC driver for LAGER.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/migor.c
+ *
+ * ALSA SoC driver for Migo-R
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/sh_scu.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static struct scu_route_info *routeinfo;
+
+int scu_check_route(int dir, struct scu_route_info *routeinfo)
+{
+	if (!dir) { /* playback */
+		if (routeinfo->p_route != RP_MEM_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC0_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC0_DVC0_SSI0) {
+			pr_info("scu playback route is invalid.\n");
+			return -EPERM;
+		}
+	} else { /* capture */
+		if (routeinfo->c_route != RC_SSI1_MEM &&
+		    routeinfo->c_route != RC_SSI1_SRC1_MEM &&
+		    routeinfo->c_route != RC_SSI1_SRC1_DVC1_MEM) {
+			pr_info("scu capture route is invalid.\n");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_check_route);
+
+/************************************************************************
+
+	DAPM
+
+************************************************************************/
+#undef EV_PRINT
+#ifdef EV_PRINT
+static void event_print(int event, char *evt_str)
+{
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMD\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMD\n", evt_str);
+		break;
+	default:
+		printk(KERN_INFO "%s unknown event\n", evt_str);
+	}
+}
+#else
+#define event_print(a, b)
+#endif
+
+static int event_ssi0(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi0;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi0;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src0(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi_src = scu_init_ssi0_src0;
+		routeinfo->pcb.deinit_ssi_src = scu_deinit_ssi0_src0;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi_src = NULL;
+		routeinfo->pcb.deinit_ssi_src = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_dvc0(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_dvc0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi_dvc = scu_init_ssi0_dvc0;
+		routeinfo->pcb.deinit_ssi_dvc = scu_deinit_ssi0_dvc0;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi_dvc = NULL;
+		routeinfo->pcb.deinit_ssi_dvc = NULL;
+	}
+	return 0;
+}
+
+static int event_src0(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src0;
+		routeinfo->pcb.deinit_src = scu_deinit_src0;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc0(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_dvc = scu_init_dvc0;
+		routeinfo->pcb.deinit_dvc = scu_deinit_dvc0;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_dvc = NULL;
+		routeinfo->pcb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi = scu_init_ssi1;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi1_src1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi1_src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi_src = scu_init_ssi1_src1;
+		routeinfo->ccb.deinit_ssi_src = scu_deinit_ssi1_src1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi_src = NULL;
+		routeinfo->ccb.deinit_ssi_src = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi1_dvc1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi_dvc = scu_init_ssi1_dvc1;
+		routeinfo->ccb.deinit_ssi_dvc = scu_deinit_ssi1_dvc1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi_dvc = NULL;
+		routeinfo->ccb.deinit_ssi_dvc = NULL;
+	}
+	return 0;
+}
+
+static int event_src1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src = scu_init_src1;
+		routeinfo->ccb.deinit_src = scu_deinit_src1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src = NULL;
+		routeinfo->ccb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1_dvc1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src_dvc = scu_init_src1_dvc1;
+		routeinfo->ccb.deinit_src_dvc = scu_deinit_src1_dvc1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src_dvc = NULL;
+		routeinfo->ccb.deinit_src_dvc = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc1(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_dvc = scu_init_dvc1;
+		routeinfo->ccb.deinit_dvc = scu_deinit_dvc1;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_dvc = NULL;
+		routeinfo->ccb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static void scu_playback_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT1");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT2");
+
+	switch (routeinfo->p_route) {
+	case RP_MEM_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT0");
+		break;
+	case RP_MEM_SRC0_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT1");
+		break;
+	case RP_MEM_SRC0_DVC0_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT2");
+		break;
+	default:
+		break;
+	};
+}
+
+static void scu_capture_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI1_IN0");
+	snd_soc_dapm_disable_pin(dapm, "SSI1_IN1");
+	snd_soc_dapm_disable_pin(dapm, "SSI1_IN2");
+
+	switch (routeinfo->c_route) {
+	case RC_SSI1_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI1_IN0");
+		break;
+	case RC_SSI1_SRC1_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI1_IN1");
+		break;
+	case RC_SSI1_SRC1_DVC1_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI1_IN2");
+		break;
+	default:
+		break;
+	};
+}
+
+static int scu_get_ssi0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[0];
+
+	return 0;
+}
+
+static int scu_set_ssi0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_ssi[0])
+		routeinfo->p_route |= W_SSI0;
+	else
+		routeinfo->p_route &= ~W_SSI0;
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[0];
+
+	return 0;
+}
+
+static int scu_set_src0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[0])
+		routeinfo->p_route |= W_SRC0;
+	else
+		routeinfo->p_route &= ~W_SRC0;
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[0];
+
+	return 0;
+}
+
+static int scu_set_dvc0_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[0])
+		routeinfo->p_route |= W_DVC0;
+	else
+		routeinfo->p_route &= ~W_DVC0;
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_ssi1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[1];
+
+	return 0;
+}
+
+static int scu_set_ssi1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_ssi[1])
+		routeinfo->c_route |= W_SSI1;
+	else
+		routeinfo->c_route &= ~W_SSI1;
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[1];
+
+	return 0;
+}
+
+static int scu_set_src1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[1])
+		routeinfo->c_route |= W_SRC1;
+	else
+		routeinfo->c_route &= ~W_SRC1;
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[1];
+
+	return 0;
+}
+
+static int scu_set_dvc1_route(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[1])
+		routeinfo->c_route |= W_DVC1;
+	else
+		routeinfo->c_route &= ~W_DVC1;
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static const char * const widget_switch[] = {"Off", "On"};
+
+static const struct soc_enum widget_switch_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(widget_switch), widget_switch);
+
+static const struct snd_kcontrol_new playback_controls[] = {
+	SOC_ENUM_EXT("SSI0 control", widget_switch_enum,
+		scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC0 control", widget_switch_enum,
+		scu_get_src0_route, scu_set_src0_route),
+	SOC_ENUM_EXT("DVC0 control", widget_switch_enum,
+		scu_get_dvc0_route, scu_set_dvc0_route),
+};
+
+static const struct snd_kcontrol_new capture_controls[] = {
+	SOC_ENUM_EXT("SSI1 control", widget_switch_enum,
+		scu_get_ssi1_route, scu_set_ssi1_route),
+	SOC_ENUM_EXT("SRC1 control", widget_switch_enum,
+		scu_get_src1_route, scu_set_src1_route),
+	SOC_ENUM_EXT("DVC1 control", widget_switch_enum,
+		scu_get_dvc1_route, scu_set_dvc1_route),
+};
+
+static const struct snd_soc_dapm_widget lager_dapm_widgets[] = {
+	/* Playback */
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT0"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT1"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT2"),
+
+	SND_SOC_DAPM_DAC("MEM_OUT", "HiFi Playback", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi0,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi0_src0,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_DVC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi0_dvc0,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_src0,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_dvc0,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	/* Capture */
+	SND_SOC_DAPM_ADC("MEM_IN", "HiFi Capture", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_INPUT("SSI1_IN0"),
+	SND_SOC_DAPM_INPUT("SSI1_IN1"),
+	SND_SOC_DAPM_INPUT("SSI1_IN2"),
+
+	SND_SOC_DAPM_MIXER_E("SSI1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI1_SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi1_src1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI1_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_ssi1_dvc1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_src1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_src1_dvc1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+		event_dvc1,
+		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/*
+	 * Playback route
+	 */
+	/* SSI<-MEM */
+	{"SSI0", NULL, "MEM_OUT"},
+	{"SSI0_OUT0", NULL, "SSI0"},
+	/* SSI<-SRC<-MEM */
+	{"SRC0", NULL, "MEM_OUT"},
+	{"SSI0_SRC0", NULL, "SRC0"},
+	{"SSI0_OUT1", NULL, "SSI0_SRC0"},
+	/* SSI<-DVC<-SRC<-MEM */
+	{"DVC0", NULL, "SRC0"},
+	{"SSI0_DVC0", NULL, "DVC0"},
+	{"SSI0_OUT2", NULL, "SSI0_DVC0"},
+
+	/*
+	 * Capture route
+	 */
+	/* MEM<-SSI */
+	{"SSI1", NULL, "SSI1_IN0"},
+	{"MEM_IN", NULL, "SSI1"},
+	/* MEM<-SRC<-SSI */
+	{"SSI1_SRC1", NULL, "SSI1_IN1"},
+	{"SRC1", NULL, "SSI1_SRC1"},
+	{"MEM_IN", NULL, "SRC1"},
+	/* MEM<-DVC<-SRC<-SSI */
+	{"SSI1_DVC1", NULL, "SSI1_IN2"},
+	{"SRC1_DVC1", NULL, "SSI1_DVC1"},
+	{"DVC1", NULL, "SRC1_DVC1"},
+	{"MEM_IN", NULL, "DVC1"},
+};
+
+/************************************************************************
+
+	ALSA SoC
+
+************************************************************************/
+static int lager_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	/* set PLL clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 11289600, SND_SOC_CLOCK_IN);
+	if (ret) {
+		pr_err("snd_soc_dai_set_sysclk err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_CBS_CFS |
+					 SND_SOC_DAIFMT_I2S);
+	if (ret) {
+		pr_err("snd_soc_dai_set_fmt err=%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int lager_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static struct snd_soc_ops lager_dai_ops = {
+	.hw_params = lager_hw_params,
+	.hw_free = lager_hw_free,
+};
+
+static int lager_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret;
+
+	FNC_ENTRY
+	/* Add controls */
+	ret = snd_soc_add_card_controls(rtd->card, playback_controls,
+					ARRAY_SIZE(playback_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(playback) err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_add_card_controls(rtd->card, capture_controls,
+					ARRAY_SIZE(capture_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(capture) err=%d\n", ret);
+		return ret;
+	}
+
+	/* Add widget and route for scu */
+	ret = snd_soc_dapm_new_controls(dapm, lager_dapm_widgets,
+				  ARRAY_SIZE(lager_dapm_widgets));
+	if (ret) {
+		pr_err("snd_soc_dapm_new_controls err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret) {
+		pr_err("snd_soc_dapm_add_routes err=%d\n", ret);
+		return ret;
+	}
+
+	scu_playback_route_control(dapm);
+	scu_capture_route_control(dapm);
+
+	FNC_EXIT
+	return ret;
+}
+
+/* lager digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link lager_dai = {
+	.name		= "ak4643",
+	.stream_name	= "AK4643",
+	.cpu_dai_name	= "scu-ssi-dai",
+	.codec_dai_name	= "ak4642-hifi",
+	.platform_name	= "scu-pcm-audio.0",
+	.codec_name	= "ak4642-codec.2-0012",
+	.ops		= &lager_dai_ops,
+	.init		= lager_dai_init,
+};
+
+/* lager audio machine driver */
+static struct snd_soc_card snd_soc_lager = {
+	.name = "lager-ak4643",
+	.owner = THIS_MODULE,
+	.dai_link = &lager_dai,
+	.num_links = 1,
+};
+
+static int __devinit lager_probe(struct platform_device *pdev)
+{
+	int ret = -ENOMEM;
+
+	FNC_ENTRY
+	routeinfo = scu_get_route_info();
+
+	snd_soc_lager.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_soc_lager);
+	if (ret)
+		pr_err("Unable to register sourd card\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct platform_driver lager_alsa_driver = {
+	.driver = {
+		.name = "lager_alsa_soc_platform",
+		.owner = THIS_MODULE,
+	},
+	.probe = lager_probe,
+};
+
+module_platform_driver(lager_alsa_driver);
+
+MODULE_AUTHOR("Renesas Electronics");
+MODULE_DESCRIPTION("ALSA SoC LAGER");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/sh/scu_dai.c b/sound/soc/sh/scu_dai.c
new file mode 100644
index 0000000..95fe501
--- /dev/null
+++ b/sound/soc/sh/scu_dai.c
@@ -0,0 +1,984 @@
+/*
+ * sound/soc/sh/scu_dai.c
+ *     This file is ALSA SoC driver for SCU peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_dai.c
+ *
+ * siu_dai.c - ALSA SoC driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/sh_scu.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static struct scu_reg_info *rinfo;
+static spinlock_t *sculock;
+static struct scu_audio_info *ainfo;
+
+struct scu_route_info *scu_get_route_info(void)
+{
+	return &ainfo->routeinfo;
+}
+EXPORT_SYMBOL(scu_get_route_info);
+
+/************************************************************************
+
+	basic function
+
+************************************************************************/
+static void scu_or_writel(u32 data, u32 *reg)
+{
+	u32 val;
+
+	spin_lock(sculock);
+	val = readl(reg);
+	writel((val | data), reg);
+	spin_unlock(sculock);
+}
+
+static void scu_and_writel(u32 data, u32 *reg)
+{
+	u32 val;
+
+	spin_lock(sculock);
+	val = readl(reg);
+	writel((val & data), reg);
+	spin_unlock(sculock);
+}
+
+/************************************************************************
+
+	peripheral function
+
+************************************************************************/
+static void adg_init(void)
+{
+	FNC_ENTRY
+
+	/* clock select */
+	scu_or_writel(0x23550000,
+		(u32 *)(rinfo->adgreg + ADG_SSICKR));
+
+	/* audio clock select */
+	scu_or_writel(((ADG_SEL0_SSI1_DIV1 | ADG_SEL0_SSI1_ACLK_DIV |
+		ADG_SEL0_SSI1_DIVCLK_CLKA) | (ADG_SEL0_SSI0_DIV1 |
+		ADG_SEL0_SSI0_ACLK_DIV | ADG_SEL0_SSI0_DIVCLK_CLKA)),
+		(u32 *)(rinfo->adgreg + ADG_AUDIO_CLK_SEL0));
+
+	/* SRC Input Timing */
+	scu_or_writel(ADG_SRCIN0_SRC0_DIVCLK_SSI_WS0,
+		(u32 *)(rinfo->adgreg + ADG_SRCIN_TIMSEL0));
+
+	/* SRC Output Timing */
+	scu_or_writel(ADG_SRCOUT0_SRC0_DIVCLK_SSI_WS0,
+		(u32 *)(rinfo->adgreg + ADG_SRCOUT_TIMSEL0));
+
+	/* CMD Output Timing */
+	/* not implement */
+
+	/* division enable */
+	scu_or_writel(ADG_DIVEN_AUDIO_CLKA,
+			(u32 *)(rinfo->adgreg + ADG_DIV_EN));
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssiu_init(void)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_control(int master_ch, int slave_ch)
+{
+	FNC_ENTRY
+	/* SSI setting */
+	writel(SSICR_P4643_ST, &rinfo->ssireg[master_ch]->cr);
+	writel(SSIWS_ST, &rinfo->ssireg[master_ch]->wsr);
+	writel(SSICR_C4643_ST, &rinfo->ssireg[slave_ch]->cr);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_start(int ssi_ch)
+{
+	u32 val, reg;
+
+	FNC_ENTRY
+	/* SSI enable (figure.39.12 flow) */
+	val = readl(&rinfo->ssireg[ssi_ch]->cr);
+	val |= (SSICR_DMEN | SSICR_UIEN | SSICR_OIEN | SSICR_ENABLE);
+	writel(val, &rinfo->ssireg[ssi_ch]->cr);
+
+	/* SSIU start (figure.39.12 flow) */
+	if (ssi_ch == 0)
+		reg = SSI0_0_CONTROL;
+	else
+		reg = SSI1_0_CONTROL;
+
+	scu_or_writel(SSI_CTRL_4CH_START0,
+		(u32 *)(rinfo->ssiureg + reg));
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_stop(int ssi_ch)
+{
+	u32 val, reg;
+
+	FNC_ENTRY
+	/* SSI disable (figure.39.13 flow) */
+	val = readl(&rinfo->ssireg[ssi_ch]->cr);
+	val &= ~(SSICR_DMEN | SSICR_UIEN | SSICR_UIEN | SSICR_ENABLE);
+	writel(val, &rinfo->ssireg[ssi_ch]->cr);
+	FNC_EXIT
+
+	/* SSIU stop (figure.39.13 flow) */
+	if (ssi_ch == 0)
+		reg = SSI0_0_CONTROL;
+	else
+		reg = SSI1_0_CONTROL;
+
+	writel(0, (u32 *)(rinfo->ssiureg + reg));
+}
+
+void scu_src_control(int src_ch, struct snd_pcm_substream *ss)
+{
+	u64 val = 0;
+
+	FNC_ENTRY
+	/* SRC Activation (SRC_SWRSR) Figure42.7 */
+	writel(0, (u32 *)&rinfo->srcreg[src_ch]->swrsr);
+	writel(1, (u32 *)&rinfo->srcreg[src_ch]->swrsr);
+
+	/* SRC_SRCIR */
+	writel(1, (u32 *)&rinfo->srcreg[src_ch]->srcir);
+
+	/* SRC_ADINR *//* only stereo now */
+	writel((SRCADIN_OTBL_16BIT | SRCADIN_CHNUM_2),
+		(u32 *)&rinfo->srcreg[src_ch]->adinr);
+
+	/* SRC_IFSCR INTIFS enable */
+	writel(1, (u32 *)&rinfo->srcreg[src_ch]->ifscr);
+
+	/* SRC_IFSVR INTIFS calculation */
+#ifdef CONVERT_48KHZ
+	/* Convert example (48kHz) */
+	val = div_u64(SRC_IFS_FSO * ss->runtime->rate, SRC_IFS_48KHZ);
+#else
+	/* Not convert example (CODEC driver converts by itself) */
+	val = SRC_IFS_FSO;
+#endif
+	writel((u32)val, (u32 *)&rinfo->srcreg[src_ch]->ifsvr);
+
+	/* SRC_SRCCR */
+	writel(0x00010111, (u32 *)&rinfo->srcreg[src_ch]->srccr);
+
+	/* SRC_MNFSR MINFS calculation */
+	val = div_u64(val * 98, 100);	/* 98% */
+	writel(val, (u32 *)&rinfo->srcreg[src_ch]->mnfsr);
+
+	/* SRC_BSDSR (FSO/FSI Ratio is 6-1) */
+	writel(0x00400000, (u32 *)&rinfo->srcreg[src_ch]->bsdsr);
+
+	/* SRC_BSISR (FSO/FSI Ratio is 6-1) */
+	writel(0x00100020, (u32 *)&rinfo->srcreg[src_ch]->bsisr);
+
+	/* SRC_SRCIR */
+	writel(0, (u32 *)&rinfo->srcreg[src_ch]->srcir);
+
+	FNC_EXIT
+	return;
+}
+EXPORT_SYMBOL(scu_src_control);
+
+static void scu_src_start(int src_ch, int src_dir)
+{
+	FNC_ENTRY
+	/* SCU SRC_MODE */
+	writel(SRC_MODE_SRCUSE, (u32 *)&rinfo->scusrcreg[src_ch]->mode);
+
+	/* SRC_CONTROL */
+	if (src_dir == SRC_INOUT)
+		scu_or_writel((SRC_MODE_START_IN | SRC_MODE_START_OUT),
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+	else if (src_dir == SRC_OUT)
+		scu_or_writel(SRC_MODE_START_OUT,
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+	else /* SRC_IN */
+		scu_or_writel(SRC_MODE_START_IN,
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+	FNC_EXIT
+	return;
+}
+
+static void scu_src_stop(int src_ch, int src_dir)
+{
+	FNC_ENTRY
+	/* SRC_CONTROL */
+	if (src_dir == SRC_INOUT)
+		scu_and_writel(~(SRC_MODE_START_IN | SRC_MODE_START_OUT),
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+	if (src_dir == SRC_OUT)
+		scu_and_writel(~SRC_MODE_START_OUT,
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+	else /* SRC_IN */
+		scu_and_writel(~SRC_MODE_START_IN,
+			(u32 *)&rinfo->scusrcreg[src_ch]->control);
+
+	/* SCU SRC_MODE */
+	writel(0, (u32 *)&rinfo->scusrcreg[src_ch]->mode);
+
+	FNC_EXIT
+	return;
+}
+
+/************************************************************************
+
+	DAPM callback function
+
+************************************************************************/
+static void scu_ssi_control(int master_ch, int slave_ch);
+static void scu_ssi_start(int ssi_ch);
+static void scu_ssi_stop(int ssi_ch);
+
+void scu_init_ssi0(void)
+{
+	/* SSI0_0_BUSIF_ADINR */
+	scu_or_writel((SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI0_0_BUSIF_ADINR));
+	/* SSI_MODE0 (SSI independant) */
+	scu_or_writel(SSI_MODE0_IND0, (u32 *)(rinfo->ssiureg + SSI_MODE0));
+	/* SSI init */
+	scu_ssi_control(0, 1);
+	/* SSI start */
+	scu_ssi_start(0);
+}
+EXPORT_SYMBOL(scu_init_ssi0);
+
+void scu_deinit_ssi0(void)
+{
+	/* SSI stop */
+	scu_ssi_stop(0);
+	/* SSI_MODE0 (SSI independant) */
+	scu_and_writel(~SSI_MODE0_IND0, (u32 *)(rinfo->ssiureg + SSI_MODE0));
+	/* SSI0_0_BUSIF_ADINR */
+	scu_and_writel(~(SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI0_0_BUSIF_ADINR));
+}
+EXPORT_SYMBOL(scu_deinit_ssi0);
+
+void scu_init_ssi0_src0(void)
+{
+	/* SSI0_0_BUSIF_ADINR */
+	scu_or_writel((SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI0_0_BUSIF_ADINR));
+	/* SSI init */
+	scu_ssi_control(0, 1);
+	/* SSI start */
+	scu_ssi_start(0);
+}
+EXPORT_SYMBOL(scu_init_ssi0_src0);
+
+void scu_deinit_ssi0_src0(void)
+{
+	/* SSI stop */
+	scu_ssi_stop(0);
+	/* SSI0_0_BUSIF_ADINR */
+	scu_and_writel(~(SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI0_0_BUSIF_ADINR));
+}
+EXPORT_SYMBOL(scu_deinit_ssi0_src0);
+
+void scu_init_ssi0_dvc0(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_init_ssi0_dvc0);
+
+void scu_deinit_ssi0_dvc0(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_deinit_ssi0_dvc0);
+
+void scu_init_src0(void)
+{
+	/* start src */
+	scu_src_start(0, SRC_INOUT);
+}
+EXPORT_SYMBOL(scu_init_src0);
+
+void scu_deinit_src0(void)
+{
+	/* stop src */
+	scu_src_stop(0, SRC_INOUT);
+}
+EXPORT_SYMBOL(scu_deinit_src0);
+
+void scu_init_dvc0(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_init_dvc0);
+
+void scu_deinit_dvc0(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_deinit_dvc0);
+
+void scu_init_ssi1(void)
+{
+	/* SSI1_0_BUSIF_ADINR */
+	scu_or_writel((SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI1_0_BUSIF_ADINR));
+	/* SSI_MODE0 (SSI independant) */
+	scu_or_writel(SSI_MODE0_IND1, (u32 *)(rinfo->ssiureg + SSI_MODE0));
+	/* SSI_MODE1 (SSI1 slave, SSI0 master) */
+	scu_or_writel(SSI_MODE1_SSI1_MASTER,
+			(u32 *)(rinfo->ssiureg + SSI_MODE1));
+	/* SSI init */
+	scu_ssi_control(0, 1);
+	/* SSI start */
+	scu_ssi_start(1);
+}
+EXPORT_SYMBOL(scu_init_ssi1);
+
+void scu_deinit_ssi1(void)
+{
+	/* SSI stop */
+	scu_ssi_stop(1);
+	/* SSI_MODE1 (SSI1 slave, SSI0 master) */
+	scu_and_writel(~SSI_MODE1_SSI1_MASTER,
+			(u32 *)(rinfo->ssiureg + SSI_MODE1));
+	/* SSI_MODE0 (SSI independant) */
+	scu_and_writel(~SSI_MODE0_IND1, (u32 *)(rinfo->ssiureg + SSI_MODE0));
+	/* SSI0_0_BUSIF_ADINR */
+	scu_and_writel(~(SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI1_0_BUSIF_ADINR));
+}
+EXPORT_SYMBOL(scu_deinit_ssi1);
+
+void scu_init_ssi1_src1(void)
+{
+	/* SSI1_0_BUSIF_ADINR */
+	scu_or_writel((SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI1_0_BUSIF_ADINR));
+	/* SSI_MODE1 (SSI1 slave, SSI0 master) */
+	scu_or_writel(SSI_MODE1_SSI1_MASTER,
+			(u32 *)(rinfo->ssiureg + SSI_MODE1));
+	/* SSI init */
+	scu_ssi_control(0, 1);
+	/* SSI start */
+	scu_ssi_start(1);
+}
+EXPORT_SYMBOL(scu_init_ssi1_src1);
+
+void scu_deinit_ssi1_src1(void)
+{
+	/* SSI stop */
+	scu_ssi_stop(1);
+	/* SSI_MODE1 (SSI1 slave, SSI0 master) */
+	scu_and_writel(~SSI_MODE1_SSI1_MASTER,
+			(u32 *)(rinfo->ssiureg + SSI_MODE1));
+	/* SSI0_0_BUSIF_ADINR */
+	scu_and_writel(~(SSI_ADINR_OTBL_16BIT | SSI_ADINR_CHNUM_2CH),
+			(u32 *)(rinfo->ssiureg + SSI1_0_BUSIF_ADINR));
+}
+EXPORT_SYMBOL(scu_deinit_ssi1_src1);
+
+void scu_init_ssi1_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_init_ssi1_dvc1);
+
+void scu_deinit_ssi1_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_deinit_ssi1_dvc1);
+
+void scu_init_src1(void)
+{
+	/* start src */
+	scu_src_start(1, SRC_INOUT);
+}
+EXPORT_SYMBOL(scu_init_src1);
+
+void scu_deinit_src1(void)
+{
+	/* stop src */
+	scu_src_stop(1, SRC_INOUT);
+}
+EXPORT_SYMBOL(scu_deinit_src1);
+
+void scu_init_src1_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_init_src1_dvc1);
+
+void scu_deinit_src1_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_deinit_src1_dvc1);
+
+void scu_init_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_init_dvc1);
+
+void scu_deinit_dvc1(void)
+{
+	/* no process (not implement ) */
+}
+EXPORT_SYMBOL(scu_deinit_dvc1);
+
+/************************************************************************
+
+	dai ops
+
+************************************************************************/
+/* Playback and capture hardware properties are identical */
+static struct snd_pcm_hardware scu_dai_pcm_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED	|
+				   SNDRV_PCM_INFO_MMAP		|
+				   SNDRV_PCM_INFO_MMAP_VALID	|
+				   SNDRV_PCM_INFO_PAUSE),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_8000_48000,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= SCU_BUFFER_BYTES_MAX,
+	.period_bytes_min	= SCU_PERIOD_BYTES_MIN,
+	.period_bytes_max	= SCU_PERIOD_BYTES_MAX,
+	.periods_min		= SCU_PERIODS_MIN,
+	.periods_max		= SCU_PERIODS_MAX,
+};
+
+static int scu_dai_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	FNC_ENTRY
+	snd_soc_set_runtime_hwparams(substream, &scu_dai_pcm_hw);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dai_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return;
+}
+
+static int scu_dai_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_fmt(struct snd_soc_dai *dai,
+			   unsigned int fmt)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+			      unsigned int freq, int dir)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static const struct snd_soc_dai_ops scu_dai_ops = {
+	.startup	= scu_dai_startup,
+	.shutdown	= scu_dai_shutdown,
+	.prepare	= scu_dai_prepare,
+	.set_sysclk	= scu_dai_set_sysclk,
+	.set_fmt	= scu_dai_set_fmt,
+};
+
+static struct snd_soc_dai_driver scu_ssi_dai = {
+	.name	= "scu-ssi-dai",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	 },
+	.ops = &scu_dai_ops,
+};
+
+static void scu_alloc_scureg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	/* SCU common */
+	rinfo->scureg = mem + 0x500000;
+	DBG_MSG("scureg=%08x\n", (int)rinfo->scureg);
+
+	/* SCU common SRC */
+	offset = mem + 0x500000;
+	for (i = 0; i < MAXCH_SRC; i++) {
+		rinfo->scusrcreg[i] = (struct scu_src_regs *)offset;
+		offset += 0x20;
+		DBG_MSG("scusrcreg[%2d]=%08x\n", i, (int)rinfo->scusrcreg[i]);
+	}
+
+	/* SCU common CMD */
+	offset = mem + 0x500184;
+	for (i = 0; i < MAXCH_CMD; i++) {
+		rinfo->scucmdreg[i] = (struct scu_cmd_regs *)offset;
+		offset += 0x20;
+		DBG_MSG("scucmdreg[%2d]=%08x\n", i, (int)rinfo->scucmdreg[i]);
+	}
+
+	/* SRC */
+	offset = mem + 0x500200;
+	for (i = 0; i < MAXCH_SRC; i++) {
+		rinfo->srcreg[i] = (struct src_regs *)offset;
+		offset += 0x40;
+		DBG_MSG("srcreg[%2d]=%08x\n", i, (int)rinfo->srcreg[i]);
+	}
+
+	/* CTU */
+	offset = mem + 0x500500;
+	for (i = 0; i < MAXCH_CTU; i++) {
+		rinfo->ctureg[i] = (struct ctu_regs *)offset;
+		offset += 0x100;
+		DBG_MSG("ctureg[%2d]=%08x\n", i, (int)rinfo->ctureg[i]);
+	}
+
+	/* MIX */
+	offset = mem + 0x500d00;
+	for (i = 0; i < MAXCH_CMD; i++) {
+		rinfo->mixreg[i] = (struct mix_regs *)offset;
+		offset += 0x40;
+		DBG_MSG("mixreg[%2d]=%08x\n", i, (int)rinfo->mixreg[i]);
+	}
+
+	/* DVC */
+	offset = mem + 0x500e00;
+	for (i = 0; i < MAXCH_CMD; i++) {
+		rinfo->dvcreg[i] = (struct dvc_regs *)offset;
+		offset += 0x100;
+		DBG_MSG("dvcreg[%2d]=%08x\n", i, (int)rinfo->dvcreg[i]);
+	}
+
+	return;
+}
+
+static void scu_alloc_ssireg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	offset = mem;
+	for (i = 0; i < MAXCH_SSI; i++) {
+		rinfo->ssireg[i] = (struct ssi_regs *)offset;
+		offset += 0x40;
+		DBG_MSG("ssireg[%2d]=%08x\n", i, (int)rinfo->ssireg[i]);
+	}
+
+	return;
+}
+
+static int __devinit scu_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct scu_clock_info *cinfo;
+	struct resource *scu_res;
+	struct resource *scu_region = NULL;
+	struct resource *ssiu_res;
+	struct resource *ssiu_region = NULL;
+	struct resource *ssi_res;
+	struct resource *ssi_region = NULL;
+	struct resource *adg_res;
+	struct resource *adg_region = NULL;
+	void __iomem *mem;
+
+	FNC_ENTRY
+	if (pdev->id != 0) {
+		dev_err(&pdev->dev, "current scu support id 0 only now\n");
+		return -ENODEV;
+	}
+
+	ainfo = kzalloc(sizeof(struct scu_audio_info), GFP_KERNEL);
+	if (!ainfo) {
+		dev_err(&pdev->dev, "no memory\n");
+		return -ENOMEM;
+	}
+	cinfo = &ainfo->clockinfo;
+	rinfo = &ainfo->reginfo;
+
+	spin_lock_init(&ainfo->scu_lock);
+	sculock = &ainfo->scu_lock;
+
+	/* request clocks */
+	cinfo->adg_clk = clk_get(NULL, "adg");
+	if (IS_ERR(cinfo->adg_clk)) {
+		dev_err(&pdev->dev, "Unable to get adg clock\n");
+		ret = PTR_ERR(cinfo->adg_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->scu_clk = clk_get(NULL, "scu");
+	if (IS_ERR(cinfo->scu_clk)) {
+		dev_err(&pdev->dev, "Unable to get scu clock\n");
+		ret = PTR_ERR(cinfo->scu_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->src0_clk = clk_get(NULL, "src0");
+	if (IS_ERR(cinfo->src0_clk)) {
+		dev_err(&pdev->dev, "Unable to get src0 clock\n");
+		ret = PTR_ERR(cinfo->src0_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->src1_clk = clk_get(NULL, "src1");
+	if (IS_ERR(cinfo->src1_clk)) {
+		dev_err(&pdev->dev, "Unable to get src1 clock\n");
+		ret = PTR_ERR(cinfo->src1_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->dvc0_clk = clk_get(NULL, "dvc0");
+	if (IS_ERR(cinfo->dvc0_clk)) {
+		dev_err(&pdev->dev, "Unable to get dvc0 clock\n");
+		ret = PTR_ERR(cinfo->dvc0_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->dvc1_clk = clk_get(NULL, "dvc1");
+	if (IS_ERR(cinfo->dvc1_clk)) {
+		dev_err(&pdev->dev, "Unable to get dvc1 clock\n");
+		ret = PTR_ERR(cinfo->dvc1_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->ssiu_clk = clk_get(NULL, "ssi");
+	if (IS_ERR(cinfo->ssiu_clk)) {
+		dev_err(&pdev->dev, "Unable to get ssiu clock\n");
+		ret = PTR_ERR(cinfo->ssiu_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->ssi0_clk = clk_get(NULL, "ssi0");
+	if (IS_ERR(cinfo->ssi0_clk)) {
+		dev_err(&pdev->dev, "Unable to get ssi0 clock\n");
+		ret = PTR_ERR(cinfo->ssi0_clk);
+		goto error_clk_put;
+	}
+
+	cinfo->ssi1_clk = clk_get(NULL, "ssi1");
+	if (IS_ERR(cinfo->ssi1_clk)) {
+		dev_err(&pdev->dev, "Unable to get ssi1 clock\n");
+		ret = PTR_ERR(cinfo->ssi1_clk);
+		goto error_clk_put;
+	}
+
+	/* resource */
+	scu_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!scu_res) {
+		dev_err(&pdev->dev, "No memory (0) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	ssiu_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!ssiu_res) {
+		dev_err(&pdev->dev, "No memory (1) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	ssi_res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!ssiu_res) {
+		dev_err(&pdev->dev, "No memory (2) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	adg_res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (!adg_res) {
+		dev_err(&pdev->dev, "No memory (3) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	scu_region = request_mem_region(scu_res->start,
+			resource_size(scu_res), pdev->name);
+	if (!scu_region) {
+		dev_err(&pdev->dev, "SCU region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	ssiu_region = request_mem_region(ssiu_res->start,
+			resource_size(ssiu_res), pdev->name);
+	if (!ssiu_region) {
+		dev_err(&pdev->dev, "SSIU region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	ssi_region = request_mem_region(ssi_res->start,
+			resource_size(ssi_res), pdev->name);
+	if (!ssi_region) {
+		dev_err(&pdev->dev, "SSI region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	adg_region = request_mem_region(adg_res->start,
+			resource_size(adg_res), pdev->name);
+	if (!adg_region) {
+		dev_err(&pdev->dev, "ADG region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	/* mapping scu */
+	mem = ioremap_nocache(scu_res->start, resource_size(scu_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for scu\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_scureg(mem);
+
+	mem = ioremap_nocache(ssiu_res->start, resource_size(ssiu_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for ssiu\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	rinfo->ssiureg = mem;
+	DBG_MSG("ssiureg=%08x\n", (int)rinfo->ssiureg);
+
+	mem = ioremap_nocache(ssi_res->start, resource_size(ssi_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for ssi\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_ssireg(mem);
+
+	mem = ioremap_nocache(adg_res->start, resource_size(adg_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for adg\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	rinfo->adgreg = mem;
+	DBG_MSG("adgreg=%08x\n", (int)rinfo->adgreg);
+
+	clk_enable(cinfo->adg_clk);
+	clk_enable(cinfo->scu_clk);
+	clk_enable(cinfo->src0_clk);
+	clk_enable(cinfo->src1_clk);
+	clk_enable(cinfo->dvc0_clk);
+	clk_enable(cinfo->dvc1_clk);
+	clk_enable(cinfo->ssiu_clk);
+	clk_enable(cinfo->ssi0_clk);
+	clk_enable(cinfo->ssi1_clk);
+
+	ret = snd_soc_register_platform(&pdev->dev, &scu_platform);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc register\n");
+		goto error_unmap;
+	}
+
+	ret = snd_soc_register_dais(&pdev->dev, &scu_ssi_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc dais register\n");
+		goto error_unregister;
+	}
+
+	adg_init();
+	scu_ssiu_init();
+
+	FNC_EXIT
+	return ret;
+
+error_unregister:
+	snd_soc_unregister_platform(&pdev->dev);
+
+error_unmap:
+	if (rinfo->scureg)
+		iounmap(rinfo->scureg);
+	if (rinfo->ssiureg)
+		iounmap(rinfo->ssiureg);
+	if (rinfo->ssireg)
+		iounmap(rinfo->ssireg);
+	if (rinfo->adgreg)
+		iounmap(rinfo->adgreg);
+
+error_release:
+	if (scu_region)
+		release_mem_region(scu_res->start, resource_size(scu_res));
+	if (ssiu_region)
+		release_mem_region(ssiu_res->start, resource_size(ssiu_res));
+	if (ssi_region)
+		release_mem_region(ssi_res->start, resource_size(ssi_res));
+	if (adg_region)
+		release_mem_region(adg_res->start, resource_size(adg_res));
+
+error_clk_put:
+	if (!IS_ERR(cinfo->adg_clk))
+		clk_put(cinfo->adg_clk);
+	if (!IS_ERR(cinfo->scu_clk))
+		clk_put(cinfo->scu_clk);
+	if (!IS_ERR(cinfo->src0_clk))
+		clk_put(cinfo->src0_clk);
+	if (!IS_ERR(cinfo->src1_clk))
+		clk_put(cinfo->src1_clk);
+	if (!IS_ERR(cinfo->dvc0_clk))
+		clk_put(cinfo->dvc0_clk);
+	if (!IS_ERR(cinfo->dvc1_clk))
+		clk_put(cinfo->dvc1_clk);
+	if (!IS_ERR(cinfo->ssiu_clk))
+		clk_put(cinfo->ssiu_clk);
+	if (!IS_ERR(cinfo->ssi0_clk))
+		clk_put(cinfo->ssi0_clk);
+	if (!IS_ERR(cinfo->ssi1_clk))
+		clk_put(cinfo->ssi1_clk);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int __devexit scu_remove(struct platform_device *pdev)
+{
+	struct scu_clock_info *cinfo = &ainfo->clockinfo;
+	struct resource *res;
+
+	FNC_ENTRY
+	snd_soc_unregister_dai(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+
+	clk_disable(cinfo->adg_clk);
+	clk_disable(cinfo->scu_clk);
+	clk_disable(cinfo->src0_clk);
+	clk_disable(cinfo->src1_clk);
+	clk_disable(cinfo->dvc0_clk);
+	clk_disable(cinfo->dvc1_clk);
+	clk_disable(cinfo->ssiu_clk);
+	clk_disable(cinfo->ssi0_clk);
+	clk_disable(cinfo->ssi1_clk);
+
+	clk_put(cinfo->adg_clk);
+	clk_put(cinfo->scu_clk);
+	clk_put(cinfo->src0_clk);
+	clk_put(cinfo->src1_clk);
+	clk_put(cinfo->dvc0_clk);
+	clk_put(cinfo->dvc1_clk);
+	clk_put(cinfo->ssiu_clk);
+	clk_put(cinfo->ssi0_clk);
+	clk_put(cinfo->ssi1_clk);
+
+	iounmap(rinfo->scureg);
+	iounmap(rinfo->ssiureg);
+	iounmap(rinfo->ssireg);
+	iounmap(rinfo->adgreg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	kfree(ainfo);
+
+	FNC_EXIT
+	return 0;
+}
+
+static struct platform_driver scu_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "scu-pcm-audio",
+	},
+	.probe		= scu_probe,
+	.remove		= __devexit_p(scu_remove),
+};
+
+module_platform_driver(scu_driver);
+
+MODULE_AUTHOR("Carlos Munoz <carlos@kenati.com>");
+MODULE_DESCRIPTION("ALSA SoC SH7722 SIU driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sh/scu_pcm.c b/sound/soc/sh/scu_pcm.c
new file mode 100644
index 0000000..f4a436e
--- /dev/null
+++ b/sound/soc/sh/scu_pcm.c
@@ -0,0 +1,746 @@
+/*
+ * sound/soc/sh/scu_pcm.c
+ *     This file is ALSA SoC driver for SCU peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_pcm.c
+ *
+ * siu_pcm.c - ALSA driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/sh_scu.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static u64 dma_mask = DMA_BIT_MASK(32);
+
+static struct snd_soc_dai *scu_get_dai(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+
+	return  rtd->cpu_dai;
+}
+
+static void scu_dma_callback(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct snd_soc_dai *dai = scu_get_dai(ss);
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int buf_pos;
+	u32 dma_size;
+	u32 dma_paddr;
+
+	FNC_ENTRY
+
+	buf_pos = pcminfo->period & (SCU_PERIODS_MAX - 1);
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	dma_paddr = runtime->dma_addr + (buf_pos * dma_size);
+	dma_sync_single_for_cpu(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	pcminfo->tran_period++;
+
+	/* Notify alsa: a period is done */
+	snd_pcm_period_elapsed(ss);
+
+	/* stop dma */
+	if (pcminfo->flag_start == 0)
+		return;
+
+	schedule_work(&pcminfo->work);
+
+	FNC_EXIT
+}
+
+static bool filter_audma(struct dma_chan *chan, void *slave)
+{
+	struct shdma_slave *param = slave;
+	struct platform_device *pdev = to_platform_device(chan->device->dev);
+
+	DBG_MSG("%s: pdev->id=%d, slave_id=%d\n",
+				__func__, pdev->id, param->slave_id);
+
+	if ((pdev->id != SHDMA_DEVID_AUDIO_LO) &&
+	    (pdev->id != SHDMA_DEVID_AUDIO_UP))
+		return false;
+
+	chan->private = param;
+	return true;
+}
+
+static bool filter_audmapp(struct dma_chan *chan, void *slave)
+{
+	struct shdma_slave *param = slave;
+	struct platform_device *pdev = to_platform_device(chan->device->dev);
+
+	DBG_MSG("%s: pdev->id=%d, slave_id=%d\n",
+				__func__, pdev->id, param->slave_id);
+
+	if (pdev->id != SHDMA_DEVID_AUDIOPP)
+		return false;
+
+	chan->private = param;
+	return true;
+}
+
+static int scu_dmae_req_chan(int sid, int did, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct sh_dmadesc_slave *param = &pcminfo->de_param[sid];
+	dma_cap_mask_t mask;
+	int ret = 0;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	DBG_MSG("sid=%d, did=%d\n", sid, did);
+
+	FNC_ENTRY
+	/* set dma slave id */
+	param->shdma_slave.slave_id = sid;
+
+	/* request dma channel */
+	if (pcminfo->de_chan[sid] == NULL) {
+		if (did == SHDMA_DEVID_AUDIO)
+			pcminfo->de_chan[sid] = dma_request_channel(mask,
+							filter_audma, param);
+		else /* did == SHDMA_DEVID_AUDIOPP */
+			pcminfo->de_chan[sid] = dma_request_channel(mask,
+							filter_audmapp, param);
+		if (!pcminfo->de_chan[sid]) {
+			printk(KERN_ERR "DMA channel request error\n");
+			ret = -EBUSY;
+		}
+	}
+
+	DBG_MSG("chan=0x%08x\n", (int)pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_rel_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	/* release dma channel */
+	if (pcminfo->de_chan[sid]) {
+		dma_release_channel(pcminfo->de_chan[sid]);
+		pcminfo->de_chan[sid] = NULL;
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_rel_allchan(struct snd_pcm_substream *ss)
+{
+	int i;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	/* release all dma channel */
+	for (i = 0; i < SHDMA_SLAVE_PCM_MAX; i++)
+		ret = scu_dmae_rel_chan(i, ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_request(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+	if (!dir) { /* playback */
+		/* ssi0 */
+		if (pcminfo->routeinfo->pcb.init_ssi) {
+			/* dma channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_MEM_SSI0,
+						SHDMA_DEVID_AUDIO, ss);
+		}
+
+		/* ssi0 via src0 */
+		if (pcminfo->routeinfo->pcb.init_ssi_src &&
+		    pcminfo->routeinfo->pcb.init_src) {
+			/* dma(mem->src) channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_MEM_SRC0,
+						SHDMA_DEVID_AUDIO, ss);
+
+			/* dma(src->ssi) channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_SRC0_SSI0,
+						SHDMA_DEVID_AUDIOPP, ss);
+		}
+
+		/* ssi0 via src0,dvc0 */
+		/* not implement */
+	} else { /* capture */
+		/* ssi1 */
+		if (pcminfo->routeinfo->ccb.init_ssi) {
+			/* dma channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_SSI1_MEM,
+						SHDMA_DEVID_AUDIO, ss);
+		}
+
+		/* ssi1 via src1 */
+		if (pcminfo->routeinfo->ccb.init_ssi_src &&
+		    pcminfo->routeinfo->ccb.init_src) {
+			/* dma(ssi->src) channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_SSI1_SRC1,
+						SHDMA_DEVID_AUDIOPP, ss);
+
+			/* dma(src->mem) channel allocation */
+			ret = scu_dmae_req_chan(SHDMA_SLAVE_PCM_SRC1_MEM,
+						SHDMA_DEVID_AUDIO, ss);
+		}
+
+		/* ssi1 via src1,dvc1 */
+		/* not implement */
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_release(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+	if (!dir) { /* playback */
+		/* ssi */
+		if (pcminfo->routeinfo->pcb.init_ssi)
+			ret = scu_dmae_rel_allchan(ss);
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->pcb.init_ssi_src &&
+		    pcminfo->routeinfo->pcb.init_src) {
+			ret = scu_dmae_rel_allchan(ss);
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+
+	} else { /* capture */
+		/* ssi */
+		if (pcminfo->routeinfo->ccb.init_ssi)
+			ret = scu_dmae_rel_allchan(ss);
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->ccb.init_ssi_src &&
+		    pcminfo->routeinfo->ccb.init_src) {
+			ret = scu_dmae_rel_allchan(ss);
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audma_start(int sid, struct snd_pcm_substream *ss)
+{
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int buf_pos;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	struct device *dev = ss->pcm->card->dev;
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+	u32 dma_size;
+	u32 dma_paddr;
+	struct snd_soc_dai *dai;
+
+	FNC_ENTRY
+	dai = scu_get_dai(ss);
+
+	/* buffer control */
+	buf_pos = pcminfo->period & (SCU_PERIODS_MAX - 1);
+	DBG_MSG("buf_pos=%d\n", buf_pos);
+
+	/* DMA size */
+	dma_size = frames_to_bytes(runtime, runtime->period_size);
+	DBG_MSG("dma_size=%d\n", dma_size);
+
+	/* DMA physical adddress */
+	dma_paddr = runtime->dma_addr + (buf_pos * dma_size);
+	DBG_MSG("dma_paddr=0x%08x\n", dma_paddr);
+
+	dma_sync_single_for_device(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	desc = dmaengine_prep_slave_single(pcminfo->de_chan[sid], dma_paddr,
+		dma_size, DMA_DIR(dir), DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dev_err(dai->dev, "dmaengine_prep_slave_sg_single() fail\n");
+		return -ENOMEM;
+	}
+
+	desc->callback = (dma_async_tx_callback)scu_dma_callback;
+	desc->callback_param = ss;
+
+	cookie = dmaengine_submit(desc);
+	if (cookie < 0) {
+		dev_err(dev, "Failed to submit a dma transfer\n");
+		FNC_EXIT
+		return cookie;
+	}
+
+	dma_async_issue_pending(pcminfo->de_chan[sid]);
+
+	/* Update period */
+	pcminfo->period++;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_audma_stop(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static void scu_pcm_start(struct snd_pcm_substream *ss, int first_flag)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+
+	FNC_ENTRY
+	if (!dir) { /* playback */
+		/* ssi */
+		if (pcminfo->routeinfo->pcb.init_ssi) {
+			/* start dma */
+			scu_audma_start(SHDMA_SLAVE_PCM_MEM_SSI0, ss);
+
+			if (first_flag) {
+				/* start ssi */
+				pcminfo->routeinfo->pcb.init_ssi();
+			}
+		}
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->pcb.init_ssi_src &&
+		    pcminfo->routeinfo->pcb.init_src) {
+			/* start dma */
+			scu_audma_start(SHDMA_SLAVE_PCM_MEM_SRC0, ss);
+
+			if (first_flag) {
+				/* control src */
+				scu_src_control(0, ss);
+
+				/* start ssi */
+				pcminfo->routeinfo->pcb.init_ssi_src();
+
+				/* start src */
+				pcminfo->routeinfo->pcb.init_src();
+			}
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+
+	} else { /* capture */
+		/* ssi */
+		if (pcminfo->routeinfo->ccb.init_ssi) {
+			/* start dma */
+			scu_audma_start(SHDMA_SLAVE_PCM_SSI1_MEM, ss);
+
+			if (first_flag) {
+				/* start ssi */
+				pcminfo->routeinfo->ccb.init_ssi();
+			}
+		}
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->ccb.init_ssi_src &&
+		    pcminfo->routeinfo->ccb.init_src) {
+			/* start dma */
+			scu_audma_start(SHDMA_SLAVE_PCM_SRC1_MEM, ss);
+
+			if (first_flag) {
+				/* control src */
+				scu_src_control(1, ss);
+
+				/* start ssi */
+				pcminfo->routeinfo->ccb.init_ssi_src();
+
+				/* start src */
+				pcminfo->routeinfo->ccb.init_src();
+			}
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_pcm_stop(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+
+	FNC_ENTRY
+	if (!dir) { /* playback */
+		/* ssi */
+		if (pcminfo->routeinfo->pcb.deinit_ssi) {
+			DBG_MSG("post:ssi\n");
+			/* stop ssi */
+			pcminfo->routeinfo->pcb.deinit_ssi();
+			/* stop dma */
+			scu_audma_stop(ss);
+		}
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->pcb.deinit_ssi_src &&
+		    pcminfo->routeinfo->pcb.deinit_src) {
+			DBG_MSG("post:src->ssi\n");
+			/* stop src */
+			pcminfo->routeinfo->pcb.deinit_src();
+			/* stop ssi */
+			pcminfo->routeinfo->pcb.deinit_ssi_src();
+			/* stop dma */
+			scu_audma_stop(ss);
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+
+	} else { /* capture */
+		/* ssi */
+		if (pcminfo->routeinfo->ccb.deinit_ssi) {
+			DBG_MSG("post:ssi\n");
+			/* stop ssi */
+			pcminfo->routeinfo->ccb.deinit_ssi();
+			/* stop dma */
+			scu_audma_stop(ss);
+		}
+
+		/* ssi via src */
+		if (pcminfo->routeinfo->ccb.deinit_ssi_src &&
+		    pcminfo->routeinfo->ccb.deinit_src) {
+			DBG_MSG("post:src->ssi\n");
+			/* stop src */
+			pcminfo->routeinfo->ccb.deinit_src();
+			/* stop ssi */
+			pcminfo->routeinfo->ccb.deinit_ssi_src();
+			/* stop dma */
+			scu_audma_stop(ss);
+		}
+
+		/* ssi via src/dvc */
+		/* not implement */
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dma_do_work(struct work_struct *work)
+{
+	struct scu_pcm_info *pcminfo =
+			container_of(work, struct scu_pcm_info, work);
+	struct snd_pcm_substream *ss = pcminfo->ss;
+
+	FNC_ENTRY
+	/* start pcm process */
+	scu_pcm_start(ss, pcminfo->flag_first);
+	if (pcminfo->flag_first == 1)
+		pcminfo->flag_first = 0;
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_audio_start(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int ret = 0;
+
+	FNC_ENTRY
+	/* dma channel request */
+	ret = scu_dmae_request(ss);
+	if (ret < 0) {
+		pr_info("scu_dmae_request faild\n");
+		FNC_EXIT
+		return ret;
+	}
+
+	/* DMA control */
+	pcminfo->flag_start = 1;
+	/* PCM 1st process */
+	pcminfo->flag_first = 1;
+
+	schedule_work(&pcminfo->work);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audio_stop(struct snd_pcm_substream *ss)
+{
+	int ret = 0;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+	/* stop dma */
+	pcminfo->flag_start = 0;
+
+	/* stop pcm process */
+	scu_pcm_stop(ss);
+
+	/* dma channel release */
+	ret = scu_dmae_release(ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct scu_pcm_info *scu_pcm_new_stream(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+	int i;
+
+	FNC_ENTRY
+	/* allocate scu_pcm_info structure */
+	pcminfo = kzalloc(sizeof(struct scu_pcm_info), GFP_KERNEL);
+	if (!pcminfo)
+		return pcminfo;
+
+	/* initialize rcar_pcm_info structure */
+	pcminfo->period      = 0;
+	pcminfo->tran_period = 0;
+	pcminfo->routeinfo   = scu_get_route_info();
+	pcminfo->ss          = ss;
+	for (i = 0; i < SHDMA_SLAVE_PCM_MAX; i++)
+		pcminfo->de_chan[i] = NULL;
+
+	spin_lock_init(&pcminfo->pcm_lock);
+
+	INIT_WORK(&pcminfo->work, scu_dma_do_work);
+	FNC_EXIT
+	return pcminfo;
+}
+
+static void scu_pcm_free_stream(struct snd_pcm_runtime *runtime)
+{
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	FNC_ENTRY
+
+	/* post process */
+	cancel_work_sync(&pcminfo->work);
+	kfree(runtime->private_data);	/* free pcminfo structure */
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+	pcminfo = scu_pcm_new_stream(ss);
+	if (pcminfo == NULL)
+		return -ENOMEM;
+
+	ret = scu_check_route(dir, pcminfo->routeinfo);
+	if (ret < 0)
+		return ret;
+
+	ss->runtime->private_data = pcminfo;
+	ss->runtime->private_free = scu_pcm_free_stream;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_close(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_hw_params(struct snd_pcm_substream *ss,
+			     struct snd_pcm_hw_params *hw_params)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+	ret = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_malloc_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+	ret = snd_pcm_lib_free_pages(ss);
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_free_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	spin_lock(&pcminfo->pcm_lock);
+
+	FNC_ENTRY
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ret = scu_audio_start(ss);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ret = scu_audio_stop(ss);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&pcminfo->pcm_lock);
+
+	FNC_EXIT
+	return ret;
+}
+
+static snd_pcm_uframes_t scu_pcm_pointer_dma(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	snd_pcm_uframes_t position = 0;
+
+	position = runtime->period_size *
+			(pcminfo->tran_period & (SCU_PERIODS_MAX - 1));
+
+	DBG_MSG("\tposition = %d\n", (u32)position);
+
+	return position;
+}
+
+static int scu_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_card *card = rtd->card->snd_card;
+
+	FNC_ENTRY
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &dma_mask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = snd_pcm_lib_preallocate_pages_for_all(
+		rtd->pcm,
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
+		SCU_BUFFER_BYTES_MAX, SCU_BUFFER_BYTES_MAX);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_pcm_free(struct snd_pcm *pcm)
+{
+	FNC_ENTRY
+
+	/* free dma buffer */
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+
+	FNC_EXIT
+}
+
+static struct snd_pcm_ops scu_pcm_ops = {
+	.open		= scu_pcm_open,
+	.close		= scu_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= scu_pcm_hw_params,
+	.hw_free	= scu_pcm_hw_free,
+	.prepare	= scu_pcm_prepare,
+	.trigger	= scu_pcm_trigger,
+	.pointer	= scu_pcm_pointer_dma,
+};
+
+struct snd_soc_platform_driver scu_platform = {
+	.ops		= &scu_pcm_ops,
+	.pcm_new	= scu_pcm_new,
+	.pcm_free	= scu_pcm_free,
+};
+EXPORT_SYMBOL_GPL(scu_platform);
-- 
1.7.10.4

