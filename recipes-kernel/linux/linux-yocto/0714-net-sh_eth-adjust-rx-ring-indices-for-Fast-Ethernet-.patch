From 8e32003b9ff0f2f0ccaf1505256807b71780a74b Mon Sep 17 00:00:00 2001
From: Teppei Kamijou <teppei.kamijou.yb@renesas.com>
Date: Wed, 13 Jun 2012 04:39:14 +0000
Subject: [PATCH 0714/1083] net: sh_eth: adjust rx ring indices for Fast
 Ethernet when restarting rx

Redmine: N/A

Symptom:
--------

When using Receiving method control register with an initial setting
(RMCR.RNC=0 or CXR11.RR=0), the E-DMAC writes the receive status to
the descriptor upon completion of reception of one frame, and clears
the RR bit in EDRRR to 0.  In short, it stops receiving every frame.

With such receiving mode, and with this commit applied:

|commit 79fba9f51755c704c0a7d7b7f0df10874dc0a744
|Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
|Date:   Mon May 28 23:07:55 2012 +0000
|
|    net: sh_eth: fix the rxdesc pointer when rx descriptor empty happens
|
|    When Receive Descriptor Empty happens, rxdesc pointer of the driver
|    and actual next descriptor of the controller may be mismatch.
|    This patch fixes it.
|
|    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
|    Signed-off-by: David S. Miller <davem@davemloft.net>

we failed to mount root filesystem over NFS like this:

	PHY: sh-eth-0:03 - Link is Up - 100/Full
	VFS: Mounted root (nfs filesystem) on device 0:12.
	Freeing init memory: 116K
	nfs: server 192.168.1.1 not responding, still trying
	nfs: server 192.168.1.1 OK
	nfs: server 192.168.1.1 not responding, still trying
	nfs: server 192.168.1.1 OK

There is something wrong with data reception.

This is observed on a Fast Ethernet MAC equipped machine, but not on
a Gigabit Ethernet MAC equipped machine (R-Mobile A1, R8A7740).

Details:
--------

Making a comparison on the register dump between R-Mobile A1 (GbE) and
R-Home S1 (Fast Ethernet), we've found that RDFAR (Receive Descriptor
Fetch Address Register) values are different, off by one.

We took a closer look at the hardware manuals and IP specificaions of
Fast/Gigabit Ethernet MAC and companion DMACs, but can't tell what is
the right behavior of RDFAR.

Anyway, this fixes the issue with Fast Ethernet MAC.

Reported-by: Takamitsu Honda <takamitsu.honda.pv@renesas.com>
Signed-off-by: Teppei Kamijou <teppei.kamijou.yb@renesas.com>
Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi.px@renesas.com>
Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/net/ethernet/renesas/sh_eth.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index c64e290..c5432f7 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -1182,10 +1182,15 @@ static int sh_eth_rx(struct net_device *ndev, u32 intr_status)
 	/* If we don't need to check status, don't. -KDU */
 	if (!(sh_eth_read(ndev, EDRRR) & EDRRR_R)) {
 		/* fix the values for the next receiving if RDE is set */
-		if (intr_status & EESR_RDE)
+		if (intr_status & EESR_RDE) {
 			mdp->cur_rx = mdp->dirty_rx =
 				(sh_eth_read(ndev, RDFAR) -
 				 sh_eth_read(ndev, RDLAR)) >> 4;
+			if (!sh_eth_is_gether(mdp)) {
+				mdp->cur_rx++;
+				mdp->dirty_rx++;
+			}
+		}
 		sh_eth_write(ndev, EDRRR_R, EDRRR);
 	}
 
-- 
1.8.3.2

