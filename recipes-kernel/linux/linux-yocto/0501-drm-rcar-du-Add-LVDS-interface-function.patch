From 497c2bb5aaa145b2426528506091af5c2400552d Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 17 Jun 2013 10:45:13 +0900
Subject: [PATCH 0501/1083] drm: rcar-du: Add LVDS interface function

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
(cherry picked from commit 691db996030ad6f3f5392dd697a58df0ef4b74f5)

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c | 116 +++++++++++++++++++++++++++++++++
 drivers/gpu/drm/rcar-du/rcar_du_drv.c  |  89 +++++++++++++++++++++++++
 drivers/gpu/drm/rcar-du/rcar_du_drv.h  |   5 ++
 drivers/gpu/drm/rcar-du/rcar_du_regs.h |  19 ++++++
 4 files changed, 229 insertions(+)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index 01e9d24..dd043df 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -29,6 +29,7 @@
 #include "rcar_du_vga.h"
 
 #define to_rcar_crtc(c)	container_of(c, struct rcar_du_crtc, crtc)
+#define WORK_AROUND
 
 static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)
 {
@@ -69,6 +70,118 @@ static void rcar_du_crtc_clr_set(struct rcar_du_crtc *rcrtc, u32 reg,
 	rcar_du_write(rcdu, rcrtc->mmio_offset + reg, (value & ~clr) | set);
 }
 
+static inline u32 rcar_du_lvds0_read(struct rcar_du_device *rcdu, u32 reg)
+{
+	return ioread32(rcdu->lvds0_mmio + reg);
+}
+
+static inline void rcar_du_lvds0_write(struct rcar_du_device *rcdu,
+				 u32 reg, u32 data)
+{
+	iowrite32(data, rcdu->lvds0_mmio + reg);
+}
+
+static inline u32 rcar_du_lvds1_read(struct rcar_du_device *rcdu, u32 reg)
+{
+	return ioread32(rcdu->lvds1_mmio + reg);
+}
+
+static inline void rcar_du_lvds1_write(struct rcar_du_device *rcdu,
+				 u32 reg, u32 data)
+{
+	iowrite32(data, rcdu->lvds1_mmio + reg);
+}
+
+static void rcar_du_lvds0_setting(struct rcar_du_device *rcdu)
+{
+	u32 set_clock;
+
+	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
+
+	/* 3. PLL, CTR, CH register setting */
+	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000577B);
+	else if ((set_clock > (38 * 1000 * 1000))
+		 && (set_clock <= (60 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000569A);
+	else if ((set_clock > (61 * 1000 * 1000))
+		 && (set_clock <= (121 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000522C);
+	else if ((set_clock > (121 * 1000 * 1000))
+		 && (set_clock <= (150 * 1000 * 1000)))
+		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x000001C7);
+	else
+		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
+
+#ifdef WORK_AROUND /* work around */
+	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00002020); /* work around */
+#else
+	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00000000);
+#endif
+
+	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000005));
+
+	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
+	rcar_du_lvds0_write(rcdu, LVDCR1,
+		 (rcar_du_lvds0_read(rcdu, LVDCR1) | 0x000003FF));
+
+	/* 6. Set LVDCR0.PLLON=1 PLL ON */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000010));
+	udelay(100); /* wait for 100us */
+
+	/* 7. Set LVDCR.LVRES=1 */
+	rcar_du_lvds0_write(rcdu, LVDCR0,
+		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000002));
+}
+
+static void rcar_du_lvds1_setting(struct rcar_du_device *rcdu)
+{
+	u32 set_clock;
+
+	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
+
+	/* 3. PLL, CTR, CH register setting */
+	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000577B);
+	else if ((set_clock > (38 * 1000 * 1000))
+		 && (set_clock <= (60 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000569A);
+	else if ((set_clock > (61 * 1000 * 1000))
+		 && (set_clock <= (121 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000522C);
+	else if ((set_clock > (121 * 1000 * 1000))
+		 && (set_clock <= (150 * 1000 * 1000)))
+		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x000001C7);
+	else
+		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
+
+#ifdef WORK_AROUND /* work around */
+	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00002020); /* work around */
+#else
+	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00000000);
+#endif
+
+	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000005));
+
+	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
+	rcar_du_lvds1_write(rcdu, LVDCR1,
+		 (rcar_du_lvds1_read(rcdu, LVDCR1) | 0x000003FF));
+
+	/* 6. Set LVDCR0.PLLON=1 PLL ON */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000010));
+	udelay(100); /* wait for 100us */
+
+	/* 7. Set LVDCR.LVRES=1 */
+	rcar_du_lvds1_write(rcdu, LVDCR0,
+		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000002));
+}
+
 static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 {
 	struct drm_crtc *crtc = &rcrtc->crtc;
@@ -285,6 +398,9 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 
 	rcar_du_start_stop(rcdu, true);
 
+	rcar_du_lvds0_setting(rcdu);
+	rcar_du_lvds1_setting(rcdu);
+
 	rcrtc->started = true;
 }
 
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index 813d48c..e457598 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -55,11 +55,24 @@ int rcar_du_get(struct rcar_du_device *rcdu)
 	if (ret < 0)
 		return ret;
 
+	ret = clk_enable(rcdu->clock_du1);
+	if (ret < 0)
+		return ret;
+
+	ret = clk_enable(rcdu->clock_lvds0);
+	if (ret < 0)
+		return ret;
+
+	ret = clk_enable(rcdu->clock_lvds1);
+	if (ret < 0)
+		return ret;
+
 	/* Enable extended features */
 	rcar_du_write(rcdu, DEFR, DEFR_CODE | DEFR_DEFE);
 	rcar_du_write(rcdu, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);
 	rcar_du_write(rcdu, DEFR3, DEFR3_CODE | DEFR3_DEFE3);
 	rcar_du_write(rcdu, DEFR4, DEFR4_CODE);
+	rcar_du_write(rcdu, DEFR5, DEFR5_CODE | DEFR5_DEFE5);
 
 	/* Use DS1PR and DS2PR to configure planes priorities and connects the
 	 * superposition 0 to DU0 pins. DU1 pins will be configured dynamically.
@@ -84,6 +97,9 @@ void rcar_du_put(struct rcar_du_device *rcdu)
 		return;
 
 	clk_disable_unprepare(rcdu->clock);
+	clk_disable(rcdu->clock_du1);
+	clk_disable(rcdu->clock_lvds0);
+	clk_disable(rcdu->clock_lvds1);
 }
 
 /* -----------------------------------------------------------------------------
@@ -113,7 +129,11 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 	struct rcar_du_platform_data *pdata = pdev->dev.platform_data;
 	struct rcar_du_device *rcdu;
 	struct resource *ioarea;
+	struct resource *lvds0_ioarea;
+	struct resource *lvds1_ioarea;
 	struct resource *mem;
+	struct resource *lvds0_mem;
+	struct resource *lvds1_mem;
 	int ret;
 
 	if (pdata == NULL) {
@@ -156,6 +176,54 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		goto done;
 	}
 
+	/* LVDS0 */
+	lvds0_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (lvds0_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory lvds0 resource\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	lvds0_ioarea = devm_request_mem_region(&pdev->dev, lvds0_mem->start,
+					 resource_size(lvds0_mem), pdev->name);
+	if (lvds0_ioarea == NULL) {
+		dev_err(&pdev->dev, "failed to request memory lvds0 region\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	rcdu->lvds0_mmio = devm_ioremap_nocache(&pdev->dev, lvds0_ioarea->start,
+					  resource_size(lvds0_ioarea));
+	if (rcdu->lvds0_mmio == NULL) {
+		dev_err(&pdev->dev, "failed to remap memory lvds0 resource\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* LVDS1 */
+	lvds1_mem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (lvds1_mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory lvds1 resource\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	lvds1_ioarea = devm_request_mem_region(&pdev->dev, lvds1_mem->start,
+					 resource_size(lvds1_mem), pdev->name);
+	if (lvds1_ioarea == NULL) {
+		dev_err(&pdev->dev, "failed to request memory lvds1 region\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	rcdu->lvds1_mmio = devm_ioremap_nocache(&pdev->dev, lvds1_ioarea->start,
+					  resource_size(lvds1_ioarea));
+	if (rcdu->lvds1_mmio == NULL) {
+		dev_err(&pdev->dev, "failed to remap memory lvds1 resource\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
 	rcdu->clock = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(rcdu->clock)) {
 		dev_err(&pdev->dev, "failed to get clock\n");
@@ -163,6 +231,27 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		goto done;
 	}
 
+	rcdu->clock_du1 = clk_get(NULL, "rcar-du.1");
+	if (IS_ERR(rcdu->clock_du1)) {
+		dev_err(&pdev->dev, "failed to get rcar-du.1 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
+	rcdu->clock_lvds0 = clk_get(NULL, "lvds.0");
+	if (IS_ERR(rcdu->clock_lvds0)) {
+		dev_err(&pdev->dev, "failed to get lvds.0 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
+	rcdu->clock_lvds1 = clk_get(NULL, "lvds.1");
+	if (IS_ERR(rcdu->clock_lvds1)) {
+		dev_err(&pdev->dev, "failed to get lvds.1 clock\n");
+		ret = -ENOENT;
+		goto done;
+	}
+
 	/* DRM/KMS objects */
 	ret = rcar_du_modeset_init(rcdu);
 	if (ret < 0) {
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index e761b27..f0d6254 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -31,7 +31,12 @@ struct rcar_du_device {
 	const struct rcar_du_platform_data *pdata;
 
 	void __iomem *mmio;
+	void __iomem *lvds0_mmio;
+	void __iomem *lvds1_mmio;
 	struct clk *clock;
+	struct clk *clock_du1;
+	struct clk *clock_lvds0;
+	struct clk *clock_lvds1;
 	unsigned int use_count;
 
 	struct drm_device *ddev;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_regs.h b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
index 69f21f1..5703744 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
@@ -204,6 +204,14 @@
 #define DEFR6_MLOS1		(1 << 2)
 #define DEFR6_DEFAULT		(DEFR6_CODE | DEFR6_TCNE2)
 
+#define DEFR8			0x20020
+#define DEFR8_CODE		(0x7790 << 16)
+#define DEFR8_VSCS		(1 << 6)
+#define DEFR8_DRGBS_DU2		(2 << 4)
+#define DEFR8_DRGBS_DU1		(1 << 4)
+#define DEFR8_DRGBS_DU0		(0 << 4)
+#define DEFR8_DEFE8		(1 << 0)
+
 /* -----------------------------------------------------------------------------
  * Display Timing Generation Registers
  */
@@ -442,4 +450,15 @@
 #define GCBCR			0x11098
 #define BCBCR			0x1109c
 
+/* -----------------------------------------------------------------------------
+ * LVDS registers
+ */
+
+#define LVDCR0		0x0000
+#define LVDCR1		0x0004
+#define LVDPLLCR	0x0008
+#define LVDCTRCR	0x000C
+#define LVDCHCR		0x0010
+
+
 #endif /* __RCAR_DU_REGS_H__ */
-- 
1.8.3.2

