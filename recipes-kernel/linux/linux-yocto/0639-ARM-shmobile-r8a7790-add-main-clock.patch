From 979cca1345e51d5e61519054475dc87fa2018804 Mon Sep 17 00:00:00 2001
From: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date: Fri, 12 Apr 2013 00:42:22 -0700
Subject: [PATCH 0639/1083] ARM: shmobile: r8a7790: add main clock

Almost all clock needs main clock which is basis clock on r8a7790.
This patch adds it, and, set its parent/ratio via MD pin.
It is based on v0.05 datasheet

Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
(cherry picked from commit 323862e615b8559fdbfd2096b383ca48c7e139c0)

Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
(cherry picked from commit 96251084226455947b6ccd758e846a14ec8b10f5)

Conflicts:
	arch/arm/mach-shmobile/clock-r8a7790.c

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 arch/arm/mach-shmobile/clock-r8a7790.c | 301 ++++++++++++++++++++-------------
 1 file changed, 184 insertions(+), 117 deletions(-)

diff --git a/arch/arm/mach-shmobile/clock-r8a7790.c b/arch/arm/mach-shmobile/clock-r8a7790.c
index 8235a17..a442ebb 100644
--- a/arch/arm/mach-shmobile/clock-r8a7790.c
+++ b/arch/arm/mach-shmobile/clock-r8a7790.c
@@ -11,7 +11,7 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
@@ -23,8 +23,28 @@
 #include <linux/kernel.h>
 #include <linux/sh_clk.h>
 #include <linux/clkdev.h>
+#include <mach/clock.h>
 #include <mach/common.h>
 
+/*
+ *   MD		EXTAL		PLL0	PLL1	PLL3
+ * 14 13 19	(MHz)		*1	*1
+ *---------------------------------------------------
+ * 0  0  0	15 x 1		x172/2	x208/2	x106
+ * 0  0  1	15 x 1		x172/2	x208/2	x88
+ * 0  1  0	20 x 1		x130/2	x156/2	x80
+ * 0  1  1	20 x 1		x130/2	x156/2	x66
+ * 1  0  0	26 / 2		x200/2	x240/2	x122
+ * 1  0  1	26 / 2		x200/2	x240/2	x102
+ * 1  1  0	30 / 2		x172/2	x208/2	x106
+ * 1  1  1	30 / 2		x172/2	x208/2	x88
+ *
+ * *1 :	Table 7.6 indicates VCO ouput (PLLx = VCO/2)
+ *	see "p1 / 2" on R8A7790_CLOCK_ROOT() below
+ */
+
+#define MD(nr)	(1 << nr)
+
 #define CPG_BASE 0xe6150000
 #define CPG_LEN 0x1000
 
@@ -36,64 +56,69 @@
 #define SMSTPCR9	0xE6150994
 #define SMSTPCR10	0xE6150998
 
+#define MODEMR		0xE6160060
 #define SDCKCR		0xE6150074
 #define SD2CKCR		0xE6150078
 #define SD3CKCR		0xE615007C
 
 static struct clk_mapping cpg_mapping = {
-	.phys	= CPG_BASE,
-	.len	= CPG_LEN,
-};
-
-static unsigned long d12_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 12;
-}
-
-static unsigned long d4_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 4;
-}
-
-static unsigned long d3_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 3;
-}
-
-static unsigned long d2_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 2;
-}
-
-static struct sh_clk_ops d12_clk_ops = {
-	.recalc		= d12_recalc,
+	.phys   = CPG_BASE,
+	.len    = CPG_LEN,
 };
 
-static struct sh_clk_ops d4_clk_ops = {
-	.recalc		= d4_recalc,
+static struct clk extal_clk = {
+	/* .rate will be updated on r8a7790_clock_init() */
+	.mapping	= &cpg_mapping,
 };
 
-static struct sh_clk_ops d3_clk_ops = {
-	.recalc		= d3_recalc,
+static struct sh_clk_ops followparent_clk_ops = {
+	.recalc	= followparent_recalc,
 };
 
-static struct sh_clk_ops d2_clk_ops = {
-	.recalc		= d2_recalc,
+static struct clk main_clk = {
+	/* .parent will be set r8a73a4_clock_init */
+	.ops	= &followparent_clk_ops,
 };
 
-static struct clk extal_clk = {
-	.rate		= 30000000,
-	.mapping	= &cpg_mapping,
-};
+/*
+ * clock ratio of these clock will be updated
+ * on r8a7790_clock_init()
+ */
+SH_FIXED_RATIO_CLK_SET(pll1_clk,		main_clk,	1, 1);
+SH_FIXED_RATIO_CLK_SET(pll3_clk,		main_clk,	1, 1);
+SH_FIXED_RATIO_CLK_SET(lb_clk,			pll1_clk,	1, 1);
+SH_FIXED_RATIO_CLK_SET(qspi_clk,		pll1_clk,	1, 1);
+
+/* fixed ratio clock */
+SH_FIXED_RATIO_CLK_SET(extal_div2_clk,		extal_clk,	1, 2);
+SH_FIXED_RATIO_CLK_SET(cp_clk,			extal_clk,	1, 2);
+
+SH_FIXED_RATIO_CLK_SET(pll1_div2_clk,		pll1_clk,	1, 2);
+SH_FIXED_RATIO_CLK_SET(zg_clk,			pll1_clk,	1, 3);
+SH_FIXED_RATIO_CLK_SET(zx_clk,			pll1_clk,	1, 3);
+SH_FIXED_RATIO_CLK_SET(zs_clk,			pll1_clk,	1, 6);
+SH_FIXED_RATIO_CLK_SET(hp_clk,			pll1_clk,	1, 12);
+SH_FIXED_RATIO_CLK_SET(i_clk,			pll1_clk,	1, 2);
+SH_FIXED_RATIO_CLK_SET(b_clk,			pll1_clk,	1, 12);
+SH_FIXED_RATIO_CLK_SET(p_clk,			pll1_clk,	1, 24);
+SH_FIXED_RATIO_CLK_SET(cl_clk,			pll1_clk,	1, 48);
+SH_FIXED_RATIO_CLK_SET(m2_clk,			pll1_clk,	1, 8);
+SH_FIXED_RATIO_CLK_SET(imp_clk,			pll1_clk,	1, 4);
+SH_FIXED_RATIO_CLK_SET(rclk_clk,		pll1_clk,	1, (48 * 1024));
+SH_FIXED_RATIO_CLK_SET(oscclk_clk,		pll1_clk,	1, (12 * 1024));
+
+SH_FIXED_RATIO_CLK_SET(zb3_clk,			pll3_clk,	1, 4);
+SH_FIXED_RATIO_CLK_SET(zb3d2_clk,		pll3_clk,	1, 8);
+SH_FIXED_RATIO_CLK_SET(ddr_clk,			pll3_clk,	1, 8);
+SH_FIXED_RATIO_CLK_SET(mp_clk,			pll1_div2_clk,	1, 15);
 
-static struct clk pll1_clk = {
-	.rate		= 3120000000,
-	.mapping	= &cpg_mapping,
-};
+static unsigned long d4_recalc(struct clk *clk)
+{
+	return clk->parent->rate / 4;
+}
 
-static struct clk pll1_d2_clk = {
-	.ops		= &d2_clk_ops,
-	.parent		= &pll1_clk,
+static struct sh_clk_ops d4_clk_ops = {
+	.recalc		= d4_recalc,
 };
 
 static struct clk pll1_d4_clk = {
@@ -101,38 +126,31 @@ static struct clk pll1_d4_clk = {
 	.parent		= &pll1_clk,
 };
 
-static struct clk zg_clk = {
-	.ops		= &d3_clk_ops,
-	.parent		= &pll1_d2_clk,
-};
-
-static struct clk hp_clk = {
-	.ops		= &d12_clk_ops,
-	.parent		= &pll1_d2_clk,
-};
-
-static struct clk qspi_clk = {
-	.rate		= 97500000,
-};
-
-static struct clk mp_clk = {
-	.rate		= 52000000,
-	.mapping	= &cpg_mapping,
-};
-
-static struct clk cp_clk = {
-	.ops		= &d2_clk_ops,
-	.parent		= &extal_clk,
-};
-
 static struct clk *main_clks[] = {
 	&extal_clk,
+	&extal_div2_clk,
+	&main_clk,
 	&pll1_clk,
-	&pll1_d2_clk,
+	&pll1_div2_clk,
 	&pll1_d4_clk,
+	&pll3_clk,
+	&lb_clk,
+	&qspi_clk,
 	&zg_clk,
+	&zx_clk,
+	&zs_clk,
 	&hp_clk,
-	&qspi_clk,
+	&i_clk,
+	&b_clk,
+	&p_clk,
+	&cl_clk,
+	&m2_clk,
+	&imp_clk,
+	&rclk_clk,
+	&oscclk_clk,
+	&zb3_clk,
+	&zb3d2_clk,
+	&ddr_clk,
 	&mp_clk,
 	&cp_clk,
 };
@@ -166,8 +184,8 @@ static struct clk_div4_table div4_table = {
 }
 
 static struct clk sd01_clks[SD01_NR] = {
-	[SD0] = SD_DIV(&pll1_d2_clk, SDCKCR, 4, 0),
-	[SD1] = SD_DIV(&pll1_d2_clk, SDCKCR, 0, 0),
+	[SD0] = SD_DIV(&pll1_div2_clk, SDCKCR, 4, 0),
+	[SD1] = SD_DIV(&pll1_div2_clk, SDCKCR, 0, 0),
 };
 
 static struct clk sd23_clks[SD23_NR] = {
@@ -175,37 +193,40 @@ static struct clk sd23_clks[SD23_NR] = {
 	[SD3] = SH_CLK_DIV6(&pll1_d4_clk, SD3CKCR, 0),
 };
 
+/* MSTP */
 enum {
-	MSTP112,
-	MSTP216, MSTP207, MSTP206, MSTP204, MSTP203, MSTP202,
-	MSTP726, MSTP725, MSTP724, MSTP723, MSTP721, MSTP720, MSTP704, MSTP703,
+	MSTP726, MSTP725, MSTP724, MSTP723, MSTP721, MSTP720,
 	MSTP314, MSTP313, MSTP312, MSTP311,
-	MSTP931, MSTP930, MSTP929, MSTP928, MSTP922, MSTP917,
+	MSTP216, MSTP207, MSTP206, MSTP204, MSTP203, MSTP202,
+	MSTP112,
 	MSTP502, MSTP501,
-	MSTP1031, MSTP1030, MSTP1019, MSTP1018, MSTP1017, MSTP1015, \
-	MSTP1014, MSTP1005,
-	MSTP_NR };
+	MSTP704, MSTP703, 
+	MSTP917, MSTP931, MSTP930, MSTP929, MSTP928, MSTP922,
+	MSTP1031, MSTP1030, MSTP1019, MSTP1018, MSTP1017, MSTP1015, MSTP1014,
+	MSTP1005,
+	MSTP_NR
+};
 
 static struct clk mstp_clks[MSTP_NR] = {
+	[MSTP726] = SH_CLK_MSTP32(&zx_clk, SMSTPCR7, 26, 0), /* LVDS0 */
+	[MSTP725] = SH_CLK_MSTP32(&zx_clk, SMSTPCR7, 25, 0), /* LVDS1 */
+	[MSTP724] = SH_CLK_MSTP32(&zx_clk, SMSTPCR7, 24, 0), /* DU0 */
+	[MSTP723] = SH_CLK_MSTP32(&zx_clk, SMSTPCR7, 23, 0), /* DU1 */
+	[MSTP721] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 21, 0), /* SCIF0 */
+	[MSTP720] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 20, 0), /* SCIF1 */
+	[MSTP314] = SH_CLK_MSTP32(&sd01_clks[SD0], SMSTPCR3, 14, 0), /* SDHI0 */
+	[MSTP313] = SH_CLK_MSTP32(&sd01_clks[SD1], SMSTPCR3, 13, 0), /* SDHI1 */
+	[MSTP312] = SH_CLK_MSTP32(&sd23_clks[SD2], SMSTPCR3, 12, 0), /* SDHI2 */
+	[MSTP311] = SH_CLK_MSTP32(&sd23_clks[SD3], SMSTPCR3, 11, 0), /* SDHI3 */
+	[MSTP216] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 16, 0), /* SCIFB2 */
+	[MSTP207] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 7, 0), /* SCIFB1 */
+	[MSTP206] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 6, 0), /* SCIFB0 */
+	[MSTP204] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 4, 0), /* SCIFA0 */
+	[MSTP203] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 3, 0), /* SCIFA1 */
+	[MSTP202] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 2, 0), /* SCIFA2 */
 	[MSTP112] = SH_CLK_MSTP32(&zg_clk, SMSTPCR1, 12, 0),
-	[MSTP216] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 16, 0),
-	[MSTP207] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 7, 0),
-	[MSTP206] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 6, 0),
-	[MSTP204] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 4, 0),
-	[MSTP203] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 3, 0),
-	[MSTP202] = SH_CLK_MSTP32(&mp_clk, SMSTPCR2, 2, 0),
-	[MSTP726] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 26, 0),
-	[MSTP725] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 25, 0),
-	[MSTP314] = SH_CLK_MSTP32(&sd01_clks[SD0], SMSTPCR3, 14, 0),
-	[MSTP313] = SH_CLK_MSTP32(&sd01_clks[SD1], SMSTPCR3, 13, 0),
-	[MSTP312] = SH_CLK_MSTP32(&sd23_clks[SD2], SMSTPCR3, 12, 0),
-	[MSTP311] = SH_CLK_MSTP32(&sd23_clks[SD3], SMSTPCR3, 11, 0),
 	[MSTP502] = SH_CLK_MSTP32(&hp_clk, SMSTPCR5, 2, 0),
 	[MSTP501] = SH_CLK_MSTP32(&hp_clk, SMSTPCR5, 1, 0),
-	[MSTP724] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 24, 0),
-	[MSTP723] = SH_CLK_MSTP32(&zg_clk, SMSTPCR7, 23, 0),
-	[MSTP721] = SH_CLK_MSTP32(&cp_clk, SMSTPCR7, 21, 0),
-	[MSTP720] = SH_CLK_MSTP32(&cp_clk, SMSTPCR7, 20, 0),
 	[MSTP704] = SH_CLK_MSTP32(&mp_clk, SMSTPCR7, 04, 0),
 	[MSTP703] = SH_CLK_MSTP32(&mp_clk, SMSTPCR7, 03, 0),
 	[MSTP917] = SH_CLK_MSTP32(&qspi_clk, SMSTPCR9, 17, 0),
@@ -225,29 +246,43 @@ static struct clk mstp_clks[MSTP_NR] = {
 };
 
 static struct clk_lookup lookups[] = {
+
 	/* main clocks */
-	CLKDEV_CON_ID("extal_clk", &extal_clk),
-	CLKDEV_CON_ID("pll1_clk", &pll1_clk),
-	CLKDEV_CON_ID("pll1_div2_clk", &pll1_d2_clk),
-	CLKDEV_CON_ID("pll1_div4_clk", &pll1_d4_clk),
-	CLKDEV_CON_ID("zg_clk", &zg_clk),
-	CLKDEV_CON_ID("hp_clk", &hp_clk),
-	CLKDEV_CON_ID("mp_clk", &mp_clk),
-	CLKDEV_CON_ID("cp_clk", &cp_clk),
+	CLKDEV_CON_ID("extal",		&extal_clk),
+	CLKDEV_CON_ID("extal_div2",	&extal_div2_clk),
+	CLKDEV_CON_ID("main",		&main_clk),
+	CLKDEV_CON_ID("pll1",		&pll1_clk),
+	CLKDEV_CON_ID("pll1_div2",	&pll1_div2_clk),
+	CLKDEV_CON_ID("pll3",		&pll3_clk),
+	CLKDEV_CON_ID("zg",		&zg_clk),
+	CLKDEV_CON_ID("zx",		&zx_clk),
+	CLKDEV_CON_ID("zs",		&zs_clk),
+	CLKDEV_CON_ID("hp",		&hp_clk),
+	CLKDEV_CON_ID("i",		&i_clk),
+	CLKDEV_CON_ID("b",		&b_clk),
+	CLKDEV_CON_ID("lb",		&lb_clk),
+	CLKDEV_CON_ID("p",		&p_clk),
+	CLKDEV_CON_ID("cl",		&cl_clk),
+	CLKDEV_CON_ID("m2",		&m2_clk),
+	CLKDEV_CON_ID("imp",		&imp_clk),
+	CLKDEV_CON_ID("rclk",		&rclk_clk),
+	CLKDEV_CON_ID("oscclk",		&oscclk_clk),
+	CLKDEV_CON_ID("zb3",		&zb3_clk),
+	CLKDEV_CON_ID("zb3d2",		&zb3d2_clk),
+	CLKDEV_CON_ID("ddr",		&ddr_clk),
+	CLKDEV_CON_ID("mp",		&mp_clk),
+	CLKDEV_CON_ID("qspi",		&qspi_clk),
+	CLKDEV_CON_ID("cp",		&cp_clk),
 	CLKDEV_CON_ID("peripheral_clk", &hp_clk),
 
+	/* MSTP */
 	CLKDEV_DEV_ID("pvrsrvkm", &mstp_clks[MSTP112]),
-	CLKDEV_CON_ID("g6400", &mstp_clks[MSTP112]),
 	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP314]),
 	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[MSTP313]),
 	CLKDEV_DEV_ID("sh_mobile_sdhi.2", &mstp_clks[MSTP312]),
 	CLKDEV_DEV_ID("sh_mobile_sdhi.3", &mstp_clks[MSTP311]),
 	CLKDEV_CON_ID("audmac_lo", &mstp_clks[MSTP502]),
 	CLKDEV_CON_ID("audmac_up", &mstp_clks[MSTP501]),
-	CLKDEV_DEV_ID("rcar-du.0", &mstp_clks[MSTP724]),
-	CLKDEV_CON_ID("rcar-du.1", &mstp_clks[MSTP723]),
-	CLKDEV_CON_ID("lvds.0", &mstp_clks[MSTP726]),
-	CLKDEV_CON_ID("lvds.1", &mstp_clks[MSTP725]),
 	CLKDEV_DEV_ID("sh-sci.0", &mstp_clks[MSTP204]),
 	CLKDEV_DEV_ID("sh-sci.1", &mstp_clks[MSTP203]),
 	CLKDEV_DEV_ID("sh-sci.2", &mstp_clks[MSTP206]),
@@ -263,15 +298,6 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_DEV_ID("i2c-rcar.1", &mstp_clks[MSTP930]),
 	CLKDEV_DEV_ID("i2c-rcar.2", &mstp_clks[MSTP929]),
 	CLKDEV_DEV_ID("i2c-rcar.3", &mstp_clks[MSTP928]),
-	CLKDEV_DEV_ID("adg", &mstp_clks[MSTP922]),
-	CLKDEV_DEV_ID("src0", &mstp_clks[MSTP1031]),
-	CLKDEV_DEV_ID("src1", &mstp_clks[MSTP1030]),
-	CLKDEV_DEV_ID("dvc0", &mstp_clks[MSTP1019]),
-	CLKDEV_DEV_ID("dvc1", &mstp_clks[MSTP1018]),
-	CLKDEV_DEV_ID("scu-pcm-audio.0", &mstp_clks[MSTP1017]),
-	CLKDEV_DEV_ID("ssi0", &mstp_clks[MSTP1015]),
-	CLKDEV_DEV_ID("ssi1", &mstp_clks[MSTP1014]),
-	CLKDEV_DEV_ID("ssi", &mstp_clks[MSTP1005]),
 	CLKDEV_CON_ID("adg", &mstp_clks[MSTP922]),
 	CLKDEV_CON_ID("src0", &mstp_clks[MSTP1031]),
 	CLKDEV_CON_ID("src1", &mstp_clks[MSTP1030]),
@@ -296,10 +322,51 @@ static void __init r8a7790_rgx_control_init(void)
 	iounmap(cpgp);
 }
 
+#define R8A7790_CLOCK_ROOT(e, m, p0, p1, p30, p31)		\
+	extal_clk.rate	= e * 1000 * 1000;			\
+	main_clk.parent	= m;					\
+	SH_CLK_SET_RATIO(&pll1_clk_ratio, p1 / 2, 1);		\
+	if (mode & MD(19))					\
+		SH_CLK_SET_RATIO(&pll3_clk_ratio, p31, 1);	\
+	else							\
+		SH_CLK_SET_RATIO(&pll3_clk_ratio, p30, 1)
+
+
 void __init r8a7790_clock_init(void)
 {
+	void __iomem *modemr = ioremap_nocache(MODEMR, PAGE_SIZE);
+	u32 mode;
 	int k, ret = 0;
 
+	BUG_ON(!modemr);
+	mode = ioread32(modemr);
+	iounmap(modemr);
+
+	switch (mode & (MD(14) | MD(13))) {
+	case 0:
+		R8A7790_CLOCK_ROOT(15, &extal_clk, 172, 208, 106, 88);
+		break;
+	case MD(13):
+		R8A7790_CLOCK_ROOT(20, &extal_clk, 130, 156, 80, 66);
+		break;
+	case MD(14):
+		R8A7790_CLOCK_ROOT(26, &extal_div2_clk, 200, 240, 122, 102);
+		break;
+	case MD(13) | MD(14):
+		R8A7790_CLOCK_ROOT(30, &extal_div2_clk, 172, 208, 106, 88);
+		break;
+	}
+
+	if (mode & (MD(18)))
+		SH_CLK_SET_RATIO(&lb_clk_ratio, 1, 36);
+	else
+		SH_CLK_SET_RATIO(&lb_clk_ratio, 1, 24);
+
+	if ((mode & (MD(3) | MD(2) | MD(1))) == MD(2))
+		SH_CLK_SET_RATIO(&qspi_clk_ratio, 1, 16);
+	else
+		SH_CLK_SET_RATIO(&qspi_clk_ratio, 1, 20);
+
 	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
 		ret = clk_register(main_clks[k]);
 
-- 
1.8.3.2

