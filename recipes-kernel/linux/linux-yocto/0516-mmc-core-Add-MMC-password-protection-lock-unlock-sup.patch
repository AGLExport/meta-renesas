From e59a8bdefa777e4378a8741900fe99143506a12a Mon Sep 17 00:00:00 2001
From: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
Date: Fri, 14 Jun 2013 15:27:03 +0900
Subject: [PATCH 0516/1083] mmc: core: Add MMC password protection
 (lock/unlock) support

Add the lock/unlock function using Key Retention Service.
This function supports the following items by sysfs interface.
 - password assign
 - password change
 - password remove
 - unlock
 - force erase

Signed-off-by: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
(cherry picked from commit 0085c59728ac6eb8c5be1e9796481d48e0ed4362)

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/mmc/core/Kconfig   |  14 ++++
 drivers/mmc/core/Makefile  |   1 +
 drivers/mmc/core/bus.c     |  12 +++
 drivers/mmc/core/core.c    |   8 ++
 drivers/mmc/core/lock.c    | 191 +++++++++++++++++++++++++++++++++++++++++++++
 drivers/mmc/core/lock.h    |  42 ++++++++++
 drivers/mmc/core/mmc.c     |  17 +++-
 drivers/mmc/core/mmc_ops.c | 118 ++++++++++++++++++++++++++++
 drivers/mmc/core/mmc_ops.h |   5 ++
 drivers/mmc/core/sd.c      |  56 ++++++++-----
 include/linux/mmc/card.h   |   3 +
 include/linux/mmc/mmc.h    |   8 ++
 12 files changed, 456 insertions(+), 19 deletions(-)
 create mode 100644 drivers/mmc/core/lock.c
 create mode 100644 drivers/mmc/core/lock.h

diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index ef10387..91f9bbb 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -27,3 +27,17 @@ config MMC_CLKGATE
 	  support handling this in order for it to be of any use.
 
 	  If unsure, say N.
+
+config MMC_PASSWORDS
+	boolean "MMC card lock/unlock passwords (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	select KEYS
+	help
+	  Say Y here to enable the use of passwords to lock and unlock
+	  MMC cards. This uses the access key retention support, using
+	  request_key to look up the key associated with each card.
+
+	  For example, if you have an MMC card that was locked using
+	  Symbian OS on your cell phone, you won't be able to read it
+	  on Linux without this support.
+
diff --git a/drivers/mmc/core/Makefile b/drivers/mmc/core/Makefile
index 38ed210..05f5e6c 100644
--- a/drivers/mmc/core/Makefile
+++ b/drivers/mmc/core/Makefile
@@ -10,3 +10,4 @@ mmc_core-y			:= core.o bus.o host.o \
 				   quirks.o slot-gpio.o
 
 mmc_core-$(CONFIG_DEBUG_FS)	+= debugfs.o
+mmc_core-$(CONFIG_MMC_PASSWORDS) += lock.o
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index c60cee9..5e8a791 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -24,6 +24,7 @@
 #include "core.h"
 #include "sdio_cis.h"
 #include "bus.h"
+#include "lock.h"
 
 #define to_mmc_driver(d)	container_of(d, struct mmc_driver, drv)
 
@@ -55,9 +56,20 @@ static struct device_attribute mmc_dev_attrs[] = {
  * This currently matches any MMC driver to any MMC card - drivers
  * themselves make the decision whether to drive this card in their
  * probe method.
+ *
+ * We also fail for all locked cards; drivers expect to be able to do block
+ * I/O still on probe(), which is not possible while the card is locked.
+ * Device probing must be triggered sometime later to make the card available
+ * to the block driver.
  */
 static int mmc_bus_match(struct device *dev, struct device_driver *drv)
 {
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	if (mmc_card_locked(card)) {
+		dev_dbg(&card->dev, "card is locked; binding is deferred\n");
+		return 0;
+	}
 	return 1;
 }
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1db77e7..bd58c6e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -40,6 +40,7 @@
 #include "mmc_ops.h"
 #include "sd_ops.h"
 #include "sdio_ops.h"
+#include "lock.h"
 
 static struct workqueue_struct *workqueue;
 
@@ -2450,8 +2451,14 @@ static int __init mmc_init(void)
 	if (ret)
 		goto unregister_host_class;
 
+	ret = mmc_register_key_type();
+	if (ret)
+		goto unregister_sdio;
+
 	return 0;
 
+unregister_sdio:
+	sdio_unregister_bus();
 unregister_host_class:
 	mmc_unregister_host_class();
 unregister_bus:
@@ -2464,6 +2471,7 @@ destroy_workqueue:
 
 static void __exit mmc_exit(void)
 {
+	mmc_unregister_key_type();
 	sdio_unregister_bus();
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
diff --git a/drivers/mmc/core/lock.c b/drivers/mmc/core/lock.c
new file mode 100644
index 0000000..580e31b1
--- /dev/null
+++ b/drivers/mmc/core/lock.c
@@ -0,0 +1,191 @@
+/*
+ * linux/drivers/mmc/core/lock.c
+ *
+ * Copyright 2006 Instituto Nokia de Tecnologia (INdT), All Rights Reserved.
+ * Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * MMC password key handling.
+ */
+
+#include <linux/device.h>
+#include <linux/key-type.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+
+#include "mmc_ops.h"
+#include "lock.h"
+
+#define MMC_KEYLEN_MAXBYTES 32
+
+static int mmc_key_instantiate(struct key *key, const void *data, size_t datalen)
+{
+	struct mmc_key_payload *mpayload;
+	int ret;
+
+	ret = -EINVAL;
+	if (datalen <= 0 || datalen > MMC_KEYLEN_MAXBYTES || !data) {
+		pr_debug("Invalid data\n");
+		goto error;
+	}
+
+	ret = key_payload_reserve(key, datalen);
+	if (ret < 0) {
+		pr_debug("ret = %d\n", ret);
+		goto error;
+	}
+
+	ret = -ENOMEM;
+	mpayload = kmalloc(sizeof(*mpayload) + datalen, GFP_KERNEL);
+	if (!mpayload) {
+		pr_debug("Unable to allocate mpayload structure\n");
+		goto error;
+	}
+	mpayload->datalen = datalen;
+	memcpy(mpayload->data, data, datalen);
+
+	rcu_assign_pointer(key->payload.data, mpayload);
+
+	/* ret = 0 if there is no error */
+	ret = 0;
+
+error:
+	return ret;
+}
+
+static int mmc_key_match(const struct key *key, const void *description)
+{
+	return strcmp(key->description, description) == 0;
+}
+
+/*
+ * dispose of the data dangling from the corpse of a mmc key
+ */
+static void mmc_key_destroy(struct key *key)
+{
+	struct mmc_key_payload *mpayload = key->payload.data;
+
+	kfree(mpayload);
+}
+
+static struct key_type mmc_key_type = {
+	.name = "mmc",
+	.def_datalen = MMC_KEYLEN_MAXBYTES,
+	.instantiate = mmc_key_instantiate,
+	.match = mmc_key_match,
+	.destroy = mmc_key_destroy,
+};
+
+int mmc_register_key_type(void)
+{
+	return register_key_type(&mmc_key_type);
+}
+
+void mmc_unregister_key_type(void)
+{
+	unregister_key_type(&mmc_key_type);
+}
+
+static ssize_t
+mmc_lockable_show(struct device *dev, struct device_attribute *att, char *buf)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+
+	return sprintf(buf, "%slocked\n", mmc_card_locked(card) ? "" : "un");
+}
+
+/*
+ * implement MMC password functions: force erase, remove password, change
+ * password, unlock card and assign password.
+ */
+static ssize_t
+mmc_lockable_store(struct device *dev, struct device_attribute *att,
+ const char *data, size_t len)
+{
+	struct mmc_card *card = dev_to_mmc_card(dev);
+	int ret;
+	struct key *mmc_key;
+
+	WARN_ON(!(mmc_card_mmc(card) || mmc_card_sd(card)));
+	WARN_ON(!(card->csd.cmdclass & CCC_LOCK_CARD));
+
+	if(!data)
+		return -EINVAL;
+	if((card->type != MMC_TYPE_MMC) && (card->type != MMC_TYPE_SD))
+		return -EINVAL;
+	if(!(card->csd.cmdclass & CCC_LOCK_CARD))
+		return -EINVAL;
+
+	mmc_claim_host(card->host);
+
+	ret = -EINVAL;
+	if (mmc_card_locked(card) && !strncmp(data, "erase", 5)) {
+		/* forced erase only works while card is locked */
+		mmc_lock_unlock(card, NULL, MMC_LOCK_MODE_ERASE);
+		ret = len;
+	} else if (!mmc_card_locked(card) && !strncmp(data, "remove", 6)) {
+		/* remove password only works while card is unlocked */
+		mmc_key = request_key(&mmc_key_type, "mmc:key", "remove");
+
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_CLR_PWD);
+			if (!ret)
+				ret = len;
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	} else if (!mmc_card_locked(card) && ((!strncmp(data, "assign", 6)) ||
+				(!strncmp(data, "change", 6)))) {
+		/* assign or change */
+		if(!(strncmp(data, "assign", 6)))
+			mmc_key = request_key(&mmc_key_type, "mmc:key", "assign");
+		else
+			mmc_key = request_key(&mmc_key_type, "mmc:key", "change");
+
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_SET_PWD);
+			if (!ret)
+				ret = len;
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	} else if (mmc_card_locked(card) && !strncmp(data, "unlock", 6)) {
+		/* unlock */
+		mmc_key = request_key(&mmc_key_type, "mmc:key", "unlock");
+		if (!IS_ERR(mmc_key)) {
+			ret = mmc_lock_unlock(card, mmc_key, MMC_LOCK_MODE_UNLOCK);
+			if (ret) {
+				dev_dbg(&card->dev, "Wrong password\n");
+				ret = -EINVAL;
+			}
+			else {
+				mmc_release_host(card->host);
+				device_release_driver(dev);
+				ret = device_attach(dev);
+				if(!ret)
+					return -EINVAL;
+				else
+					return len;
+			}
+		} else
+			dev_dbg(&card->dev,
+				"request_key returned error %ld\n",
+				PTR_ERR(mmc_key));
+	}
+
+	mmc_release_host(card->host);
+	return ret;
+}
+
+
+DEVICE_ATTR(lockable, S_IWUSR | S_IRUGO, mmc_lockable_show, mmc_lockable_store);
diff --git a/drivers/mmc/core/lock.h b/drivers/mmc/core/lock.h
new file mode 100644
index 0000000..cf05137
--- /dev/null
+++ b/drivers/mmc/core/lock.h
@@ -0,0 +1,42 @@
+/*
+ * linux/drivers/mmc/core/lock.h
+ *
+ * Copyright 2006 Instituto Nokia de Tecnologia (INdT), All Rights Reserved.
+ * Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _MMC_CORE_LOCK_H
+#define _MMC_CORE_LOCK_H
+
+#define dev_to_mmc_card(d) container_of(d, struct mmc_card, dev)
+
+#ifdef CONFIG_MMC_PASSWORDS
+
+/* core-internal data */
+struct mmc_key_payload {
+	struct rcu_head rcu; /* RCU destructor */
+	unsigned short datalen; /* length of this data */
+	char data[0]; /* actual data */
+};
+
+int mmc_register_key_type(void);
+void mmc_unregister_key_type(void);
+extern struct device_attribute dev_attr_lockable;
+
+#else
+
+static inline int mmc_register_key_type(void)
+{
+	return 0;
+}
+
+static inline void mmc_unregister_key_type(void)
+{
+}
+
+#endif
+
+#endif
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 54df5ad..1c2102c 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -20,6 +20,7 @@
 
 #include "core.h"
 #include "bus.h"
+#include "lock.h"
 #include "mmc_ops.h"
 #include "sd_ops.h"
 
@@ -638,6 +639,9 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_serial.attr,
 	&dev_attr_enhanced_area_offset.attr,
 	&dev_attr_enhanced_area_size.attr,
+#ifdef CONFIG_MMC_PASSWORDS
+	&dev_attr_lockable.attr,
+#endif
 	NULL,
 };
 
@@ -827,6 +831,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	unsigned int max_dtr;
 	u32 rocr;
 	u8 *ext_csd = NULL;
+	u32 status;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -904,6 +909,15 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
 	}
 
+	/*
+	* Check if card is locked.
+	*/
+	err = mmc_send_status(card, &status);
+	if (err)
+		goto free_card;
+	if (status & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+
 	if (!oldcard) {
 		/*
 		 * Fetch CSD from card.
@@ -1348,7 +1362,8 @@ static int mmc_suspend(struct mmc_host *host)
 			mmc_card_set_sleep(host->card);
 	} else if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
-	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200
+						   | MMC_STATE_LOCKED);
 	mmc_release_host(host);
 
 	return err;
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 69370f4..8be3fcd 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -2,6 +2,8 @@
  *  linux/drivers/mmc/core/mmc_ops.h
  *
  *  Copyright 2006-2007 Pierre Ossman
+ * MMC password protection (C) 2006 Instituto Nokia de Tecnologia (INdT),
+ * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -13,12 +15,14 @@
 #include <linux/export.h>
 #include <linux/types.h>
 #include <linux/scatterlist.h>
+#include <linux/key.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/mmc.h>
 
 #include "core.h"
+#include "lock.h"
 #include "mmc_ops.h"
 
 static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
@@ -45,6 +49,120 @@ static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
 	return 0;
 }
 
+#ifdef CONFIG_MMC_PASSWORDS
+
+int mmc_lock_unlock(struct mmc_card *card, struct key *key, int mode)
+{
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	struct scatterlist sg;
+	struct mmc_key_payload *mpayload;
+	unsigned long erase_timeout;
+	int err, data_size;
+	u8 *data_buf;
+
+	mpayload = NULL;
+	data_size = 1;
+	if (!(mode & MMC_LOCK_MODE_ERASE)) {
+		mpayload = rcu_dereference(key->payload.data);
+		data_size = 2 + mpayload->datalen;
+	}
+
+	data_buf = kzalloc(data_size, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
+
+	data_buf[0] |= mode;
+	if (mode & MMC_LOCK_MODE_UNLOCK)
+		data_buf[0] &= ~MMC_LOCK_MODE_UNLOCK;
+
+	if (!(mode & MMC_LOCK_MODE_ERASE)) {
+		data_buf[1] = mpayload->datalen;
+		memcpy(data_buf + 2, mpayload->data, mpayload->datalen);
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SET_BLOCKLEN;
+	cmd.arg = data_size;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		goto out;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_LOCK_UNLOCK;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R1B | MMC_CMD_ADTC;
+
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	data.blksz = data_size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_WRITE;
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	mmc_set_data_timeout(&data, card);
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, data_buf, data_size);
+	mmc_wait_for_req(card->host, &mrq);
+	err = cmd.error;
+	if (err)
+		goto out;
+	err = data.error;
+	if (err)
+		goto out;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SEND_STATUS;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	/* set timeout for forced erase operation to 3 min. (see MMC spec) */
+	erase_timeout = jiffies + 180 * HZ;
+	do {
+		/* we cannot use "retries" here because the
+		* R1_LOCK_UNLOCK_FAILED bit is cleared by subsequent reads to
+		* the status register, hiding the error condition */
+		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (err)
+			break;
+		/* the other modes don't need timeout checking */
+		if (!(mode & MMC_LOCK_MODE_ERASE))
+			continue;
+		if (time_after(jiffies, erase_timeout)) {
+			dev_dbg(&card->dev, "forced erase timed out\n");
+			err = -ETIMEDOUT;
+			break;
+		}
+	} while (!(cmd.resp[0] & R1_READY_FOR_DATA));
+	if (cmd.resp[0] & R1_LOCK_UNLOCK_FAILED) {
+		dev_dbg(&card->dev, "LOCK_UNLOCK operation failed\n");
+		err = -EIO;
+	}
+
+	if (cmd.resp[0] & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+	else
+		card->state &= ~MMC_STATE_LOCKED;
+
+out:
+	kfree(data_buf);
+
+	return err;
+}
+
+#endif /* CONFIG_MMC_PASSWORDS */
+
 int mmc_select_card(struct mmc_card *card)
 {
 	BUG_ON(!card);
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
index 3dd8941..c5070d4 100644
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@ -2,6 +2,8 @@
  *  linux/drivers/mmc/core/mmc_ops.h
  *
  *  Copyright 2006-2007 Pierre Ossman
+ * MMC password protection (C) 2006 Instituto Nokia de Tecnologia (INdT),
+ * All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -12,6 +14,8 @@
 #ifndef _MMC_MMC_OPS_H
 #define _MMC_MMC_OPS_H
 
+struct key;
+
 int mmc_select_card(struct mmc_card *card);
 int mmc_deselect_cards(struct mmc_host *host);
 int mmc_go_idle(struct mmc_host *host);
@@ -27,6 +31,7 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
 int mmc_card_sleepawake(struct mmc_host *host, int sleep);
 int mmc_bus_test(struct mmc_card *card, u8 bus_width);
 int mmc_send_hpi_cmd(struct mmc_card *card, u32 *status);
+int mmc_lock_unlock(struct mmc_card *card, struct key *key, int mode);
 
 #endif
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index c272c686..131e151 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -21,6 +21,7 @@
 
 #include "core.h"
 #include "bus.h"
+#include "lock.h"
 #include "mmc_ops.h"
 #include "sd.h"
 #include "sd_ops.h"
@@ -704,6 +705,9 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_oemid.attr,
 	&dev_attr_serial.attr,
+#ifdef CONFIG_MMC_PASSWORDS
+	&dev_attr_lockable.attr,
+#endif
 	NULL,
 };
 
@@ -808,26 +812,32 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	int err;
 
 	if (!reinit) {
-		/*
-		 * Fetch SCR from card.
-		 */
-		err = mmc_app_send_scr(card, card->raw_scr);
-		if (err)
-			return err;
 
-		err = mmc_decode_scr(card);
-		if (err)
-			return err;
+		if (!mmc_card_locked(card)) {
 
-		/*
-		 * Fetch and process SD Status register.
-		 */
-		err = mmc_read_ssr(card);
-		if (err)
-			return err;
+			/*
+			* Fetch SCR from card. But if the card is locked,
+			* this command will fail, then the card will be freed.
+			* So we won't send the scr command while card is locked.
+			*/
+			err = mmc_app_send_scr(card, card->raw_scr);
+			if (err)
+				return err;
 
-		/* Erase init depends on CSD and SSR */
-		mmc_init_erase(card);
+			err = mmc_decode_scr(card);
+			if (err)
+				return err;
+
+			/*
+			 * Fetch and process SD Status register.
+			 */
+			err = mmc_read_ssr(card);
+			if (err)
+				return err;
+
+			/* Erase init depends on CSD and SSR */
+			mmc_init_erase(card);
+		}
 
 		/*
 		 * Fetch switch information from card.
@@ -907,6 +917,7 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 	int err;
 	u32 cid[4];
 	u32 rocr = 0;
+	u32 status;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -944,6 +955,15 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 			return err;
 	}
 
+	/*
+	* Check if card is locked.
+	*/
+	err = mmc_send_status(card, &status);
+	if (err)
+		goto free_card;
+	if (status & R1_CARD_IS_LOCKED)
+		mmc_card_set_locked(card);
+
 	if (!oldcard) {
 		err = mmc_sd_get_csd(host, card);
 		if (err)
@@ -1081,7 +1101,7 @@ static int mmc_sd_suspend(struct mmc_host *host)
 	mmc_claim_host(host);
 	if (!mmc_host_is_spi(host))
 		mmc_deselect_cards(host);
-	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_LOCKED);
 	mmc_release_host(host);
 
 	return 0;
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index b5292f3..2962734 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -221,6 +221,7 @@ struct mmc_card {
 #define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
 #define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
 #define MMC_STATE_SLEEP		(1<<9)		/* card is in sleep state */
+#define MMC_STATE_LOCKED	(1<<10)		/* card is currently locked */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -388,6 +389,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_is_sleep(c)	((c)->state & MMC_STATE_SLEEP)
+#define mmc_card_locked(c)	((c)->state & MMC_STATE_LOCKED)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
@@ -400,6 +402,7 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_sleep(c)	((c)->state |= MMC_STATE_SLEEP)
+#define mmc_card_set_locked(c)	((c)->state |= MMC_STATE_LOCKED)
 
 #define mmc_card_clr_sleep(c)	((c)->state &= ~MMC_STATE_SLEEP)
 /*
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index b822a2c..8e6ffb2 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -446,4 +446,12 @@ struct _mmc_csd {
 #define MMC_SWITCH_MODE_CLEAR_BITS	0x02	/* Clear bits which are 1 in value */
 #define MMC_SWITCH_MODE_WRITE_BYTE	0x03	/* Set target to value */
 
+/*
+ * MMC_LOCK_UNLOCK modes
+ */
+#define MMC_LOCK_MODE_ERASE	(1<<3)
+#define MMC_LOCK_MODE_UNLOCK	(1<<2)
+#define MMC_LOCK_MODE_CLR_PWD	(1<<1)
+#define MMC_LOCK_MODE_SET_PWD	(1<<0)
+
 #endif /* LINUX_MMC_MMC_H */
-- 
1.8.3.2

