From 2b7dee822f630a7099202ee2c75076d0acf7f9d9 Mon Sep 17 00:00:00 2001
From: Nobuyuki HIRAI <nobuyuki.hirai.xe@renesas.com>
Date: Thu, 27 Jun 2013 10:26:21 +0900
Subject: [PATCH 0687/1083] ARM: shmobile: r8a7790: Add MMC driver support

Signed-off-by: Nobuyuki HIRAI <nobuyuki.hirai.xe@renesas.com>
(cherry picked from commit f6a5e10f773932574e8c5363a0adc65f4dccf65d)

Conflicts:
	arch/arm/mach-shmobile/board-lager.c
	arch/arm/mach-shmobile/clock-r8a7790.c
	arch/arm/mach-shmobile/setup-r8a7790.c

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 arch/arm/mach-shmobile/board-lager.c          |   5 ++
 arch/arm/mach-shmobile/clock-r8a7790.c        |  15 +++-
 arch/arm/mach-shmobile/include/mach/r8a7790.h |   4 +
 arch/arm/mach-shmobile/setup-r8a7790.c        | 110 ++++++++++++++++++++++++++
 4 files changed, 133 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-shmobile/board-lager.c b/arch/arm/mach-shmobile/board-lager.c
index 4734008..bc49e0f 100644
--- a/arch/arm/mach-shmobile/board-lager.c
+++ b/arch/arm/mach-shmobile/board-lager.c
@@ -151,6 +151,11 @@ static const struct pinctrl_map lager_pinctrl_map[] = {
 	/* USB2 */
 	PIN_MAP_MUX_GROUP_DEFAULT("ehci-platform.2", "pfc-r8a7790",
 				  "usb2", "usb2"),
+	/* MMC1 */
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mmcif.1", "pfc-r8a7790",
+				  "mmc1_data8", "mmc1"),
+	PIN_MAP_MUX_GROUP_DEFAULT("sh_mmcif.1", "pfc-r8a7790",
+				  "mmc1_ctrl", "mmc1"),
 };
 
 static void __init lager_add_standard_devices(void)
diff --git a/arch/arm/mach-shmobile/clock-r8a7790.c b/arch/arm/mach-shmobile/clock-r8a7790.c
index f4728f3..dfca726 100644
--- a/arch/arm/mach-shmobile/clock-r8a7790.c
+++ b/arch/arm/mach-shmobile/clock-r8a7790.c
@@ -324,6 +324,7 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_DEV_ID("sh-sci.9", &mstp_clks[MSTP716]),
 	CLKDEV_DEV_ID("ee200000.mmcif", &mstp_clks[MSTP315]),
 	CLKDEV_DEV_ID("sh_mmcif.0", &mstp_clks[MSTP315]),
+	CLKDEV_CON_ID("mmc.0", &div6_clks[DIV6_MMC0]),
 	CLKDEV_DEV_ID("ee100000.sdhi", &mstp_clks[MSTP314]),
 	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP314]),
 	CLKDEV_DEV_ID("ee120000.sdhi", &mstp_clks[MSTP313]),
@@ -334,6 +335,7 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_DEV_ID("sh_mobile_sdhi.3", &mstp_clks[MSTP311]),
 	CLKDEV_DEV_ID("ee220000.mmcif", &mstp_clks[MSTP305]),
 	CLKDEV_DEV_ID("sh_mmcif.1", &mstp_clks[MSTP305]),
+	CLKDEV_CON_ID("mmc.1", &div6_clks[DIV6_MMC1]),
 	CLKDEV_CON_ID("hs_usb", &mstp_clks[MSTP704]),
 	CLKDEV_CON_ID("usb_fck", &mstp_clks[MSTP703]),
 	CLKDEV_CON_ID("ss_usb", &mstp_clks[MSTP328]),
@@ -402,6 +404,7 @@ void __init r8a7790_clock_init(void)
 	void __iomem *modemr = ioremap_nocache(MODEMR, PAGE_SIZE);
 	u32 mode;
 	int k, ret = 0;
+	struct clk *mmc1_clk;
 
 	BUG_ON(!modemr);
 	mode = ioread32(modemr);
@@ -449,8 +452,18 @@ void __init r8a7790_clock_init(void)
 	if (!ret)
 		shmobile_clk_init();
 	else
-		panic("failed to setup r8a7790 clocks\n");
+		goto epanic;
 
 	r8a7790_rgx_control_init();
 	r8a7790_sdhi_clock_init();
+
+	mmc1_clk = clk_get(NULL, "mmc.1");
+	ret = clk_set_rate(mmc1_clk, 97500000);
+	if (ret)
+		goto epanic;
+
+	return;
+
+epanic:
+	panic("failed to setup r8a7790 clocks\n");
 }
diff --git a/arch/arm/mach-shmobile/include/mach/r8a7790.h b/arch/arm/mach-shmobile/include/mach/r8a7790.h
index 8173dc1..9a0b83b 100644
--- a/arch/arm/mach-shmobile/include/mach/r8a7790.h
+++ b/arch/arm/mach-shmobile/include/mach/r8a7790.h
@@ -238,6 +238,10 @@ enum {
 	SHDMA_SLAVE_SDHI2_RX,
 	SHDMA_SLAVE_SDHI3_TX,
 	SHDMA_SLAVE_SDHI3_RX,
+	SHDMA_SLAVE_MMC0_TX,
+	SHDMA_SLAVE_MMC0_RX,
+	SHDMA_SLAVE_MMC1_TX,
+	SHDMA_SLAVE_MMC1_RX,
 };
 
 #endif /* __ASM_R8A7790_H__ */
diff --git a/arch/arm/mach-shmobile/setup-r8a7790.c b/arch/arm/mach-shmobile/setup-r8a7790.c
index 3affcaa..526afef 100644
--- a/arch/arm/mach-shmobile/setup-r8a7790.c
+++ b/arch/arm/mach-shmobile/setup-r8a7790.c
@@ -39,6 +39,7 @@
 #include <linux/usb/ohci_pdriver.h>
 #include <linux/mfd/tmio.h>
 #include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/mmc/sh_mmcif.h>
 #include <linux/regulator/fixed.h>
 #include <linux/regulator/machine.h>
 #include <linux/mtd/mtd.h>
@@ -1260,6 +1261,26 @@ static const struct sh_dmadesc_slave_config r8a7790_sysdma_slaves[] = {
 		.addr		= 0xee160030 + 0x2000,
 		.chcr		= CHCR_RX(XMIT_SZ_16BIT),
 		.mid_rid	= 0xd4,
+	}, {
+		.slave_id	= SHDMA_SLAVE_MMC0_TX,
+		.addr		= 0xee200034,
+		.chcr		= CHCR_TX(XMIT_SZ_32BIT),
+		.mid_rid	= 0xd1,
+	}, {
+		.slave_id	= SHDMA_SLAVE_MMC0_RX,
+		.addr		= 0xee200034,
+		.chcr		= CHCR_RX(XMIT_SZ_32BIT),
+		.mid_rid	= 0xd2,
+	}, {
+		.slave_id	= SHDMA_SLAVE_MMC1_TX,
+		.addr		= 0xee220034,
+		.chcr		= CHCR_TX(XMIT_SZ_32BIT),
+		.mid_rid	= 0xe1,
+	}, {
+		.slave_id	= SHDMA_SLAVE_MMC1_RX,
+		.addr		= 0xee220034,
+		.chcr		= CHCR_RX(XMIT_SZ_32BIT),
+		.mid_rid	= 0xe2,
 	},
 };
 
@@ -1455,6 +1476,93 @@ static struct platform_device sata1_device = {
 	},
 };
 
+static void shmmcif_set_pwr(struct platform_device *pdev, int state)
+{
+}
+
+static void shmmcif_down_pwr(struct platform_device *pdev)
+{
+}
+
+static int shmmcif_get_cd(struct platform_device *pdev)
+{
+	return 1;
+}
+
+static struct resource sh_mmcif0_resources[] = {
+	[0] = {
+		.name	= "mmc0",
+		.start	= 0xEE200000,
+		.end	= 0xEE200080-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(169),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mmcif_plat_data sh_mmcif0_plat = {
+	.set_pwr	= shmmcif_set_pwr,
+	.down_pwr	= shmmcif_down_pwr,
+	.get_cd		= shmmcif_get_cd,
+	.slave_id_tx	= SHDMA_SLAVE_MMC0_TX,
+	.slave_id_rx	= SHDMA_SLAVE_MMC0_RX,
+	.use_cd_gpio	= 0,
+	.cd_gpio	= 0,
+	.sup_pclk	= 0 ,
+	.caps		= MMC_CAP_MMC_HIGHSPEED |
+			  MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE ,
+	.ocr		= MMC_VDD_32_33 | MMC_VDD_33_34 ,
+};
+
+static struct platform_device mmc0_device = {
+	.name		= "sh_mmcif",
+	.num_resources	= ARRAY_SIZE(sh_mmcif0_resources),
+	.resource	= sh_mmcif0_resources,
+	.id		= 0,
+	.dev = {
+		.platform_data	= &sh_mmcif0_plat,
+	}
+};
+
+static struct resource sh_mmcif1_resources[] = {
+	[0] = {
+		.name	= "mmc1",
+		.start	= 0xEE220000,
+		.end	= 0xEE220080-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_spi(170),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_mmcif_plat_data sh_mmcif1_plat = {
+	.set_pwr	= shmmcif_set_pwr,
+	.down_pwr	= shmmcif_down_pwr,
+	.get_cd		= shmmcif_get_cd,
+	.slave_id_tx	= SHDMA_SLAVE_MMC1_TX,
+	.slave_id_rx	= SHDMA_SLAVE_MMC1_RX,
+	.use_cd_gpio	= 0,
+	.cd_gpio	= 0,
+	.sup_pclk	= 0 ,
+	.caps		= MMC_CAP_MMC_HIGHSPEED |
+			  MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE ,
+	.ocr		= MMC_VDD_32_33 | MMC_VDD_33_34 ,
+};
+
+static struct platform_device mmc1_device = {
+	.name		= "sh_mmcif",
+	.num_resources	= ARRAY_SIZE(sh_mmcif1_resources),
+	.resource	= sh_mmcif1_resources,
+	.id		= 1,
+	.dev = {
+		.platform_data	= &sh_mmcif1_plat,
+	}
+};
+
 static struct platform_device *r8a7790_early_devices[] __initdata = {
 	&eth_device,
 	&powervr_device,
@@ -1486,6 +1594,8 @@ static struct platform_device *r8a7790_early_devices[] __initdata = {
 	&scu_device,
 	&sata0_device,
 	&sata1_device,
+	&mmc0_device,
+	&mmc1_device,
 };
 
 static struct renesas_irqc_config irqc0_data = {
-- 
1.8.3.2

