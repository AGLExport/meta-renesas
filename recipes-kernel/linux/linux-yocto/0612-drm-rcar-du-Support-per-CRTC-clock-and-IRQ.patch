From c9470d41219f023ac998d6d3f1e609a695b40d83 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date: Fri, 14 Jun 2013 14:15:01 +0200
Subject: [PATCH 612/715] drm/rcar-du: Support per-CRTC clock and IRQ

Some of the DU revisions use one clock and IRQ per CRTC instead of one
clock and IRQ per device. Retrieve the correct clock and register the
correct IRQ for each CRTC.

Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
(cherry picked from commit 3d5d34c423c3c33d6e2fea16e4c37fc695a7af8b)

Conflicts:

	drivers/gpu/drm/rcar-du/rcar_du_drv.c

Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
(cherry picked from commit fa548c9cbc1f2296787abea34baf57eaf0b0937d)

Conflicts:
	drivers/gpu/drm/rcar-du/rcar_du_crtc.c
	drivers/gpu/drm/rcar-du/rcar_du_drv.c
	drivers/gpu/drm/rcar-du/rcar_du_drv.h

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c |  215 ++++++++++++--------------------
 drivers/gpu/drm/rcar-du/rcar_du_crtc.h |    2 +-
 drivers/gpu/drm/rcar-du/rcar_du_drv.c  |  139 +--------------------
 drivers/gpu/drm/rcar-du/rcar_du_drv.h  |    8 +-
 4 files changed, 91 insertions(+), 273 deletions(-)

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index bd8137d..00e8daa 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -70,116 +70,28 @@ static void rcar_du_crtc_clr_set(struct rcar_du_crtc *rcrtc, u32 reg,
 	rcar_du_write(rcdu, rcrtc->mmio_offset + reg, (value & ~clr) | set);
 }
 
-static inline u32 rcar_du_lvds0_read(struct rcar_du_device *rcdu, u32 reg)
+static int rcar_du_crtc_get(struct rcar_du_crtc *rcrtc)
 {
-	return ioread32(rcdu->lvds0_mmio + reg);
-}
+	struct rcar_du_device *rcdu = rcrtc->crtc.dev->dev_private;
+	int ret;
 
-static inline void rcar_du_lvds0_write(struct rcar_du_device *rcdu,
-				 u32 reg, u32 data)
-{
-	iowrite32(data, rcdu->lvds0_mmio + reg);
-}
+	ret = clk_prepare_enable(rcrtc->clock);
+	if (ret < 0)
+		return ret;
 
-static inline u32 rcar_du_lvds1_read(struct rcar_du_device *rcdu, u32 reg)
-{
-	return ioread32(rcdu->lvds1_mmio + reg);
-}
+	ret = rcar_du_get(rcdu);
+	if (ret < 0)
+		clk_disable_unprepare(rcrtc->clock);
 
-static inline void rcar_du_lvds1_write(struct rcar_du_device *rcdu,
-				 u32 reg, u32 data)
-{
-	iowrite32(data, rcdu->lvds1_mmio + reg);
+	return ret;
 }
 
-static void rcar_du_lvds0_setting(struct rcar_du_device *rcdu)
+static void rcar_du_crtc_put(struct rcar_du_crtc *rcrtc)
 {
-	u32 set_clock;
-
-	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
-
-	/* 3. PLL, CTR, CH register setting */
-	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
-		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000577B);
-	else if ((set_clock > (38 * 1000 * 1000))
-		 && (set_clock <= (60 * 1000 * 1000)))
-		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000569A);
-	else if ((set_clock > (61 * 1000 * 1000))
-		 && (set_clock <= (121 * 1000 * 1000)))
-		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x0000522C);
-	else if ((set_clock > (121 * 1000 * 1000))
-		 && (set_clock <= (150 * 1000 * 1000)))
-		rcar_du_lvds0_write(rcdu, LVDPLLCR, 0x000001C7);
-	else
-		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
-
-#ifdef WORK_AROUND /* work around */
-	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00002020); /* work around */
-#else
-	rcar_du_lvds0_write(rcdu, LVDCHCR, 0x00000000);
-#endif
-
-	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
-	rcar_du_lvds0_write(rcdu, LVDCR0,
-		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000005));
-
-	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
-	rcar_du_lvds0_write(rcdu, LVDCR1,
-		 (rcar_du_lvds0_read(rcdu, LVDCR1) | 0x000003FF));
-
-	/* 6. Set LVDCR0.PLLON=1 PLL ON */
-	rcar_du_lvds0_write(rcdu, LVDCR0,
-		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000010));
-	udelay(100); /* wait for 100us */
-
-	/* 7. Set LVDCR.LVRES=1 */
-	rcar_du_lvds0_write(rcdu, LVDCR0,
-		 (rcar_du_lvds0_read(rcdu, LVDCR0) | 0x00000002));
-}
-
-static void rcar_du_lvds1_setting(struct rcar_du_device *rcdu)
-{
-	u32 set_clock;
-
-	set_clock = rcdu->crtcs->crtc.mode.clock * 1000;
-
-	/* 3. PLL, CTR, CH register setting */
-	if ((0 < set_clock) && (set_clock <= (38 * 1000 * 1000)))
-		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000577B);
-	else if ((set_clock > (38 * 1000 * 1000))
-		 && (set_clock <= (60 * 1000 * 1000)))
-		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000569A);
-	else if ((set_clock > (61 * 1000 * 1000))
-		 && (set_clock <= (121 * 1000 * 1000)))
-		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x0000522C);
-	else if ((set_clock > (121 * 1000 * 1000))
-		 && (set_clock <= (150 * 1000 * 1000)))
-		rcar_du_lvds1_write(rcdu, LVDPLLCR, 0x000001C7);
-	else
-		dev_dbg(rcdu->dev, "error. out of dotclok in lvds input\n");
-
-#ifdef WORK_AROUND /* work around */
-	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00002020); /* work around */
-#else
-	rcar_du_lvds1_write(rcdu, LVDCHCR, 0x00000000);
-#endif
-
-	/* 4. set LVDCR0.BEN/LVEN=1, Enable LVDS IO */
-	rcar_du_lvds1_write(rcdu, LVDCR0,
-		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000005));
-
-	/* 5. Set LVDCR1.CHnSTBY = 11, LVDS IO ON */
-	rcar_du_lvds1_write(rcdu, LVDCR1,
-		 (rcar_du_lvds1_read(rcdu, LVDCR1) | 0x000003FF));
-
-	/* 6. Set LVDCR0.PLLON=1 PLL ON */
-	rcar_du_lvds1_write(rcdu, LVDCR0,
-		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000010));
-	udelay(100); /* wait for 100us */
+	struct rcar_du_device *rcdu = rcrtc->crtc.dev->dev_private;
 
-	/* 7. Set LVDCR.LVRES=1 */
-	rcar_du_lvds1_write(rcdu, LVDCR0,
-		 (rcar_du_lvds1_read(rcdu, LVDCR0) | 0x00000002));
+	rcar_du_put(rcdu);
+	clk_disable_unprepare(rcrtc->clock);
 }
 
 static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
@@ -192,7 +104,7 @@ static void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)
 	u32 div;
 
 	/* Dot clock */
-	clk = clk_get_rate(rcdu->clock);
+	clk = clk_get_rate(rcrtc->clock);
 	div = DIV_ROUND_CLOSEST(clk, mode->clock * 1000);
 	div = clamp(div, 1U, 64U) - 1;
 
@@ -398,9 +310,6 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)
 
 	rcar_du_start_stop(rcdu, true);
 
-	rcar_du_lvds0_setting(rcdu);
-	rcar_du_lvds1_setting(rcdu);
-
 	rcrtc->started = true;
 }
 
@@ -429,20 +338,16 @@ static void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)
 
 void rcar_du_crtc_suspend(struct rcar_du_crtc *rcrtc)
 {
-	struct rcar_du_device *rcdu = rcrtc->crtc.dev->dev_private;
-
 	rcar_du_crtc_stop(rcrtc);
-	rcar_du_put(rcdu);
+	rcar_du_crtc_put(rcrtc);
 }
 
 void rcar_du_crtc_resume(struct rcar_du_crtc *rcrtc)
 {
-	struct rcar_du_device *rcdu = rcrtc->crtc.dev->dev_private;
-
 	if (rcrtc->dpms != DRM_MODE_DPMS_ON)
 		return;
 
-	rcar_du_get(rcdu);
+	rcar_du_crtc_get(rcrtc);
 	rcar_du_crtc_start(rcrtc);
 }
 
@@ -456,18 +361,17 @@ static void rcar_du_crtc_update_base(struct rcar_du_crtc *rcrtc)
 
 static void rcar_du_crtc_dpms(struct drm_crtc *crtc, int mode)
 {
-	struct rcar_du_device *rcdu = crtc->dev->dev_private;
 	struct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);
 
 	if (rcrtc->dpms == mode)
 		return;
 
 	if (mode == DRM_MODE_DPMS_ON) {
-		rcar_du_get(rcdu);
+		rcar_du_crtc_get(rcrtc);
 		rcar_du_crtc_start(rcrtc);
 	} else {
 		rcar_du_crtc_stop(rcrtc);
-		rcar_du_put(rcdu);
+		rcar_du_crtc_put(rcrtc);
 	}
 
 	rcrtc->dpms = mode;
@@ -483,13 +387,12 @@ static bool rcar_du_crtc_mode_fixup(struct drm_crtc *crtc,
 
 static void rcar_du_crtc_mode_prepare(struct drm_crtc *crtc)
 {
-	struct rcar_du_device *rcdu = crtc->dev->dev_private;
 	struct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);
 
 	/* We need to access the hardware during mode set, acquire a reference
-	 * to the DU.
+	 * to the CRTC.
 	 */
-	rcar_du_get(rcdu);
+	rcar_du_crtc_get(rcrtc);
 
 	/* Stop the CRTC and release the plane. Force the DPMS mode to off as a
 	 * result.
@@ -539,10 +442,10 @@ static int rcar_du_crtc_mode_set(struct drm_crtc *crtc,
 
 error:
 	/* There's no rollback/abort operation to clean up in case of error. We
-	 * thus need to release the reference to the DU acquired in prepare()
+	 * thus need to release the reference to the CRTC acquired in prepare()
 	 * here.
 	 */
-	rcar_du_put(rcdu);
+	rcar_du_crtc_put(rcrtc);
 	return ret;
 }
 
@@ -635,6 +538,24 @@ static void rcar_du_crtc_finish_page_flip(struct rcar_du_crtc *rcrtc)
 	drm_vblank_put(dev, rcrtc->index);
 }
 
+static irqreturn_t rcar_du_crtc_irq(int irq, void *arg)
+{
+	struct rcar_du_crtc *rcrtc = arg;
+	irqreturn_t ret = IRQ_NONE;
+	u32 status;
+
+	status = rcar_du_crtc_read(rcrtc, DSSR);
+	rcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);
+
+	if (status & DSSR_VBK) {
+		drm_handle_vblank(rcrtc->crtc.dev, rcrtc->index);
+		rcar_du_crtc_finish_page_flip(rcrtc);
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
 static int rcar_du_crtc_page_flip(struct drm_crtc *crtc,
 				  struct drm_framebuffer *fb,
 				  struct drm_pending_vblank_event *event)
@@ -672,10 +593,29 @@ static const struct drm_crtc_funcs crtc_funcs = {
 
 int rcar_du_crtc_create(struct rcar_du_device *rcdu, unsigned int index)
 {
+	struct platform_device *pdev = to_platform_device(rcdu->dev);
 	struct rcar_du_crtc *rcrtc = &rcdu->crtcs[index];
 	struct drm_crtc *crtc = &rcrtc->crtc;
+	unsigned int irqflags;
+	char clk_name[5];
+	char *name;
+	int irq;
 	int ret;
 
+	/* Get the CRTC clock. */
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {
+		sprintf(clk_name, "du.%u", index);
+		name = clk_name;
+	} else {
+		name = NULL;
+	}
+
+	rcrtc->clock = devm_clk_get(rcdu->dev, name);
+	if (IS_ERR(rcrtc->clock)) {
+		dev_err(rcdu->dev, "no clock for CRTC %u\n", index);
+		return PTR_ERR(rcrtc->clock);
+	}
+
 	rcrtc->mmio_offset = index ? DISP2_REG_OFFSET : 0;
 	rcrtc->index = index;
 	rcrtc->dpms = DRM_MODE_DPMS_OFF;
@@ -689,6 +629,28 @@ int rcar_du_crtc_create(struct rcar_du_device *rcdu, unsigned int index)
 
 	drm_crtc_helper_add(crtc, &crtc_helper_funcs);
 
+	/* Register the interrupt handler. */
+	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {
+		irq = platform_get_irq(pdev, index);
+		irqflags = 0;
+	} else {
+		irq = platform_get_irq(pdev, 0);
+		irqflags = IRQF_SHARED;
+	}
+
+	if (irq < 0) {
+		dev_err(rcdu->dev, "no IRQ for CRTC %u\n", index);
+		return ret;
+	}
+
+	ret = devm_request_irq(rcdu->dev, irq, rcar_du_crtc_irq, irqflags,
+			       dev_name(rcdu->dev), rcrtc);
+	if (ret < 0) {
+		dev_err(rcdu->dev,
+			"failed to register IRQ for CRTC %u\n", index);
+		return ret;
+	}
+
 	return 0;
 }
 
@@ -701,16 +663,3 @@ void rcar_du_crtc_enable_vblank(struct rcar_du_crtc *rcrtc, bool enable)
 		rcar_du_crtc_clr(rcrtc, DIER, DIER_VBE);
 	}
 }
-
-void rcar_du_crtc_irq(struct rcar_du_crtc *rcrtc)
-{
-	u32 status;
-
-	status = rcar_du_crtc_read(rcrtc, DSSR);
-	rcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);
-
-	if (status & DSSR_VBK) {
-		drm_handle_vblank(rcrtc->crtc.dev, rcrtc->index);
-		rcar_du_crtc_finish_page_flip(rcrtc);
-	}
-}
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.h b/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
index 2a0365b..5b69e98 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
@@ -25,6 +25,7 @@ struct rcar_du_plane;
 struct rcar_du_crtc {
 	struct drm_crtc crtc;
 
+	struct clk *clock;
 	unsigned int mmio_offset;
 	unsigned int index;
 	bool started;
@@ -38,7 +39,6 @@ struct rcar_du_crtc {
 
 int rcar_du_crtc_create(struct rcar_du_device *rcdu, unsigned int index);
 void rcar_du_crtc_enable_vblank(struct rcar_du_crtc *rcrtc, bool enable);
-void rcar_du_crtc_irq(struct rcar_du_crtc *rcrtc);
 void rcar_du_crtc_cancel_page_flip(struct rcar_du_crtc *rcrtc,
 				   struct drm_file *file);
 void rcar_du_crtc_suspend(struct rcar_du_crtc *rcrtc);
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index 03ca147..d37ead5 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -36,8 +36,8 @@
 /*
  * rcar_du_get - Acquire a reference to the DU
  *
- * Acquiring a reference enables the device clock and setup core registers. A
- * reference must be held before accessing any hardware registers.
+ * Acquiring the first  reference setups core registers. A reference must be
+ * held before accessing any hardware registers.
  *
  * This function must be called with the DRM mode_config lock held.
  *
@@ -45,28 +45,9 @@
  */
 int rcar_du_get(struct rcar_du_device *rcdu)
 {
-	int ret;
-
 	if (rcdu->use_count)
 		goto done;
 
-	/* Enable clocks before accessing the hardware. */
-	ret = clk_prepare_enable(rcdu->clock);
-	if (ret < 0)
-		return ret;
-
-	ret = clk_enable(rcdu->clock_du1);
-	if (ret < 0)
-		return ret;
-
-	ret = clk_enable(rcdu->clock_lvds0);
-	if (ret < 0)
-		return ret;
-
-	ret = clk_enable(rcdu->clock_lvds1);
-	if (ret < 0)
-		return ret;
-
 	/* Enable extended features */
 	rcar_du_write(rcdu, DEFR, DEFR_CODE | DEFR_DEFE);
 	rcar_du_write(rcdu, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);
@@ -94,19 +75,11 @@ done:
 /*
  * rcar_du_put - Release a reference to the DU
  *
- * Releasing the last reference disables the device clock.
- *
  * This function must be called with the DRM mode_config lock held.
  */
 void rcar_du_put(struct rcar_du_device *rcdu)
 {
-	if (--rcdu->use_count)
-		return;
-
-	clk_disable_unprepare(rcdu->clock);
-	clk_disable(rcdu->clock_du1);
-	clk_disable(rcdu->clock_lvds0);
-	clk_disable(rcdu->clock_lvds1);
+	--rcdu->use_count;
 }
 
 /* -----------------------------------------------------------------------------
@@ -123,7 +96,6 @@ static int rcar_du_unload(struct drm_device *dev)
 	drm_kms_helper_poll_fini(dev);
 	drm_mode_config_cleanup(dev);
 	drm_vblank_cleanup(dev);
-	drm_irq_uninstall(dev);
 
 	dev->dev_private = NULL;
 
@@ -135,11 +107,7 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 	struct platform_device *pdev = dev->platformdev;
 	struct rcar_du_platform_data *pdata = pdev->dev.platform_data;
 	struct rcar_du_device *rcdu;
-	struct resource *lvds0_ioarea;
-	struct resource *lvds1_ioarea;
 	struct resource *mem;
-	struct resource *lvds0_mem;
-	struct resource *lvds1_mem;
 	int ret;
 
 	if (pdata == NULL) {
@@ -159,7 +127,7 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 	rcdu->ddev = dev;
 	dev->dev_private = rcdu;
 
-	/* I/O resources and clocks */
+	/* I/O resources */
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (mem == NULL) {
 		dev_err(&pdev->dev, "failed to get memory resource\n");
@@ -172,81 +140,6 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		return -ENOMEM;
 	}
 
-	/* LVDS0 */
-	lvds0_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (lvds0_mem == NULL) {
-		dev_err(&pdev->dev, "failed to get memory lvds0 resource\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
-	lvds0_ioarea = devm_request_mem_region(&pdev->dev, lvds0_mem->start,
-					 resource_size(lvds0_mem), pdev->name);
-	if (lvds0_ioarea == NULL) {
-		dev_err(&pdev->dev, "failed to request memory lvds0 region\n");
-		ret = -EBUSY;
-		goto done;
-	}
-
-	rcdu->lvds0_mmio = devm_ioremap_nocache(&pdev->dev, lvds0_ioarea->start,
-					  resource_size(lvds0_ioarea));
-	if (rcdu->lvds0_mmio == NULL) {
-		dev_err(&pdev->dev, "failed to remap memory lvds0 resource\n");
-		ret = -ENOMEM;
-		goto done;
-	}
-
-	/* LVDS1 */
-	lvds1_mem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
-	if (lvds1_mem == NULL) {
-		dev_err(&pdev->dev, "failed to get memory lvds1 resource\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
-	lvds1_ioarea = devm_request_mem_region(&pdev->dev, lvds1_mem->start,
-					 resource_size(lvds1_mem), pdev->name);
-	if (lvds1_ioarea == NULL) {
-		dev_err(&pdev->dev, "failed to request memory lvds1 region\n");
-		ret = -EBUSY;
-		goto done;
-	}
-
-	rcdu->lvds1_mmio = devm_ioremap_nocache(&pdev->dev, lvds1_ioarea->start,
-					  resource_size(lvds1_ioarea));
-	if (rcdu->lvds1_mmio == NULL) {
-		dev_err(&pdev->dev, "failed to remap memory lvds1 resource\n");
-		ret = -ENOMEM;
-		goto done;
-	}
-
-	rcdu->clock = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(rcdu->clock)) {
-		dev_err(&pdev->dev, "failed to get clock\n");
-		return -ENOENT;
-	}
-
-	rcdu->clock_du1 = clk_get(NULL, "rcar-du.1");
-	if (IS_ERR(rcdu->clock_du1)) {
-		dev_err(&pdev->dev, "failed to get rcar-du.1 clock\n");
-		ret = -ENOENT;
-		goto done;
-	}
-
-	rcdu->clock_lvds0 = clk_get(NULL, "lvds.0");
-	if (IS_ERR(rcdu->clock_lvds0)) {
-		dev_err(&pdev->dev, "failed to get lvds.0 clock\n");
-		ret = -ENOENT;
-		goto done;
-	}
-
-	rcdu->clock_lvds1 = clk_get(NULL, "lvds.1");
-	if (IS_ERR(rcdu->clock_lvds1)) {
-		dev_err(&pdev->dev, "failed to get lvds.1 clock\n");
-		ret = -ENOENT;
-		goto done;
-	}
-
 	/* DRM/KMS objects */
 	ret = rcar_du_modeset_init(rcdu);
 	if (ret < 0) {
@@ -254,19 +147,13 @@ static int rcar_du_load(struct drm_device *dev, unsigned long flags)
 		goto done;
 	}
 
-	/* IRQ and vblank handling */
+	/* vblank handling */
 	ret = drm_vblank_init(dev, (1 << rcdu->num_crtcs) - 1);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to initialize vblank\n");
 		goto done;
 	}
 
-	ret = drm_irq_install(dev);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to install IRQ handler\n");
-		goto done;
-	}
-
 	platform_set_drvdata(pdev, rcdu);
 
 done:
@@ -292,18 +179,6 @@ static void rcar_du_lastclose(struct drm_device *dev)
 	drm_fbdev_cma_restore_mode(rcdu->fbdev);
 }
 
-static irqreturn_t rcar_du_irq(int irq, void *arg)
-{
-	struct drm_device *dev = arg;
-	struct rcar_du_device *rcdu = dev->dev_private;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(rcdu->crtcs); ++i)
-		rcar_du_crtc_irq(&rcdu->crtcs[i]);
-
-	return IRQ_HANDLED;
-}
-
 static int rcar_du_enable_vblank(struct drm_device *dev, int crtc)
 {
 	struct rcar_du_device *rcdu = dev->dev_private;
@@ -336,13 +211,11 @@ static const struct file_operations rcar_du_fops = {
 };
 
 static struct drm_driver rcar_du_driver = {
-	.driver_features	= DRIVER_HAVE_IRQ | DRIVER_GEM | DRIVER_MODESET
-				| DRIVER_PRIME,
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME,
 	.load			= rcar_du_load,
 	.unload			= rcar_du_unload,
 	.preclose		= rcar_du_preclose,
 	.lastclose		= rcar_du_lastclose,
-	.irq_handler		= rcar_du_irq,
 	.get_vblank_counter	= drm_vblank_count,
 	.enable_vblank		= rcar_du_enable_vblank,
 	.disable_vblank		= rcar_du_disable_vblank,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index 873514b..460fabf 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -26,6 +26,8 @@ struct device;
 struct drm_device;
 struct drm_fbdev_cma;
 
+#define RCAR_DU_FEATURE_CRTC_IRQ_CLOCK	(1 << 0)	/* Per-CRTC IRQ and clock */
+
 /*
  * struct rcar_du_device_info - DU model-specific information
  * @features: device features (RCAR_DU_FEATURE_*)
@@ -40,12 +42,6 @@ struct rcar_du_device {
 	const struct rcar_du_device_info *info;
 
 	void __iomem *mmio;
-	void __iomem *lvds0_mmio;
-	void __iomem *lvds1_mmio;
-	struct clk *clock;
-	struct clk *clock_du1;
-	struct clk *clock_lvds0;
-	struct clk *clock_lvds1;
 	unsigned int use_count;
 
 	struct drm_device *ddev;
-- 
1.7.10.4

