From 793f4d6928ee734116ca68573b326514b05d7ae4 Mon Sep 17 00:00:00 2001
From: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
Date: Thu, 27 Jun 2013 19:40:41 +0900
Subject: [PATCH 695/715] media: video: Add ADV7180 decoder driver

The controls of contrast, brightness, hue and saturation are added.

Signed-off-by: Shinobu Uehara <shinobu.uehara.xc@renesas.com>
(cherry picked from commit 346764f7b1e30ed613e7246b5a3ccbb35694c2be)

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/media/video/adv7180.c |  699 +++++++++++++++++++++++++++++++++++++----
 1 file changed, 641 insertions(+), 58 deletions(-)

diff --git a/drivers/media/video/adv7180.c b/drivers/media/video/adv7180.c
index b8b6c4b..2d2b2a7 100644
--- a/drivers/media/video/adv7180.c
+++ b/drivers/media/video/adv7180.c
@@ -1,4 +1,8 @@
 /*
+ * drivers/media/video/adv7180.c
+ *
+ * Copyright (C) 2011-2013 Renesas Electronics Corporation
+ *
  * adv7180.c Analog Devices ADV7180 video decoder driver
  * Copyright (c) 2009 Intel Corporation
  *
@@ -26,8 +30,10 @@
 #include <media/v4l2-ioctl.h>
 #include <linux/videodev2.h>
 #include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
 #include <media/v4l2-chip-ident.h>
 #include <linux/mutex.h>
+#include <media/soc_camera.h>
 
 #define DRIVER_NAME "adv7180"
 
@@ -48,6 +54,7 @@
 #define ADV7180_INPUT_CONTROL_PAL_COMB_N_PED		0xd0
 #define ADV7180_INPUT_CONTROL_PAL_SECAM			0xe0
 #define ADV7180_INPUT_CONTROL_PAL_SECAM_PED		0xf0
+#define ADV7180_INPUT_CONTROL_INSEL_MASK		0x0f
 
 #define ADV7180_EXTENDED_OUTPUT_CONTROL_REG		0x04
 #define ADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS		0xC5
@@ -55,9 +62,37 @@
 #define ADV7180_AUTODETECT_ENABLE_REG			0x07
 #define ADV7180_AUTODETECT_DEFAULT			0x7f
 
+/* Contrast Control */
+#define ADV7180_CON_REG		0x08	/* Unsigned */
+#define ADV7180_CON_MIN		0	/* Gain on luma channel = 0 */
+#define ADV7180_CON_DEF		128	/* Gain on luma channel = 1 */
+#define ADV7180_CON_MAX		255	/* Gain on luma channel = 2 */
+/* Brightness Control */
+#define ADV7180_BRI_REG		0x0a	/* Signed */
+#define ADV7180_BRI_MIN		-128	/* -30 IRE */
+#define ADV7180_BRI_DEF		0	/* 0 IRE */
+#define ADV7180_BRI_MAX		127	/* +30 IRE */
+/* Hue Control */
+#define ADV7180_HUE_REG		0x0b	/* Signed, inverted */
+#define ADV7180_HUE_MIN		-127	/* -90 degree */
+#define ADV7180_HUE_DEF		0	/* 0 degree */
+#define ADV7180_HUE_MAX		128	/* +90 degree */
+/* Saturation Control */
+#define ADV7180_SD_SAT_CB_REG	0xe3	/* Unsigned */
+#define ADV7180_SD_SAT_CR_REG	0xe4	/* Unsigned */
+#define ADV7180_SAT_MIN		0	/* Gain on Cb/Cr channel = -42 dB */
+#define ADV7180_SAT_DEF		128	/* Gain on Cb/Cr channel = 0 dB */
+#define ADV7180_SAT_MAX		255	/* Gain on Cb/Cr channel = +6 dB */
+
 #define ADV7180_ADI_CTRL_REG				0x0e
 #define ADV7180_ADI_CTRL_IRQ_SPACE			0x20
 
+/* Power Management */
+#define ADV7180_PWR_MAN_REG		0x0f
+#define ADV7180_PWR_MAN_ON		0x04
+#define ADV7180_PWR_MAN_OFF		0x24
+#define ADV7180_PWR_MAN_RES		0x80
+
 #define ADV7180_STATUS1_REG				0x10
 #define ADV7180_STATUS1_IN_LOCK		0x01
 #define ADV7180_STATUS1_AUTOD_MASK	0x70
@@ -69,10 +104,22 @@
 #define ADV7180_STATUS1_AUTOD_SECAM	0x50
 #define ADV7180_STATUS1_AUTOD_PAL_COMB	0x60
 #define ADV7180_STATUS1_AUTOD_SECAM_525	0x70
+#define ADV7180_STATUS1_COL_KILL	0x80
+#define ADV7180_STATUS1_PAL_SIGNAL	(ADV7180_STATUS1_AUTOD_PAL_M | \
+					ADV7180_STATUS1_AUTOD_PAL_60 | \
+					ADV7180_STATUS1_AUTOD_PAL_B_G | \
+					ADV7180_STATUS1_AUTOD_PAL_COMB)
 
 #define ADV7180_IDENT_REG 0x11
 #define ADV7180_ID_7180 0x18
 
+#define ADV7180_MISC_GAIN_CONTROL	0x2B
+#define ADV7180_MISC_GAIN_CKE		0x40
+#define ADV7180_MISC_GAIN_PW_UPD	0x01
+
+#define ADV7180_MAN_WIN_CONTROL_REG	0x3D
+#define ADV7180_CKILLTHR_MASK		0x70
+
 #define ADV7180_ICONF1_ADI		0x40
 #define ADV7180_ICONF1_ACTIVE_LOW	0x01
 #define ADV7180_ICONF1_PSYNC_ONLY	0x10
@@ -90,13 +137,47 @@
 #define ADV7180_IMR3_ADI	0x4C
 #define ADV7180_IMR4_ADI	0x50
 
+#define ADV7180_NTSC_V_BIT_END_REG		0xE6
+#define ADV7180_NTSC_V_BIT_END_MANUAL_NVEND	0x4F
+
+/* Input image size */
+#define ADV7180_MAX_WIDTH	720
+#define ADV7180_MAX_HEIGHT	480
+
 struct adv7180_state {
+	struct v4l2_ctrl_handler ctrl_hdl;
 	struct v4l2_subdev	sd;
 	struct work_struct	work;
 	struct mutex		mutex; /* mutual excl. when accessing chip */
 	int			irq;
 	v4l2_std_id		curr_norm;
 	bool			autodetect;
+	u8			input;
+	const struct adv7180_color_format	*cfmt;
+};
+
+#define to_adv7180_sd(_ctrl) (&container_of(_ctrl->handler,		\
+					    struct adv7180_state,	\
+					    ctrl_hdl)->sd)
+
+struct regval_list {
+	unsigned char reg_num;
+	unsigned char value;
+};
+
+struct adv7180_color_format {
+	enum v4l2_mbus_pixelcode code;
+	enum v4l2_colorspace colorspace;
+};
+
+/*
+ * supported color format list
+ */
+static const struct adv7180_color_format adv7180_cfmts[] = {
+	{
+		.code		= V4L2_MBUS_FMT_YUYV8_2X8,
+		.colorspace	= V4L2_COLORSPACE_JPEG,
+	},
 };
 
 static v4l2_std_id adv7180_std_to_v4l2(u8 status1)
@@ -224,7 +305,8 @@ static int adv7180_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
 	if (std == V4L2_STD_ALL) {
 		ret = i2c_smbus_write_byte_data(client,
 			ADV7180_INPUT_CONTROL_REG,
-			ADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM);
+			ADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM
+				| state->input);
 		if (ret < 0)
 			goto out;
 
@@ -236,7 +318,8 @@ static int adv7180_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
 			goto out;
 
 		ret = i2c_smbus_write_byte_data(client,
-			ADV7180_INPUT_CONTROL_REG, ret);
+			ADV7180_INPUT_CONTROL_REG,
+			ret | state->input);
 		if (ret < 0)
 			goto out;
 
@@ -249,14 +332,404 @@ out:
 	return ret;
 }
 
+static int adv7180_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct adv7180_state *state = to_state(sd);
+
+	dev_dbg(&client->dev, "format %d\n", state->cfmt->code);
+
+	return 0;
+}
+
+static int adv7180_g_mbus_config(struct v4l2_subdev *sd,
+					struct v4l2_mbus_config *cfg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct soc_camera_link *icl = soc_camera_i2c_to_link(client);
+
+	cfg->flags = V4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_MASTER |
+		V4L2_MBUS_VSYNC_ACTIVE_LOW | V4L2_MBUS_HSYNC_ACTIVE_LOW |
+		V4L2_MBUS_DATA_ACTIVE_HIGH;
+	cfg->type = V4L2_MBUS_BT656;
+	cfg->flags = soc_camera_apply_board_flags(icl, cfg);
+
+	return 0;
+}
+
+/*
+ * adv7180_g_crop() - V4L2 decoder i/f handler for g_crop
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @a: pointer to standard V4L2 cropcap structure
+ *
+ * Gets current cropping rectangle.
+ */
+static int adv7180_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)
+{
+	a->c.left = 0;
+	a->c.top = 0;
+	/* set current window size */
+	a->c.width = ADV7180_MAX_WIDTH;		/* width is fixed value */
+	a->c.height = ADV7180_MAX_HEIGHT;	/* heigth is fixed value */
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	return 0;
+}
+
+/*
+ * adv7180_cropcap() - V4L2 decoder i/f handler for cropcap
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @a: pointer to standard V4L2 cropcap structure
+ *
+ * Gets cropping limits, default cropping rectangle and pixel aspect.
+ */
+static int adv7180_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)
+{
+	a->bounds.left = 0;
+	a->bounds.top = 0;
+	/* set maximum window size */
+	a->bounds.width = ADV7180_MAX_WIDTH;	/* width is fixed value */
+	a->bounds.height = ADV7180_MAX_HEIGHT;	/* heigth is fixed value */
+	a->defrect = a->bounds;
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	a->pixelaspect.numerator = 1;
+	a->pixelaspect.denominator = 1;
+
+	return 0;
+}
+
+/*
+ * adv7180_try_fmt() - V4L2 decoder i/f handler for try_mbus_fmt
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @mf: pointer to mediabus format structure
+ *
+ * Negotiate the image capture size and mediabus format.
+ * Try a format.
+ */
+static int adv7180_try_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_mbus_framefmt *mf)
+{
+	struct adv7180_state *state = to_state(sd);
+	int i;
+
+	mf->width = ADV7180_MAX_WIDTH;		/* width is fixed value */
+	mf->height = ADV7180_MAX_HEIGHT;	/* heigth is fixed value */
+
+	for (i = 0; i < ARRAY_SIZE(adv7180_cfmts); i++)
+		if (mf->code == adv7180_cfmts[i].code)
+			break;
+
+	if (i == ARRAY_SIZE(adv7180_cfmts)) {
+		/* Unsupported format requested. Propose either */
+		if (state->cfmt) {
+			/* the current one or */
+			mf->colorspace = state->cfmt->colorspace;
+			mf->code = state->cfmt->code;
+		} else {
+			/* the default one */
+			mf->colorspace = adv7180_cfmts[0].colorspace;
+			mf->code = adv7180_cfmts[0].code;
+		}
+	} else {
+		/* Also return the colorspace */
+		mf->colorspace	= adv7180_cfmts[i].colorspace;
+	}
+
+	return 0;
+}
+
+/*
+ * adv7180_enum_fmt() - V4L2 decoder i/f handler for enum_mbus_fmt
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @index: format index
+ * @code: pointer to mediabus format
+ *
+ * Enumerate supported mediabus formats.
+ */
+static int adv7180_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
+			   enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= ARRAY_SIZE(adv7180_cfmts))
+		return -EINVAL;
+
+	*code = adv7180_cfmts[index].code;
+
+	return 0;
+}
+
+static int adv7180_s_routing(struct v4l2_subdev *sd, u32 input,
+			     u32 output, u32 config)
+{
+	struct adv7180_state *state = to_state(sd);
+	int ret = mutex_lock_interruptible(&state->mutex);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (ret)
+		return ret;
+
+	/* We cannot discriminate between LQFP and 40-pin LFCSP, so accept
+	 * all inputs and let the card driver take care of validation
+	 */
+	if ((input & ADV7180_INPUT_CONTROL_INSEL_MASK) != input)
+		goto out;
+
+	ret = i2c_smbus_read_byte_data(client, ADV7180_INPUT_CONTROL_REG);
+
+	if (ret < 0)
+		goto out;
+
+	ret &= ~ADV7180_INPUT_CONTROL_INSEL_MASK;
+	ret = i2c_smbus_write_byte_data(client,
+					ADV7180_INPUT_CONTROL_REG,
+					ret | input);
+	state->input = input;
+out:
+	mutex_unlock(&state->mutex);
+	return ret;
+}
+
+/*
+ * adv7180_s_ctrl() - V4L2 decoder i/f handler for s_ctrl
+ * @ctrl: pointer to standard V4L2 control structure
+ *
+ * Set a control in ADV7180 decoder device.
+ */
+static int adv7180_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_adv7180_sd(ctrl);
+	struct adv7180_state *state = to_state(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = mutex_lock_interruptible(&state->mutex);
+	int val;
+
+	if (ret)
+		return ret;
+
+	val = ctrl->val;
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		if ((ctrl->val < ADV7180_BRI_MIN) ||
+					(ctrl->val > ADV7180_BRI_MAX))
+			ret = -ERANGE;
+		else
+			ret = i2c_smbus_write_byte_data(client,
+							ADV7180_BRI_REG,
+							val);
+		break;
+	case V4L2_CID_HUE:
+		/*Hue is inverted according to HSL chart */
+		if ((ctrl->val < ADV7180_HUE_MIN) ||
+					(ctrl->val > ADV7180_HUE_MAX))
+			ret = -ERANGE;
+		else
+			ret = i2c_smbus_write_byte_data(client,
+							ADV7180_HUE_REG,
+							-val);
+		break;
+	case V4L2_CID_CONTRAST:
+		if ((ctrl->val < ADV7180_CON_MIN) ||
+					(ctrl->val > ADV7180_CON_MAX))
+			ret = -ERANGE;
+		else
+			ret = i2c_smbus_write_byte_data(client,
+							ADV7180_CON_REG,
+							val);
+		break;
+	case V4L2_CID_SATURATION:
+		/*
+		 *This could be V4L2_CID_BLUE_BALANCE/V4L2_CID_RED_BALANCE
+		 *Let's not confuse the user, everybody understands saturation
+		 */
+		if ((ctrl->val < ADV7180_SAT_MIN) ||
+					(ctrl->val > ADV7180_SAT_MAX))
+			ret = -ERANGE;
+		else {
+			ret = i2c_smbus_write_byte_data(client,
+							ADV7180_SD_SAT_CB_REG,
+							val);
+			if (ret < 0)
+				break;
+
+			ret = i2c_smbus_write_byte_data(client,
+							ADV7180_SD_SAT_CR_REG,
+							val);
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&state->mutex);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops adv7180_ctrl_ops = {
+	.s_ctrl = adv7180_s_ctrl,
+};
+
+/*
+ * adv7180_init_controls() - Init controls
+ * @state: pointer to private state structure
+ *
+ * Init ADV7180 supported control handler.
+ */
+static int adv7180_init_controls(struct adv7180_state *state)
+{
+	v4l2_ctrl_handler_init(&state->ctrl_hdl, 4);
+
+	v4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, (s32)0x80000000,
+			  (s32)0x7fffffff, 1, ADV7180_BRI_DEF);
+	v4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,
+			  V4L2_CID_CONTRAST, (s32)0x80000000,
+			  (s32)0x7fffffff, 1, ADV7180_CON_DEF);
+	v4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,
+			  V4L2_CID_SATURATION, (s32)0x80000000,
+			  (s32)0x7fffffff, 1, ADV7180_SAT_DEF);
+	v4l2_ctrl_new_std(&state->ctrl_hdl, &adv7180_ctrl_ops,
+			  V4L2_CID_HUE, (s32)0x80000000,
+			  (s32)0x7fffffff, 1, ADV7180_HUE_DEF);
+	state->sd.ctrl_handler = &state->ctrl_hdl;
+	if (state->ctrl_hdl.error) {
+		int err = state->ctrl_hdl.error;
+
+		v4l2_ctrl_handler_free(&state->ctrl_hdl);
+		return err;
+	}
+	v4l2_ctrl_handler_setup(&state->ctrl_hdl);
+
+	return 0;
+}
+
+/*
+ * adv7180_exit_controls() - Cleanup controls
+ * @state: pointer to private state structure
+ *
+ * Free ADV7180 supported control handler.
+ */
+static void adv7180_exit_controls(struct adv7180_state *state)
+{
+	v4l2_ctrl_handler_free(&state->ctrl_hdl);
+}
+
+static int adv7180_set_params(struct i2c_client *client, u32 *width,
+			     u32 *height,
+			     enum v4l2_mbus_pixelcode code)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct adv7180_state *state = to_state(sd);
+	int i;
+	long status;
+
+	/*
+	 * select format
+	 */
+	for (i = 0; i < ARRAY_SIZE(adv7180_cfmts); i++) {
+		if (code == adv7180_cfmts[i].code) {
+			state->cfmt = adv7180_cfmts + i;
+			break;
+		}
+	}
+	if (i >= ARRAY_SIZE(adv7180_cfmts))
+		return -EINVAL;			/* no match format */
+
+	status = i2c_smbus_read_byte_data(client, ADV7180_STATUS1_REG);
+	if (status < 0) {
+		dev_info(&client->dev, "Not detect any video input signal\n");
+	} else {
+		if (status & ADV7180_STATUS1_IN_LOCK) {
+			if (((status & ADV7180_STATUS1_AUTOD_NTSC_4_43) \
+				 == ADV7180_STATUS1_AUTOD_NTSC_4_43) || \
+				  ((status & ADV7180_STATUS1_AUTOD_MASK) \
+				  == ADV7180_STATUS1_AUTOD_NTSM_M_J)) {
+				dev_info(&client->dev,
+				"Detected the NTSC video input signal\n");
+			} else if (status & ADV7180_STATUS1_PAL_SIGNAL) {
+				dev_info(&client->dev,
+				"Detected the PAL video input signal\n");
+			}
+		} else {
+			dev_info(&client->dev,
+				"Not detect any video input signal\n");
+		}
+	}
+
+	/*
+	 * set window size
+	 */
+	*width = ADV7180_MAX_WIDTH;	/* fixed value */
+	*height = ADV7180_MAX_HEIGHT;	/* fixed value */
+
+	return 0;
+}
+
+/*
+ * adv7180_g_fmt() - V4L2 decoder i/f handler for g_mbus_fmt
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @mf: pointer to mediabus format structure
+ *
+ * Negotiate the image capture size and mediabus format.
+ * Get the data format.
+ */
+static int adv7180_g_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct adv7180_state *state = to_state(sd);
+
+	mf->width	= ADV7180_MAX_WIDTH;	/* fixed value */
+	mf->height	= ADV7180_MAX_HEIGHT;	/* fixed value */
+	mf->code	= state->cfmt->code;
+	mf->colorspace	= state->cfmt->colorspace;
+	mf->field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+/*
+ * adv7180_s_fmt() - V4L2 decoder i/f handler for s_mbus_fmt
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @mf: pointer to mediabus format structure
+ *
+ * Negotiate the image capture size and mediabus format.
+ * Try a format.
+ */
+static int adv7180_s_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *mf)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct adv7180_state *state = to_state(sd);
+	int ret;
+
+	ret = adv7180_set_params(client, &mf->width, &mf->height,
+				    mf->code);
+
+	if (!ret)
+		mf->colorspace = state->cfmt->colorspace;
+
+	return ret;
+}
+
 static const struct v4l2_subdev_video_ops adv7180_video_ops = {
 	.querystd = adv7180_querystd,
 	.g_input_status = adv7180_g_input_status,
+	.s_routing = adv7180_s_routing,
+	.s_stream	= adv7180_s_stream,
+	.g_mbus_fmt	= adv7180_g_fmt,
+	.s_mbus_fmt	= adv7180_s_fmt,
+	.try_mbus_fmt	= adv7180_try_fmt,
+	.cropcap	= adv7180_cropcap,
+	.g_crop		= adv7180_g_crop,
+	.enum_mbus_fmt	= adv7180_enum_fmt,
+	.g_mbus_config	= adv7180_g_mbus_config,
 };
 
 static const struct v4l2_subdev_core_ops adv7180_core_ops = {
 	.g_chip_ident = adv7180_g_chip_ident,
 	.s_std = adv7180_s_std,
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
 };
 
 static const struct v4l2_subdev_ops adv7180_ops = {
@@ -298,55 +771,56 @@ static irqreturn_t adv7180_irq(int irq, void *devid)
 }
 
 /*
- * Generic i2c probe
- * concerning the addresses: i2c wants 7 bit (without the r/w bit), so '>>1'
+ * init_device - Init a ADV7180 device
+ * @client: pointer to i2c_client structure
+ * @state: pointer to private state structure
+ *
+ * Initialize the ADV7180 device
  */
-
-static __devinit int adv7180_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
+static int init_device(struct i2c_client *client, struct adv7180_state *state)
 {
-	struct adv7180_state *state;
-	struct v4l2_subdev *sd;
 	int ret;
 
-	/* Check if the adapter supports the needed features */
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
-		return -EIO;
-
-	v4l_info(client, "chip found @ 0x%02x (%s)\n",
-			client->addr << 1, client->adapter->name);
-
-	state = kzalloc(sizeof(struct adv7180_state), GFP_KERNEL);
-	if (state == NULL) {
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	state->irq = client->irq;
-	INIT_WORK(&state->work, adv7180_work);
-	mutex_init(&state->mutex);
-	state->autodetect = true;
-	sd = &state->sd;
-	v4l2_i2c_subdev_init(sd, client, &adv7180_ops);
-
 	/* Initialize adv7180 */
 	/* Enable autodetection */
-	ret = i2c_smbus_write_byte_data(client, ADV7180_INPUT_CONTROL_REG,
-		ADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM);
-	if (ret < 0)
-		goto err_unreg_subdev;
+	if (state->autodetect) {
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_INPUT_CONTROL_REG,
+				ADV7180_INPUT_CONTROL_AD_PAL_BG_NTSC_J_SECAM
+					| state->input);
+		if (ret < 0)
+			return ret;
 
-	ret = i2c_smbus_write_byte_data(client, ADV7180_AUTODETECT_ENABLE_REG,
-		ADV7180_AUTODETECT_DEFAULT);
-	if (ret < 0)
-		goto err_unreg_subdev;
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_AUTODETECT_ENABLE_REG,
+				ADV7180_AUTODETECT_DEFAULT);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = v4l2_std_to_adv7180(state->curr_norm);
+		if (ret < 0)
+			return ret;
 
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_INPUT_CONTROL_REG,
+				ret | state->input);
+		if (ret < 0)
+			return ret;
+
+	}
 	/* ITU-R BT.656-4 compatible */
 	ret = i2c_smbus_write_byte_data(client,
-		ADV7180_EXTENDED_OUTPUT_CONTROL_REG,
-		ADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);
+			ADV7180_EXTENDED_OUTPUT_CONTROL_REG,
+			ADV7180_EXTENDED_OUTPUT_CONTROL_NTSCDIS);
 	if (ret < 0)
-		goto err_unreg_subdev;
+		return ret;
+
+	/* Manually set V bit end position in NTSC mode */
+	ret = i2c_smbus_write_byte_data(client,
+			ADV7180_NTSC_V_BIT_END_REG,
+			ADV7180_NTSC_V_BIT_END_MANUAL_NVEND);
+	if (ret < 0)
+		return ret;
 
 	/* read current norm */
 	__adv7180_status(client, NULL, &state->curr_norm);
@@ -354,47 +828,103 @@ static __devinit int adv7180_probe(struct i2c_client *client,
 	/* register for interrupts */
 	if (state->irq > 0) {
 		ret = request_irq(state->irq, adv7180_irq, 0, DRIVER_NAME,
-			state);
+				  state);
 		if (ret)
-			goto err_unreg_subdev;
+			return ret;
 
-		ret = i2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG,
-			ADV7180_ADI_CTRL_IRQ_SPACE);
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_ADI_CTRL_REG,
+				ADV7180_ADI_CTRL_IRQ_SPACE);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
 		/* config the Interrupt pin to be active low */
-		ret = i2c_smbus_write_byte_data(client, ADV7180_ICONF1_ADI,
-			ADV7180_ICONF1_ACTIVE_LOW | ADV7180_ICONF1_PSYNC_ONLY);
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_ICONF1_ADI,
+				ADV7180_ICONF1_ACTIVE_LOW |
+					ADV7180_ICONF1_PSYNC_ONLY);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
 		ret = i2c_smbus_write_byte_data(client, ADV7180_IMR1_ADI, 0);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
 		ret = i2c_smbus_write_byte_data(client, ADV7180_IMR2_ADI, 0);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
-		/* enable AD change interrupts interrupts */
-		ret = i2c_smbus_write_byte_data(client, ADV7180_IMR3_ADI,
-			ADV7180_IRQ3_AD_CHANGE);
+		/* enable AD change interrupts */
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_IMR3_ADI,
+				ADV7180_IRQ3_AD_CHANGE);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
 		ret = i2c_smbus_write_byte_data(client, ADV7180_IMR4_ADI, 0);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 
-		ret = i2c_smbus_write_byte_data(client, ADV7180_ADI_CTRL_REG,
-			0);
+		ret = i2c_smbus_write_byte_data(client,
+				ADV7180_ADI_CTRL_REG,
+				0);
 		if (ret < 0)
-			goto err_unreg_subdev;
+			return ret;
 	}
 
 	return 0;
+}
+
+/*
+ * adv7180_probe - Probe a ADV7180 device
+ * @client: pointer to i2c_client structure
+ * @id: pointer to i2c_device_id structure
+ *
+ * Initialize the ADV7180 device
+ */
+static __devinit int adv7180_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct adv7180_state *state;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	v4l_info(client, "chip found @ 0x%02x (%s)\n",
+			client->addr << 1, client->adapter->name);
+
+	state = kzalloc(sizeof(struct adv7180_state), GFP_KERNEL);
+	if (state == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	state->irq = client->irq;
+	INIT_WORK(&state->work, adv7180_work);
+	mutex_init(&state->mutex);
+	state->autodetect = true;
+	state->input = 0;
+	state->cfmt = &adv7180_cfmts[0];
+	sd = &state->sd;
+
+	v4l2_i2c_subdev_init(sd, client, &adv7180_ops);
+
+	ret = adv7180_init_controls(state);
+	if (ret)
+		goto err_unreg_subdev;
+
+	/* Initialize adv7180 */
+	ret = init_device(client, state);
+	if (ret)
+		goto err_free_ctrl;
+
+	return 0;
 
+err_free_ctrl:
+	adv7180_exit_controls(state);
 err_unreg_subdev:
 	mutex_destroy(&state->mutex);
 	v4l2_device_unregister_subdev(sd);
@@ -404,6 +934,12 @@ err:
 	return ret;
 }
 
+/*
+ * adv7180_remove - Remove ADV7180 device support
+ * @client: pointer to i2c_client structure
+ *
+ * Reset the ADV7180 device
+ */
 static __devexit int adv7180_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
@@ -421,6 +957,7 @@ static __devexit int adv7180_remove(struct i2c_client *client)
 		}
 	}
 
+	v4l2_ctrl_handler_free(&state->ctrl_hdl);
 	mutex_destroy(&state->mutex);
 	v4l2_device_unregister_subdev(sd);
 	kfree(to_state(sd));
@@ -432,6 +969,48 @@ static const struct i2c_device_id adv7180_id[] = {
 	{},
 };
 
+#ifdef CONFIG_PM
+/*
+ * adv7180_suspend - Suspend ADV7180 device
+ * @client: pointer to i2c_client structure
+ * @state: power management state
+ *
+ * Power down the ADV7180 device
+ */
+static int adv7180_suspend(struct i2c_client *client, pm_message_t state)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, ADV7180_PWR_MAN_REG,
+					ADV7180_PWR_MAN_OFF);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+/*
+ * adv7180_resume - Resume ADV7180 device
+ * @client: pointer to i2c_client structure
+ *
+ * Power on and initialize the ADV7180 device
+ */
+static int adv7180_resume(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct adv7180_state *state = to_state(sd);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, ADV7180_PWR_MAN_REG,
+					ADV7180_PWR_MAN_ON);
+	if (ret < 0)
+		return ret;
+	ret = init_device(client, state);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+#endif
+
 MODULE_DEVICE_TABLE(i2c, adv7180_id);
 
 static struct i2c_driver adv7180_driver = {
@@ -441,6 +1020,10 @@ static struct i2c_driver adv7180_driver = {
 	},
 	.probe		= adv7180_probe,
 	.remove		= __devexit_p(adv7180_remove),
+#ifdef CONFIG_PM
+	.suspend = adv7180_suspend,
+	.resume = adv7180_resume,
+#endif
 	.id_table	= adv7180_id,
 };
 
-- 
1.7.10.4

