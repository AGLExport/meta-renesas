From 983a1585cadd49a6354061d82619271fe4b16529 Mon Sep 17 00:00:00 2001
From: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
Date: Wed, 17 Jul 2013 16:11:38 +0900
Subject: [PATCH 0742/1083] ARM: shmobile: Add r8a7791 support

Signed-off-by: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
---
 arch/arm/boot/dts/r8a7791.dtsi                |  78 ++++++++
 arch/arm/mach-shmobile/clock-r8a7791.c        | 202 ++++++++++++++++++++
 arch/arm/mach-shmobile/include/mach/common.h  |   5 +
 arch/arm/mach-shmobile/include/mach/r8a7791.h | 247 ++++++++++++++++++++++++
 arch/arm/mach-shmobile/setup-r8a7791.c        | 262 ++++++++++++++++++++++++++
 arch/arm/mach-shmobile/smp-r8a7790.c          |   2 +-
 6 files changed, 795 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/boot/dts/r8a7791.dtsi
 create mode 100644 arch/arm/mach-shmobile/clock-r8a7791.c
 create mode 100644 arch/arm/mach-shmobile/include/mach/r8a7791.h
 create mode 100644 arch/arm/mach-shmobile/setup-r8a7791.c

diff --git a/arch/arm/boot/dts/r8a7791.dtsi b/arch/arm/boot/dts/r8a7791.dtsi
new file mode 100644
index 0000000..7b04e93
--- /dev/null
+++ b/arch/arm/boot/dts/r8a7791.dtsi
@@ -0,0 +1,78 @@
+/*
+ * Device Tree Source for the r8a7791 SoC
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/ {
+	compatible = "renesas,r8a7791";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <0>;
+			clock-frequency = <1300000000>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a15";
+			reg = <1>;
+			clock-frequency = <1300000000>;
+		};
+
+	};
+
+	gic: interrupt-controller@f1001000 {
+		compatible = "arm,cortex-a15-gic";
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+		interrupt-controller;
+		reg = <0 0xf1001000 0 0x1000>,
+			<0 0xf1002000 0 0x1000>,
+			<0 0xf1004000 0 0x2000>,
+			<0 0xf1006000 0 0x2000>;
+		interrupts = <1 9 0xf04>;
+
+		gic-cpuif@4 {
+			compatible = "arm,gic-cpuif";
+			cpuif-id = <4>;
+			cpu = <&cpu0>;
+		};
+		gic-cpuif@5 {
+			compatible = "arm,gic-cpuif";
+			cpuif-id = <5>;
+			cpu = <&cpu1>;
+		};
+};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <1 13 0xf08>,
+				<1 14 0xf08>,
+				<1 11 0xf08>,
+				<1 10 0xf08>;
+		clock-frequency = <10000000>;
+	};
+
+	irqc0: interrupt-controller@e61c0000 {
+		compatible = "renesas,irqc";
+		#interrupt-cells = <2>;
+		interrupt-controller;
+		reg = <0 0xe61c0000 0 0x200>;
+		interrupt-parent = <&gic>;
+		interrupts = <0 0 4>, <0 1 4>, <0 2 4>,	<0 3 4>;
+	};
+};
diff --git a/arch/arm/mach-shmobile/clock-r8a7791.c b/arch/arm/mach-shmobile/clock-r8a7791.c
new file mode 100644
index 0000000..97e1c83
--- /dev/null
+++ b/arch/arm/mach-shmobile/clock-r8a7791.c
@@ -0,0 +1,202 @@
+/*
+ * r8a7791 clock framework support
+ *
+ * Copyright (C) 2013  Renesas Electronics Corporation
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2013  Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/sh_clk.h>
+#include <linux/clkdev.h>
+#include <mach/clock.h>
+#include <mach/common.h>
+
+/*
+ *   MD		EXTAL		PLL0	PLL1	PLL3
+ * 14 13 19	(MHz)		*1	*1
+ *---------------------------------------------------
+ * 0  0  0	15 x 1		x172/2	x208/2	x106
+ * 0  0  1	15 x 1		x172/2	x208/2	x88
+ * 0  1  0	20 x 1		x130/2	x156/2	x80
+ * 0  1  1	20 x 1		x130/2	x156/2	x66
+ * 1  0  0	26 / 2		x200/2	x240/2	x122
+ * 1  0  1	26 / 2		x200/2	x240/2	x102
+ * 1  1  0	30 / 2		x172/2	x208/2	x106
+ * 1  1  1	30 / 2		x172/2	x208/2	x88
+ *
+ * *1 :	Table 7.6 indicates VCO ouput (PLLx = VCO/2)
+ *	see "p1 / 2" on R8A7791_CLOCK_ROOT() below
+ */
+
+#define MD(nr)	(1 << nr)
+
+#define CPG_BASE 0xe6150000
+#define CPG_LEN 0x1000
+
+#define SMSTPCR1	0xE6150134
+#define SMSTPCR2	0xe6150138
+#define SMSTPCR3	0xE615013C
+#define SMSTPCR5	0xE6150144
+#define SMSTPCR7	0xe615014c
+#define SMSTPCR8	0xE6150990
+#define SMSTPCR9	0xE6150994
+#define SMSTPCR10	0xE6150998
+
+#define MODEMR		0xE6160060
+#define SDCKCR		0xE6150074
+#define SD2CKCR		0xE6150078
+#define SD3CKCR		0xE615007C
+#define MMC0CKCR	0xE6150240
+#define MMC1CKCR	0xE6150244
+#define SSPCKCR		0xE6150248
+#define SSPRSCKCR	0xE615024C
+
+static struct clk_mapping cpg_mapping = {
+	.phys   = CPG_BASE,
+	.len    = CPG_LEN,
+};
+
+static struct clk extal_clk = {
+	/* .rate will be updated on r8a7791_clock_init() */
+	.mapping	= &cpg_mapping,
+};
+
+static struct sh_clk_ops followparent_clk_ops = {
+	.recalc	= followparent_recalc,
+};
+
+static struct clk main_clk = {
+	/* .parent will be set r8a73a4_clock_init */
+	.ops	= &followparent_clk_ops,
+};
+
+/*
+ * clock ratio of these clock will be updated
+ * on r8a7791_clock_init()
+ */
+SH_FIXED_RATIO_CLK_SET(pll1_clk,		main_clk,	1, 1);
+SH_FIXED_RATIO_CLK_SET(pll3_clk,		main_clk,	1, 1);
+
+/* fixed ratio clock */
+SH_FIXED_RATIO_CLK_SET(extal_div2_clk,		extal_clk,	1, 2);
+SH_FIXED_RATIO_CLK_SET(cp_clk,			extal_clk,	1, 2);
+
+SH_FIXED_RATIO_CLK_SET(pll1_div2_clk,		pll1_clk,	1, 2);
+SH_FIXED_RATIO_CLK_SET(hp_clk,			pll1_clk,	1, 12);
+SH_FIXED_RATIO_CLK_SET(p_clk,			pll1_clk,	1, 24);
+
+SH_FIXED_RATIO_CLK_SET(mp_clk,			pll1_div2_clk,	1, 15);
+
+static struct clk *main_clks[] = {
+	&extal_clk,
+	&extal_div2_clk,
+	&main_clk,
+	&pll1_clk,
+	&pll1_div2_clk,
+	&pll3_clk,
+	&hp_clk,
+	&p_clk,
+	&mp_clk,
+	&cp_clk,
+};
+
+/* MSTP */
+enum {
+	MSTP721, MSTP720,
+/*	MSTP216, MSTP207, MSTP206, MSTP204, MSTP203, MSTP202,*/
+	MSTP_NR
+};
+
+static struct clk mstp_clks[MSTP_NR] = {
+	[MSTP721] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 21, 0), /* SCIF0 */
+	[MSTP720] = SH_CLK_MSTP32(&p_clk, SMSTPCR7, 20, 0), /* SCIF1 */
+};
+
+static struct clk_lookup lookups[] = {
+
+	/* main clocks */
+	CLKDEV_CON_ID("extal",		&extal_clk),
+	CLKDEV_CON_ID("extal_div2",	&extal_div2_clk),
+	CLKDEV_CON_ID("main",		&main_clk),
+	CLKDEV_CON_ID("pll1",		&pll1_clk),
+	CLKDEV_CON_ID("pll1_div2",	&pll1_div2_clk),
+	CLKDEV_CON_ID("pll3",		&pll3_clk),
+	CLKDEV_CON_ID("hp",		&hp_clk),
+	CLKDEV_CON_ID("p",		&p_clk),
+	CLKDEV_CON_ID("mp",		&mp_clk),
+	CLKDEV_CON_ID("cp",		&cp_clk),
+	CLKDEV_CON_ID("peripheral_clk", &hp_clk),
+
+	/* MSTP */
+	CLKDEV_DEV_ID("sh-sci.6", &mstp_clks[MSTP721]),
+	CLKDEV_DEV_ID("sh-sci.7", &mstp_clks[MSTP720]),
+};
+
+#define R8A7791_CLOCK_ROOT(e, m, p0, p1, p30, p31)		\
+	extal_clk.rate	= e * 1000 * 1000;			\
+	main_clk.parent	= m;					\
+	SH_CLK_SET_RATIO(&pll1_clk_ratio, p1 / 2, 1);		\
+	if (mode & MD(19))					\
+		SH_CLK_SET_RATIO(&pll3_clk_ratio, p31, 1);	\
+	else							\
+		SH_CLK_SET_RATIO(&pll3_clk_ratio, p30, 1)
+
+
+void __init r8a7791_clock_init(void)
+{
+	void __iomem *modemr = ioremap_nocache(MODEMR, PAGE_SIZE);
+	u32 mode;
+	int k, ret = 0;
+
+	BUG_ON(!modemr);
+	mode = ioread32(modemr);
+	iounmap(modemr);
+
+	switch (mode & (MD(14) | MD(13))) {
+	case 0:
+		R8A7791_CLOCK_ROOT(15, &extal_clk, 172, 208, 106, 88);
+		break;
+	case MD(13):
+		R8A7791_CLOCK_ROOT(20, &extal_clk, 130, 156, 80, 66);
+		break;
+	case MD(14):
+		R8A7791_CLOCK_ROOT(26, &extal_div2_clk, 200, 240, 122, 102);
+		break;
+	case MD(13) | MD(14):
+		R8A7791_CLOCK_ROOT(30, &extal_div2_clk, 172, 208, 106, 88);
+		break;
+	}
+
+	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
+		ret = clk_register(main_clks[k]);
+
+	if (!ret)
+		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
+
+	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
+
+	if (!ret)
+		shmobile_clk_init();
+	else
+		goto epanic;
+
+	return;
+
+epanic:
+	panic("failed to setup r8a7791 clocks\n");
+}
diff --git a/arch/arm/mach-shmobile/include/mach/common.h b/arch/arm/mach-shmobile/include/mach/common.h
index 5e137c4..c973154 100644
--- a/arch/arm/mach-shmobile/include/mach/common.h
+++ b/arch/arm/mach-shmobile/include/mach/common.h
@@ -69,6 +69,11 @@ extern void r8a7790_clock_init(void);
 extern void r8a7790_pinmux_init(void);
 extern void r8a7790_pm_init(void);
 
+extern void r8a7791_add_early_devices(void);
+extern void r8a7791_add_standard_devices(void);
+extern void r8a7791_clock_init(void);
+extern void r8a7791_pinmux_init(void);
+
 extern void shmobile_init_late(void);
 
 #ifdef CONFIG_SUSPEND
diff --git a/arch/arm/mach-shmobile/include/mach/r8a7791.h b/arch/arm/mach-shmobile/include/mach/r8a7791.h
new file mode 100644
index 0000000..df55d3f
--- /dev/null
+++ b/arch/arm/mach-shmobile/include/mach/r8a7791.h
@@ -0,0 +1,247 @@
+#ifndef __ASM_R8A7791_H__
+#define __ASM_R8A7791_H__
+
+#include <asm/mach/time.h>
+#include <linux/pm_domain.h>
+
+struct platform_device;
+
+struct rcar_du_platform_data;
+
+void r8a7791_add_standard_devices(void);
+void r8a7790_add_du_device(struct rcar_du_platform_data *pdata);
+void r8a7790_clock_init(void);
+void r8a7791_pinmux_init(void);
+
+extern struct sys_timer r8a7791_timer;
+extern struct smp_operations r8a7790_smp_ops;
+
+struct r8a7790_pm_ch {
+	unsigned long chan_offs;
+	unsigned int chan_bit;
+	unsigned int isr_bit;
+};
+
+struct r8a7790_pm_domain {
+	struct generic_pm_domain genpd;
+	struct r8a7790_pm_ch ch;
+};
+
+static inline struct r8a7790_pm_ch *to_r8a7790_ch(struct generic_pm_domain *d)
+{
+	return &container_of(d, struct r8a7790_pm_domain, genpd)->ch;
+}
+
+extern int r8a7790_sysc_power_down(struct r8a7790_pm_ch *r8a7790_ch);
+extern int r8a7790_sysc_power_up(struct r8a7790_pm_ch *r8a7790_ch);
+
+#ifdef CONFIG_PM
+extern struct r8a7790_pm_domain r8a7790_rgx;
+
+extern void r8a7790_init_pm_domain(struct r8a7790_pm_domain *r8a7790_pd);
+extern void r8a7790_add_device_to_domain(struct r8a7790_pm_domain *r8a7790_pd,
+					 struct platform_device *pdev);
+#else
+#define r8a7790_init_pm_domain(pd) do { } while (0)
+#define r8a7790_add_device_to_domain(pd, pdev) do { } while (0)
+#endif /* CONFIG_PM */
+
+/* USB Host */
+#define SHUSBH_MAX_CH		3
+
+#define SHUSBH_BASE		UL(0xee080000)
+#define SHUSBH_OHCI_BASE	(SHUSBH_BASE)
+#define SHUSBH_OHCI_SIZE	0x1000
+#define SHUSBH_EHCI_BASE	(SHUSBH_BASE + 0x1000)
+#define SHUSBH_EHCI_SIZE	0x1000
+
+#define SHUSBH_XHCI_BASE	UL(0xEE000000)
+#define SHUSBH_XHCI_SIZE	0x0C00
+
+/* PCI Configuration Registers for AHB-PCI Bridge Registers */
+#define PCI_CONF_AHBPCI_BAS	(SHUSBH_BASE + 0x10000)
+#define VID_DID			0x0000
+#define CMND_STS		0x0004
+#define REVID_CC		0x0008
+#define CLS_LT_HT_BIST		0x000C
+#define BASEAD			0x0010
+#define WIN1_BASEAD		0x0014
+#define WIN2_BASEAD		0x0018
+#define SSVID_SSID		0x002C
+
+/* PCI Configuration Registers for OHCI/EHCI */
+#define PCI_CONF_OHCI_BASE	(SHUSBH_BASE + 0x10000)
+#define OHCI_VID_DID		0x0000
+#define OHCI_CMND_STS		0x0004
+#define OHCI_BASEAD		0x0010
+
+#define PCI_CONF_EHCI_BASE	(SHUSBH_BASE + 0x10100)
+#define EHCI_VID_DID		0x0000
+#define EHCI_CMND_STS		0x0004
+#define EHCI_BASEAD		0x0010
+
+/* AHB-PCI Bridge Register */
+#define AHBPCI_BASE		(SHUSBH_BASE + 0x10800)
+#define PCIAHB_WIN1_CTR		0x0000
+#define PCIAHB_WIN2_CTR		0x0004
+#define PCIAHB_DCT_CTR		0x0008
+#define AHBPCI_WIN1_CTR		0x0010
+#define AHBPCI_WIN2_CTR		0x0014
+#define AHBPCI_DCT_CTR		0x001C
+#define PCI_INT_ENABLE		0x0020
+#define PCI_INT_STATUS		0x0024
+#define AHB_BUS_CTR		0x0030
+#define USBCTR			0x0034
+#define PCI_ARBITER_CTR		0x0040
+#define PCI_UNIT_REV		0x004C
+
+/* BIT */
+#define BIT00			0x00000001
+#define BIT01			0x00000002
+#define BIT02			0x00000004
+#define BIT03			0x00000008
+#define BIT04			0x00000010
+#define BIT05			0x00000020
+#define BIT06			0x00000040
+#define BIT07			0x00000080
+#define BIT08			0x00000100
+#define BIT09			0x00000200
+#define BIT10			0x00000400
+#define BIT11			0x00000800
+#define BIT12			0x00001000
+#define BIT13			0x00002000
+#define BIT14			0x00004000
+#define BIT15			0x00008000
+#define BIT16			0x00010000
+#define BIT17			0x00020000
+#define BIT18			0x00040000
+#define BIT19			0x00080000
+#define BIT20			0x00100000
+#define BIT21			0x00200000
+#define BIT22			0x00400000
+#define BIT23			0x00800000
+#define BIT24			0x01000000
+#define BIT25			0x02000000
+#define BIT26			0x04000000
+#define BIT27			0x08000000
+#define BIT28			0x10000000
+#define BIT29			0x20000000
+#define BIT30			0x40000000
+#define BIT31			0x80000000
+
+/*** PCI Configration Register for OHCI ***/
+/* VendorID, DeviceID 00h */
+#define OHCI_ID			0x00351033
+
+/*** PCI Configration Register for EHCI ***/
+/* VendorID, DeviceID 00h */
+#define EHCI_ID			0x00e01033
+
+/*** PCI Configration Register for AHB-PCI Bridge ***/
+/* CMND_STS 04h */
+#define DETPERR			BIT31
+#define SIGSERR			BIT30
+#define REMABORT		BIT29
+#define RETABORT		BIT28
+#define SIGTABORT		BIT27
+#define DEVTIM			(BIT26|BIT25)
+#define MDPERR			BIT24
+#define FBTBCAP			BIT23
+
+#define _66MCAP			BIT21
+#define CAPLIST			BIT20
+
+#define FBTBEN			BIT09
+#define SERREN			BIT08
+#define STEPCTR			BIT07
+#define PERREN			BIT06
+#define VGAPSNP			BIT05
+#define MWINVEN			BIT04
+#define SPECIALC		BIT03
+#define MASTEREN		BIT02
+#define MEMEN			BIT01
+#define IOEN			BIT00
+
+/*** AHB-PCI Bridge Setting ***/
+/* PCIAHB_WIN1_CTR 0x0800 */
+#define PREFETCH		(BIT01|BIT00)
+/* AHBPCI_WIN*_CTR 0810h,0814h */
+#define PCIWIN1_PCICMD		(BIT03|BIT01)
+
+#define AHB_CFG_HOST		0x80000000
+
+#define AHB_CFG_AHBPCI		0x40000000
+#define PCIWIN2_PCICMD		(BIT02|BIT01)
+
+/* PCI_INT_ENABLE 0820h */
+#define USBH_PMEEN		BIT19
+#define USBH_INTBEN		BIT17
+#define USBH_INTAEN		BIT16
+#define PCIAHB_WIN2_INTEN	BIT13
+#define PCIAHB_WIN1_INTEN	BIT12
+#define RESERR_INTEN		BIT05
+#define SIGSERR_INTEN		BIT04
+#define PERR_INTEN		BIT03
+#define REMARBORT_INTEN		BIT02
+#define RETARBORT_INTEN		BIT01
+#define SIGTARBORT_INTEN	BIT00
+
+/* AHB_BUS_CTR 0830h */
+#define AHB_BUS_CTR_SET \
+	(BIT17 | BIT07 | BIT02 | BIT01 | BIT00)
+/* USBCTR 0834h */
+#define PCI_AHB_WIN1_SIZE_256M	0
+#define PCI_AHB_WIN1_SIZE_512M	BIT10
+#define PCI_AHB_WIN1_SIZE_1G	BIT11
+#define PCI_AHB_WIN1_SIZE_2G	(BIT10 | BIT11)
+#define DIRPD			BIT08
+#define PLL_RST			BIT02
+#define PCICLK_MASK		BIT01
+#define USBH_RST		BIT00
+
+/* PCI_ARBITER_CTR 0840h */
+#define PCIBP_MODE		BIT12
+#define PCIREQ1			BIT01
+#define PCIREQ0			BIT00
+
+/* DMA device IDs */
+enum {
+	SHDMA_DEVID_AUDIO_LO,
+	SHDMA_DEVID_AUDIO_UP,
+	SHDMA_DEVID_AUDIOPP,
+	SHDMA_DEVID_SYS_LO,
+	SHDMA_DEVID_SYS_UP,
+};
+#define SHDMA_DEVID_AUDIO	(SHDMA_DEVID_AUDIO_LO | SHDMA_DEVID_AUDIO_UP)
+
+/* DMA slave IDs for Audio-DMAC and Audio-DMAC-pp */
+enum {
+	SHDMA_SLAVE_PCM_MEM_SSI0,
+	SHDMA_SLAVE_PCM_MEM_SRC0,
+	SHDMA_SLAVE_PCM_SSI1_MEM,
+	SHDMA_SLAVE_PCM_SRC1_MEM,
+	SHDMA_SLAVE_PCM_CMD1_MEM,
+	SHDMA_SLAVE_PCM_SRC0_SSI0,
+	SHDMA_SLAVE_PCM_CMD0_SSI0,
+	SHDMA_SLAVE_PCM_SSI1_SRC1,
+	SHDMA_SLAVE_PCM_MAX,
+};
+
+/* DMA slave IDs for SYS-DMAC */
+enum {
+	SHDMA_SLAVE_INVALID,
+	SHDMA_SLAVE_SDHI0_TX,
+	SHDMA_SLAVE_SDHI0_RX,
+	SHDMA_SLAVE_SDHI1_TX,
+	SHDMA_SLAVE_SDHI1_RX,
+	SHDMA_SLAVE_SDHI2_TX,
+	SHDMA_SLAVE_SDHI2_RX,
+	SHDMA_SLAVE_SDHI3_TX,
+	SHDMA_SLAVE_SDHI3_RX,
+	SHDMA_SLAVE_MMC0_TX,
+	SHDMA_SLAVE_MMC0_RX,
+	SHDMA_SLAVE_MMC1_TX,
+	SHDMA_SLAVE_MMC1_RX,
+};
+
+#endif /* __ASM_R8A7791_H__ */
diff --git a/arch/arm/mach-shmobile/setup-r8a7791.c b/arch/arm/mach-shmobile/setup-r8a7791.c
new file mode 100644
index 0000000..6cc5464
--- /dev/null
+++ b/arch/arm/mach-shmobile/setup-r8a7791.c
@@ -0,0 +1,262 @@
+/*
+ * r8a7791 processor support
+ *
+ * Copyright (C) 2013  Renesas Electronics Corporation
+ * Copyright (C) 2013  Renesas Solutions Corp.
+ * Copyright (C) 2013  Magnus Damm
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/kernel.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/serial_sci.h>
+#include <linux/sh_eth.h>
+#include <linux/i2c/i2c-rcar.h>
+#include <linux/sh_dma-desc.h>
+#include <linux/dma-mapping.h>
+#include <linux/sh_audma-pp.h>
+#include <linux/platform_data/gpio-rcar.h>
+#include <linux/platform_data/rcar-du.h>
+#include <linux/platform_data/irq-renesas-irqc.h>
+#include <linux/platform_data/rcar-du.h>
+#include <linux/clk.h>
+#include <linux/usb/ehci_pdriver.h>
+#include <linux/usb/ohci_pdriver.h>
+#include <linux/mfd/tmio.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/mmc/sh_mmcif.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/dma-mapping.h>
+#include <linux/spi/sh_msiof.h>
+#include <media/vin.h>
+#include <mach/common.h>
+#include <mach/irqs.h>
+#include <mach/r8a7791.h>
+#include <mach/dma-register.h>
+#include <asm/mach/arch.h>
+
+static const struct resource pfc_resources[] = {
+	DEFINE_RES_MEM(0xe6060000, 0x250),
+};
+
+#define R8A7791_GPIO(idx)						\
+static struct resource r8a7791_gpio##idx##_resources[] = {		\
+	DEFINE_RES_MEM(0xe6050000 + 0x1000 * (idx), 0x50),		\
+	DEFINE_RES_IRQ(gic_spi(4 + (idx))),				\
+};									\
+									\
+static struct gpio_rcar_config r8a7791_gpio##idx##_platform_data = {	\
+	.gpio_base	= 32 * (idx),					\
+	.irq_base	= 0,						\
+	.number_of_pins	= 32,						\
+	.pctl_name	= "pfc-r8a7791",				\
+	.has_both_edge_trigger = 1,					\
+};									\
+
+#define R8A7791_GPIO2(idx)						\
+static struct resource r8a7791_gpio##idx##_resources[] = {		\
+	DEFINE_RES_MEM(0xe6055400 + 0x400 * (idx - 6), 0x50),		\
+	DEFINE_RES_IRQ(gic_spi(4 + (idx))),				\
+};									\
+									\
+static struct gpio_rcar_config r8a7791_gpio##idx##_platform_data = {	\
+	.gpio_base	= 32 * (idx),					\
+	.irq_base	= 0,						\
+	.number_of_pins	= 32,						\
+	.pctl_name	= "pfc-r8a7791",				\
+	.has_both_edge_trigger = 1,					\
+};									\
+
+R8A7791_GPIO(0);
+R8A7791_GPIO(1);
+R8A7791_GPIO(2);
+R8A7791_GPIO(3);
+R8A7791_GPIO(4);
+R8A7791_GPIO(5);
+R8A7791_GPIO2(6);
+R8A7791_GPIO2(7);
+
+#define r8a7791_register_gpio(idx)					\
+	platform_device_register_resndata(&platform_bus, "gpio_rcar", idx, \
+		r8a7791_gpio##idx##_resources,				\
+		ARRAY_SIZE(r8a7791_gpio##idx##_resources),		\
+		&r8a7791_gpio##idx##_platform_data,			\
+		sizeof(r8a7791_gpio##idx##_platform_data))
+
+void __init r8a7791_pinmux_init(void)
+{
+	platform_device_register_simple("pfc-r8a7791", -1, pfc_resources,
+					ARRAY_SIZE(pfc_resources));
+	r8a7791_register_gpio(0);
+	r8a7791_register_gpio(1);
+	r8a7791_register_gpio(2);
+	r8a7791_register_gpio(3);
+	r8a7791_register_gpio(4);
+	r8a7791_register_gpio(5);
+	r8a7791_register_gpio(6);
+	r8a7791_register_gpio(7);
+}
+
+#define SCIF_COMMON(scif_type, baseaddr, irq)			\
+	.type		= scif_type,				\
+	.mapbase	= baseaddr,				\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_IOREMAP,	\
+	.irqs		= SCIx_IRQ_MUXED(irq)
+
+#define SCIFA_DATA(index, baseaddr, irq)		\
+[index] = {						\
+	SCIF_COMMON(PORT_SCIFA, baseaddr, irq),		\
+	.scbrr_algo_id	= SCBRR_ALGO_4,			\
+	.scscr = SCSCR_RE | SCSCR_TE,	\
+}
+
+#define SCIFB_DATA(index, baseaddr, irq)	\
+[index] = {					\
+	SCIF_COMMON(PORT_SCIFB, baseaddr, irq),	\
+	.scbrr_algo_id	= SCBRR_ALGO_4,		\
+	.scscr = SCSCR_RE | SCSCR_TE,		\
+}
+
+#define SCIF_DATA(index, baseaddr, irq)		\
+[index] = {						\
+	SCIF_COMMON(PORT_SCIF, baseaddr, irq),		\
+	.scbrr_algo_id	= SCBRR_ALGO_2,			\
+	.scscr = SCSCR_RE | SCSCR_TE,	\
+}
+
+#define HSCIF_DATA(index, baseaddr, irq)		\
+[index] = {						\
+	SCIF_COMMON(PORT_HSCIF, baseaddr, irq),		\
+	.scbrr_algo_id	= SCBRR_ALGO_6,			\
+	.scscr = SCSCR_RE | SCSCR_TE,	\
+}
+
+enum { SCIF0 = 6, SCIF1, };
+
+static const struct plat_sci_port scif[] = {
+	SCIF_DATA(SCIF0, 0xe6e60000, gic_spi(152)), /* SCIF0 */
+	SCIF_DATA(SCIF1, 0xe6e68000, gic_spi(153)), /* SCIF1 */
+};
+
+static inline void r8a7791_register_scif(int idx)
+{
+	platform_device_register_data(&platform_bus, "sh-sci", idx, &scif[idx],
+				      sizeof(struct plat_sci_port));
+}
+
+static struct resource eth_resources[] = {
+	{
+		.start  = 0xee700200,
+		.end    = 0xee7003fc,
+		.flags  = IORESOURCE_MEM,
+	}, {
+		.start  = gic_spi(162),
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct sh_eth_plat_data eth_platform_data = {
+	.phy = 0x1,
+	.edmac_endian = EDMAC_LITTLE_ENDIAN,
+	.register_type = SH_ETH_REG_FAST_SH4,
+	.phy_interface = PHY_INTERFACE_MODE_RMII,
+	.ether_link_active_low = 1,
+};
+
+static struct platform_device eth_device = {
+	.name = "sh-eth",
+	.id	= 0,
+	.dev = {
+		.platform_data = &eth_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(eth_resources),
+	.resource = eth_resources,
+};
+
+static struct platform_device *r8a7791_early_devices[] __initdata = {
+	&eth_device,
+};
+
+static struct renesas_irqc_config irqc0_data = {
+	.irq_base = irq_pin(0), /* IRQ0 -> IRQ3 */
+};
+
+static struct resource irqc0_resources[] = {
+	DEFINE_RES_MEM(0xe61c0000, 0x200), /* IRQC Event Detector Block_0 */
+	DEFINE_RES_IRQ(gic_spi(0)), /* IRQ0 */
+	DEFINE_RES_IRQ(gic_spi(1)), /* IRQ1 */
+	DEFINE_RES_IRQ(gic_spi(2)), /* IRQ2 */
+	DEFINE_RES_IRQ(gic_spi(3)), /* IRQ3 */
+};
+
+#define r8a7791_register_irqc(idx)					\
+	platform_device_register_resndata(&platform_bus, "renesas_irqc", \
+					  idx, irqc##idx##_resources,	\
+					  ARRAY_SIZE(irqc##idx##_resources), \
+					  &irqc##idx##_data,		\
+					  sizeof(struct renesas_irqc_config))
+
+void __init r8a7791_add_standard_devices(void)
+{
+	r8a7791_register_scif(SCIF0);
+	r8a7791_register_scif(SCIF1);
+	r8a7791_register_irqc(0);
+	platform_add_devices(r8a7791_early_devices,
+			     ARRAY_SIZE(r8a7791_early_devices));
+}
+
+void __init r8a7791_timer_init(void)
+{
+	void __iomem *cntcr;
+
+	/* make sure arch timer is started by setting bit 0 of CNTCT */
+	cntcr = ioremap(0xe6080000, PAGE_SIZE);
+	iowrite32(1, cntcr);
+	iounmap(cntcr);
+
+	shmobile_timer_init();
+}
+
+struct sys_timer r8a7791_timer = {
+	.init		= r8a7791_timer_init,
+};
+
+#ifdef CONFIG_USE_OF
+void __init r8a7791_add_standard_devices_dt(void)
+{
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char *r8a7791_boards_compat_dt[] __initdata = {
+	"renesas,r8a7791",
+	NULL,
+};
+
+DT_MACHINE_START(R8A7791_DT, "Generic R8A7791 (Flattened Device Tree)")
+	.init_irq	= irqchip_init,
+	.init_machine	= r8a7791_add_standard_devices_dt,
+	.timer		= &r8a7791_timer,
+	.dt_compat	= r8a7791_boards_compat_dt,
+MACHINE_END
+#endif /* CONFIG_USE_OF */
diff --git a/arch/arm/mach-shmobile/smp-r8a7790.c b/arch/arm/mach-shmobile/smp-r8a7790.c
index d921def..2d12618 100644
--- a/arch/arm/mach-shmobile/smp-r8a7790.c
+++ b/arch/arm/mach-shmobile/smp-r8a7790.c
@@ -36,7 +36,7 @@
 #define RESCNT		0x010050
 #define CA15WUPCR	0x004010
 #define SYSCSR		0x030000
-#define MERAM		0xe8080000
+#define MERAM		0xe6300000
 #define CCI_BASE	0xf0190000
 #define CCI_SLAVE3	0x4000
 #define CCI_SLAVE4	0x5000
-- 
1.8.3.2

