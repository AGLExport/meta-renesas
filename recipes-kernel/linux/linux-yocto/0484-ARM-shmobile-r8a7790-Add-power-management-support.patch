From 6fd418911a8f92c2c405b805db99c8a2b90754a9 Mon Sep 17 00:00:00 2001
From: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
Date: Wed, 12 Jun 2013 14:29:53 +0900
Subject: [PATCH 484/715] ARM: shmobile: r8a7790: Add power management support

Signed-off-by: Hisashi Nakamura <hisashi.nakamura.ak@renesas.com>
(cherry picked from commit ed7fecca9bc54105cf9931a651f65dd38185ee1d)

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 arch/arm/mach-shmobile/Makefile               |    1 +
 arch/arm/mach-shmobile/include/mach/common.h  |    1 +
 arch/arm/mach-shmobile/include/mach/r8a7790.h |   31 ++++
 arch/arm/mach-shmobile/pm-r8a7790.c           |  225 +++++++++++++++++++++++++
 arch/arm/mach-shmobile/setup-r8a7790.c        |    2 +
 5 files changed, 260 insertions(+)
 create mode 100644 arch/arm/mach-shmobile/pm-r8a7790.c

diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index fa8509f..5306c8a 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_ARCH_SHMOBILE)	+= pm-rmobile.o
 obj-$(CONFIG_ARCH_SH7372)	+= pm-sh7372.o sleep-sh7372.o
 obj-$(CONFIG_ARCH_R8A7740)	+= pm-r8a7740.o
 obj-$(CONFIG_ARCH_R8A7779)	+= pm-r8a7779.o
+obj-$(CONFIG_ARCH_R8A7790)	+= pm-r8a7790.o
 
 # Board objects
 obj-$(CONFIG_MACH_G3EVM)	+= board-g3evm.o
diff --git a/arch/arm/mach-shmobile/include/mach/common.h b/arch/arm/mach-shmobile/include/mach/common.h
index 154a893..5e137c4 100644
--- a/arch/arm/mach-shmobile/include/mach/common.h
+++ b/arch/arm/mach-shmobile/include/mach/common.h
@@ -67,6 +67,7 @@ extern void r8a7790_add_early_devices(void);
 extern void r8a7790_add_standard_devices(void);
 extern void r8a7790_clock_init(void);
 extern void r8a7790_pinmux_init(void);
+extern void r8a7790_pm_init(void);
 
 extern void shmobile_init_late(void);
 
diff --git a/arch/arm/mach-shmobile/include/mach/r8a7790.h b/arch/arm/mach-shmobile/include/mach/r8a7790.h
index e4ed791..bbc1940 100644
--- a/arch/arm/mach-shmobile/include/mach/r8a7790.h
+++ b/arch/arm/mach-shmobile/include/mach/r8a7790.h
@@ -2,6 +2,9 @@
 #define __ASM_R8A7790_H__
 
 #include <asm/mach/time.h>
+#include <linux/pm_domain.h>
+
+struct platform_device;
 
 void r8a7790_add_standard_devices(void);
 void r8a7790_clock_init(void);
@@ -10,4 +13,32 @@ void r8a7790_pinmux_init(void);
 extern struct sys_timer r8a7790_timer;
 extern struct smp_operations r8a7790_smp_ops;
 
+struct r8a7790_pm_ch {
+	unsigned long chan_offs;
+	unsigned int chan_bit;
+	unsigned int isr_bit;
+};
+
+struct r8a7790_pm_domain {
+	struct generic_pm_domain genpd;
+	struct r8a7790_pm_ch ch;
+};
+
+static inline struct r8a7790_pm_ch *to_r8a7790_ch(struct generic_pm_domain *d)
+{
+	return &container_of(d, struct r8a7790_pm_domain, genpd)->ch;
+}
+
+extern int r8a7790_sysc_power_down(struct r8a7790_pm_ch *r8a7790_ch);
+extern int r8a7790_sysc_power_up(struct r8a7790_pm_ch *r8a7790_ch);
+
+#ifdef CONFIG_PM
+extern void r8a7790_init_pm_domain(struct r8a7790_pm_domain *r8a7790_pd);
+extern void r8a7790_add_device_to_domain(struct r8a7790_pm_domain *r8a7790_pd,
+					 struct platform_device *pdev);
+#else
+#define r8a7790_init_pm_domain(pd) do { } while (0)
+#define r8a7790_add_device_to_domain(pd, pdev) do { } while (0)
+#endif /* CONFIG_PM */
+
 #endif /* __ASM_R8A7790_H__ */
diff --git a/arch/arm/mach-shmobile/pm-r8a7790.c b/arch/arm/mach-shmobile/pm-r8a7790.c
new file mode 100644
index 0000000..cdd9747
--- /dev/null
+++ b/arch/arm/mach-shmobile/pm-r8a7790.c
@@ -0,0 +1,225 @@
+/*
+ * r8a7790 Power management support
+ *
+ * Copyright (C) 2013  Renesas Electronics Corporation
+ * Copyright (C) 2011  Renesas Solutions Corp.
+ * Copyright (C) 2011  Magnus Damm
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
+#include <linux/err.h>
+#include <linux/pm_clock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <asm/io.h>
+#include <mach/common.h>
+#include <mach/r8a7790.h>
+
+static void __iomem *r8a7790_sysc_base;
+
+/* SYSC */
+#define SYSC_BASE	0xE6180000
+
+#define SYSCSR		0x000
+#define SYSCISR		0x004
+#define SYSCISCR	0x008
+#define SYSCIER		0x00C
+#define SYSCIMR		0x010
+#define PWRSR0		0x040
+#define PWRSR2		0x0C0
+#define PWRSR3		0x100
+#define PWRSR4		0x140
+#define PWRSR5		0x180
+#define PWRSR6		0x1C0
+
+#define PWRSR_OFFS	0x000
+#define PWROFFCR_OFFS	0x004
+#define PWRONCR_OFFS	0x00C
+#define PWRER_OFFS	0x014
+
+#define SYSCSR_RETRIES	100
+#define SYSCSR_DELAY_US	1
+
+#define SYSCISR_RETRIES		1000
+#define SYSCISR_DELAY_US	1
+
+#if defined(CONFIG_PM) || defined(CONFIG_SMP)
+
+static DEFINE_SPINLOCK(r8a7790_sysc_lock); /* SMP CPUs + I/O devices */
+
+static int r8a7790_sysc_pwr_on_off(struct r8a7790_pm_ch *r8a7790_ch,
+				   int sr_bit, int reg_offs)
+{
+	int k;
+
+	for (k = 0; k < SYSCSR_RETRIES; k++) {
+		if (ioread32(r8a7790_sysc_base + SYSCSR) & (1 << sr_bit))
+			break;
+		udelay(SYSCSR_DELAY_US);
+	}
+
+	if (k == SYSCSR_RETRIES)
+		return -EAGAIN;
+
+	iowrite32(1 << r8a7790_ch->chan_bit,
+		  r8a7790_sysc_base + r8a7790_ch->chan_offs + reg_offs);
+
+	return 0;
+}
+
+static int r8a7790_sysc_pwr_off(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_pwr_on_off(r8a7790_ch, 0, PWROFFCR_OFFS);
+}
+
+static int r8a7790_sysc_pwr_on(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_pwr_on_off(r8a7790_ch, 1, PWRONCR_OFFS);
+}
+
+static int r8a7790_sysc_update(struct r8a7790_pm_ch *r8a7790_ch,
+			       int (*on_off_fn)(struct r8a7790_pm_ch *))
+{
+	unsigned int isr_mask = 1 << r8a7790_ch->isr_bit;
+	unsigned int chan_mask = 1 << r8a7790_ch->chan_bit;
+	unsigned int status;
+	unsigned long flags;
+	int ret = 0;
+	int k;
+
+	spin_lock_irqsave(&r8a7790_sysc_lock, flags);
+
+	iowrite32(isr_mask, r8a7790_sysc_base + SYSCISCR);
+
+	do {
+		ret = on_off_fn(r8a7790_ch);
+		if (ret)
+			goto out;
+
+		status = ioread32(r8a7790_sysc_base +
+				  r8a7790_ch->chan_offs + PWRER_OFFS);
+	} while (status & chan_mask);
+
+	for (k = 0; k < SYSCISR_RETRIES; k++) {
+		if (ioread32(r8a7790_sysc_base + SYSCISR) & isr_mask)
+			break;
+		udelay(SYSCISR_DELAY_US);
+	}
+
+	if (k == SYSCISR_RETRIES)
+		ret = -EIO;
+
+	iowrite32(isr_mask, r8a7790_sysc_base + SYSCISCR);
+
+ out:
+	spin_unlock_irqrestore(&r8a7790_sysc_lock, flags);
+
+	pr_debug("r8a7790 power domain %d: %02x %02x %02x %02x %02x %02x -> %d\n",
+		 r8a7790_ch->isr_bit, ioread32(r8a7790_sysc_base + PWRSR0),
+		 ioread32(r8a7790_sysc_base + PWRSR2),
+		 ioread32(r8a7790_sysc_base + PWRSR3),
+		 ioread32(r8a7790_sysc_base + PWRSR4),
+		 ioread32(r8a7790_sysc_base + PWRSR5),
+		 ioread32(r8a7790_sysc_base + PWRSR6), ret);
+	return ret;
+}
+
+int r8a7790_sysc_power_down(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_update(r8a7790_ch, r8a7790_sysc_pwr_off);
+}
+
+int r8a7790_sysc_power_up(struct r8a7790_pm_ch *r8a7790_ch)
+{
+	return r8a7790_sysc_update(r8a7790_ch, r8a7790_sysc_pwr_on);
+}
+
+static void __init r8a7790_sysc_init(void)
+{
+	r8a7790_sysc_base = ioremap_nocache(SYSC_BASE, PAGE_SIZE);
+	if (!r8a7790_sysc_base)
+		panic("unable to ioremap r8a7790 SYSC hardware block\n");
+
+	/* enable all interrupt sources, but do not use interrupt handler */
+	iowrite32(0x0131000e, r8a7790_sysc_base + SYSCIER);
+	iowrite32(0, r8a7790_sysc_base + SYSCIMR);
+}
+
+#else /* CONFIG_PM || CONFIG_SMP */
+
+static inline void r8a7790_sysc_init(void) {}
+
+#endif /* CONFIG_PM || CONFIG_SMP */
+
+#ifdef CONFIG_PM
+
+static int pd_power_down(struct generic_pm_domain *genpd)
+{
+	return r8a7790_sysc_power_down(to_r8a7790_ch(genpd));
+}
+
+static int pd_power_up(struct generic_pm_domain *genpd)
+{
+	return r8a7790_sysc_power_up(to_r8a7790_ch(genpd));
+}
+
+static bool pd_is_off(struct generic_pm_domain *genpd)
+{
+	struct r8a7790_pm_ch *r8a7790_ch = to_r8a7790_ch(genpd);
+	unsigned int st;
+
+	st = ioread32(r8a7790_sysc_base + r8a7790_ch->chan_offs + PWRSR_OFFS);
+	if (st & (1 << r8a7790_ch->chan_bit))
+		return true;
+
+	return false;
+}
+
+static bool pd_active_wakeup(struct device *dev)
+{
+	return true;
+}
+
+void r8a7790_init_pm_domain(struct r8a7790_pm_domain *r8a7790_pd)
+{
+	struct generic_pm_domain *genpd = &r8a7790_pd->genpd;
+
+	pm_genpd_init(genpd, NULL, false);
+	genpd->dev_ops.stop = pm_clk_suspend;
+	genpd->dev_ops.start = pm_clk_resume;
+	genpd->dev_ops.active_wakeup = pd_active_wakeup;
+	genpd->dev_irq_safe = true;
+	genpd->power_off = pd_power_down;
+	genpd->power_on = pd_power_up;
+
+	if (pd_is_off(&r8a7790_pd->genpd))
+		pd_power_up(&r8a7790_pd->genpd);
+}
+
+void r8a7790_add_device_to_domain(struct r8a7790_pm_domain *r8a7790_pd,
+				 struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	pm_genpd_add_device(&r8a7790_pd->genpd, dev);
+	if (pm_clk_no_clocks(dev))
+		pm_clk_add(dev, NULL);
+}
+
+#endif /* CONFIG_PM */
+
+void __init r8a7790_pm_init(void)
+{
+	static int once;
+
+	if (!once++)
+		r8a7790_sysc_init();
+}
diff --git a/arch/arm/mach-shmobile/setup-r8a7790.c b/arch/arm/mach-shmobile/setup-r8a7790.c
index 6cea67e..b84aff2 100644
--- a/arch/arm/mach-shmobile/setup-r8a7790.c
+++ b/arch/arm/mach-shmobile/setup-r8a7790.c
@@ -163,6 +163,8 @@ static struct resource irqc0_resources[] = {
 
 void __init r8a7790_add_standard_devices(void)
 {
+	r8a7790_pm_init();
+
 	r8a7790_register_scif(SCIFA0);
 	r8a7790_register_scif(SCIFA1);
 	r8a7790_register_scif(SCIFB0);
-- 
1.7.10.4

