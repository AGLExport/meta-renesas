From 1ab7e453b65b022f8a1b8ed63af6c97a77db17f1 Mon Sep 17 00:00:00 2001
From: Shunsuke Kataoka <shunsuke.kataoka.df@renesas.com>
Date: Thu, 13 Jun 2013 14:20:17 +0900
Subject: [PATCH 0530/1083] dma: sh: Add audma-pp driver

Signed-off-by: Shunsuke Kataoka <shunsuke.kataoka.df@renesas.com>
(cherry picked from commit 5951ac2c838ecb01c1ec439d2e0ceffb2ecc3a3e)

Signed-off-by: Ryo Kataoka <ryo.kataoka.wt@renesas.com>
---
 drivers/dma/Kconfig           |  22 +++
 drivers/dma/sh/Makefile       |   2 +
 drivers/dma/sh/audma-pp.c     | 337 ++++++++++++++++++++++++++++++++++++++++++
 drivers/dma/sh/audma-pp.h     |  65 ++++++++
 drivers/dma/sh/shdmapp-base.c | 245 ++++++++++++++++++++++++++++++
 include/linux/sh_audma-pp.h   |  58 ++++++++
 include/linux/shdmapp-base.h  |  35 +++++
 7 files changed, 764 insertions(+)
 create mode 100644 drivers/dma/sh/audma-pp.c
 create mode 100644 drivers/dma/sh/audma-pp.h
 create mode 100644 drivers/dma/sh/shdmapp-base.c
 create mode 100644 include/linux/sh_audma-pp.h
 create mode 100644 include/linux/shdmapp-base.h

diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index f250dad..6f30993 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -178,6 +178,28 @@ config SH_DMAE_DESC
 	  Say Y here if you have enabled, otherwise say N.
 	  To compile this driver as a module, say M.
 
+config SH_DMAEPP_BASE
+	tristate "Renesas SuperH DMA Engine support (Peripheral <-> Peripheral)"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	select DMA_ENGINE
+	help
+	  Enable support for the DMA Engine driver base library of Renesas DMA controllers.
+	  This is supported to DMAC that is transferred between peripheral and peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SH_DMAEPP_AUPP
+	tristate "Renesas SuperH Audio-DMAC-pp support"
+	depends on (SUPERH && SH_DMA) || (ARM && ARCH_SHMOBILE)
+	depends on !SH_DMA_API
+	depends on SH_DMAEPP_BASE
+	help
+	  Enable support for the Renesas DMA controllers.
+	  This is supported to Audio-DMAC-Peripheral-Peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
 config COH901318
 	bool "ST-Ericsson COH901318 DMA support"
 	select DMA_ENGINE
diff --git a/drivers/dma/sh/Makefile b/drivers/dma/sh/Makefile
index ac09de3..84116d9 100644
--- a/drivers/dma/sh/Makefile
+++ b/drivers/dma/sh/Makefile
@@ -1,3 +1,5 @@
 obj-$(CONFIG_SH_DMAE_BASE) += shdma-base.o
 obj-$(CONFIG_SH_DMAE) += shdma.o
 obj-$(CONFIG_SH_DMAE_DESC) += shdma-desc.o
+obj-$(CONFIG_SH_DMAEPP_BASE) += shdmapp-base.o
+obj-$(CONFIG_SH_DMAEPP_AUPP) += audma-pp.o
diff --git a/drivers/dma/sh/audma-pp.c b/drivers/dma/sh/audma-pp.c
new file mode 100644
index 0000000..0f2c782
--- /dev/null
+++ b/drivers/dma/sh/audma-pp.c
@@ -0,0 +1,337 @@
+/*
+ * drivers/dma/sh/audma-pp.c
+ *     This file is DMA Engine driver for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.c
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * base is drivers/dma/flsdma.c
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * - DMA of SuperH does not have Hardware DMA chain mode.
+ * - MAX DMA size is 16MB.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/platform_device.h>
+#include <linux/sh_audma-pp.h>
+#include <linux/kdebug.h>
+#include <linux/spinlock.h>
+#include <linux/rculist.h>
+
+#include "../dmaengine.h"
+#include "audma-pp.h"
+
+#define SH_DMAE_DRV_NAME "sh-audmapp-engine"
+
+/* Default MEMCPY transfer size = 2^2 = 4 bytes */
+#define LOG2_DEFAULT_XFER_SIZE	2
+#define SH_DMA_SLAVE_NUMBER 256
+#define SH_DMA_TCR_MAX (16 * 1024 * 1024 - 1)
+
+/*
+ * Used for write-side mutual exclusion for the global device list,
+ * read-side synchronization by way of RCU, and per-controller data.
+ */
+static DEFINE_SPINLOCK(sh_audmapp_lock);
+static LIST_HEAD(sh_audmapp_devices);
+
+static void sh_audmapp_writel(struct sh_audmapp_chan *sh_dc, u32 data, u32 reg)
+{
+	__raw_writel(data, sh_dc->base + reg / sizeof(u32));
+}
+
+static u32 sh_audmapp_readl(struct sh_audmapp_chan *sh_dc, u32 reg)
+{
+	return __raw_readl(sh_dc->base + reg / sizeof(u32));
+}
+
+static void dmae_start(struct sh_audmapp_chan *sh_chan)
+{
+	u32 chcr = sh_audmapp_readl(sh_chan, PDMACHCR);
+
+	sh_audmapp_writel(sh_chan, (chcr | PDMACHCR_DE), PDMACHCR);
+}
+
+static void dmae_halt(struct sh_audmapp_chan *sh_chan)
+{
+	u32 chcr = sh_audmapp_readl(sh_chan, PDMACHCR);
+
+	sh_audmapp_writel(sh_chan, (chcr & ~PDMACHCR_DE), PDMACHCR);
+}
+
+static const struct sh_audmapp_slave_config *dmae_find_slave(
+	struct sh_audmapp_chan *sh_chan, int slave_id)
+{
+	struct sh_audmapp_device *shdev = to_sh_dev(sh_chan);
+	struct sh_audmapp_pdata *pdata = shdev->pdata;
+	const struct sh_audmapp_slave_config *cfg;
+	int i;
+
+	if (slave_id >= SH_DMA_SLAVE_NUMBER)
+		return NULL;
+
+	for (i = 0, cfg = pdata->slave; i < pdata->slave_num; i++, cfg++)
+		if (cfg->slave_id == slave_id)
+			return cfg;
+
+	return NULL;
+}
+
+static int sh_audmapp_set_slave(struct shdma_chan *schan,
+			     int slave_id, bool try)
+{
+	struct sh_audmapp_chan *sh_chan =
+		container_of(schan, struct sh_audmapp_chan, shdma_chan);
+	const struct sh_audmapp_slave_config *cfg =
+		dmae_find_slave(sh_chan, slave_id);
+	if (!cfg)
+		return -ENODEV;
+
+	if (!try)
+		sh_chan->config = cfg;
+
+	sh_audmapp_writel(sh_chan, cfg->sar, PDMASAR);
+	sh_audmapp_writel(sh_chan, cfg->dar, PDMADAR);
+	sh_audmapp_writel(sh_chan, cfg->chcr, PDMACHCR);
+	dmae_start(sh_chan);
+
+	return 0;
+}
+
+static void sh_audmapp_halt(struct shdma_chan *schan)
+{
+	struct sh_audmapp_chan *sh_chan = container_of(schan,
+					struct sh_audmapp_chan, shdma_chan);
+	dmae_halt(sh_chan);
+}
+
+static int __devinit sh_audmapp_chan_probe(struct sh_audmapp_device *shdev,
+				int id, int irq, unsigned long flags)
+{
+	const struct sh_audmapp_channel *chan_pdata =
+						&shdev->pdata->channel[id];
+	struct shdma_dev *sdev = &shdev->shdma_dev;
+	struct platform_device *pdev = to_platform_device(sdev->dma_dev.dev);
+	struct sh_audmapp_chan *sh_chan;
+	struct shdma_chan *schan;
+
+	sh_chan = kzalloc(sizeof(struct sh_audmapp_chan), GFP_KERNEL);
+	if (!sh_chan) {
+		dev_err(sdev->dma_dev.dev,
+			"No free memory for allocating dma channels!\n");
+		return -ENOMEM;
+	}
+
+	schan = &sh_chan->shdma_chan;
+	schan->max_xfer_len = SH_DMA_TCR_MAX + 1;
+
+	shdmapp_chan_probe(sdev, schan, id);
+
+	sh_chan->base = shdev->chan_reg + chan_pdata->offset / sizeof(u32);
+
+	/* set up channel irq */
+	if (pdev->id >= 0)
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dmae%d.%d", pdev->id, id);
+	else
+		snprintf(sh_chan->dev_id, sizeof(sh_chan->dev_id),
+			 "sh-dma%d", id);
+
+	shdev->chan[id] = sh_chan;
+	return 0;
+}
+
+static void sh_audmapp_chan_remove(struct sh_audmapp_device *shdev)
+{
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct shdma_chan *schan;
+	int i;
+
+	shdma_for_each_chan(schan, &shdev->shdma_dev, i) {
+		struct sh_audmapp_chan *sh_chan = container_of(schan,
+					struct sh_audmapp_chan, shdma_chan);
+		BUG_ON(!schan);
+		shdmapp_chan_remove(schan);
+		kfree(sh_chan);
+	}
+	dma_dev->chancnt = 0;
+}
+
+static void sh_audmapp_shutdown(struct platform_device *pdev)
+{
+	return;
+}
+
+static const struct shdma_ops sh_audmapp_shdma_ops = {
+	.halt_channel = sh_audmapp_halt,
+	.set_slave = sh_audmapp_set_slave,
+};
+
+static int __devinit sh_audmapp_probe(struct platform_device *pdev)
+{
+	struct sh_audmapp_pdata *pdata = pdev->dev.platform_data;
+	unsigned long chan_flag[SH_AUDMAPP_MAX_CHANNELS] = {};
+	int chan_irq[SH_AUDMAPP_MAX_CHANNELS];
+	int err, i;
+	struct sh_audmapp_device *shdev;
+	struct dma_device *dma_dev;
+	struct resource *chan;
+
+	/* get platform data */
+	if (!pdata || !pdata->channel_num)
+		return -ENODEV;
+
+	chan = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!request_mem_region(chan->start, resource_size(chan), pdev->name)) {
+		dev_err(&pdev->dev, "DMAC register region already claimed\n");
+		return -EBUSY;
+	}
+
+	err = -ENOMEM;
+	shdev = kzalloc(sizeof(struct sh_audmapp_device), GFP_KERNEL);
+	if (!shdev) {
+		dev_err(&pdev->dev, "Not enough memory\n");
+		goto ealloc;
+	}
+
+	dma_dev = &shdev->shdma_dev.dma_dev;
+
+	shdev->chan_reg = ioremap(chan->start, resource_size(chan));
+	if (!shdev->chan_reg)
+		goto emapchan;
+
+	if (pdata->slave && pdata->slave_num)
+		dma_cap_set(DMA_SLAVE, dma_dev->cap_mask);
+
+	/* Default transfer size of 32 bytes requires 32-byte alignment */
+	dma_dev->copy_align = LOG2_DEFAULT_XFER_SIZE;
+
+	shdev->shdma_dev.ops = &sh_audmapp_shdma_ops;
+	shdev->shdma_dev.desc_size = sizeof(struct sh_audmapp_desc);
+
+	err = shdmapp_init(&pdev->dev, &shdev->shdma_dev,
+			      pdata->channel_num);
+	if (err < 0)
+		goto eshdma;
+
+	/* platform data */
+	shdev->pdata = pdev->dev.platform_data;
+
+	platform_set_drvdata(pdev, shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_add_tail_rcu(&shdev->node, &sh_audmapp_devices);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	/* Create DMA Channel */
+	for (i = 0; i < SH_AUDMAPP_MAX_CHANNELS; i++) {
+		err = sh_audmapp_chan_probe(shdev, i, chan_irq[i],
+								chan_flag[i]);
+		if (err)
+			goto chan_probe_err;
+	}
+
+	err = dma_async_device_register(&shdev->shdma_dev.dma_dev);
+	if (err < 0)
+		goto chan_probe_err;
+
+	return err;
+
+chan_probe_err:
+	sh_audmapp_chan_remove(shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	platform_set_drvdata(pdev, NULL);
+	shdmapp_cleanup(&shdev->shdma_dev);
+eshdma:
+	iounmap(shdev->chan_reg);
+	synchronize_rcu();
+emapchan:
+	kfree(shdev);
+ealloc:
+	release_mem_region(chan->start, resource_size(chan));
+
+	return err;
+}
+
+static int __devexit sh_audmapp_remove(struct platform_device *pdev)
+{
+	struct sh_audmapp_device *shdev = platform_get_drvdata(pdev);
+	struct dma_device *dma_dev = &shdev->shdma_dev.dma_dev;
+	struct resource *res;
+	int errirq = platform_get_irq(pdev, 0);
+
+	dma_async_device_unregister(dma_dev);
+
+	if (errirq > 0)
+		free_irq(errirq, shdev);
+
+	spin_lock_irq(&sh_audmapp_lock);
+	list_del_rcu(&shdev->node);
+	spin_unlock_irq(&sh_audmapp_lock);
+
+	sh_audmapp_chan_remove(shdev);
+	shdmapp_cleanup(&shdev->shdma_dev);
+
+	iounmap(shdev->chan_reg);
+
+	platform_set_drvdata(pdev, NULL);
+
+	synchronize_rcu();
+	kfree(shdev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	return 0;
+}
+
+static struct platform_driver aupp_dmae_driver = {
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= SH_DMAE_DRV_NAME,
+	},
+	.remove		= __devexit_p(sh_audmapp_remove),
+	.shutdown	= sh_audmapp_shutdown,
+};
+
+static int __init sh_audmapp_init(void)
+{
+	return platform_driver_probe(&aupp_dmae_driver, sh_audmapp_probe);
+}
+module_init(sh_audmapp_init);
+
+static void __exit sh_audmapp_exit(void)
+{
+	platform_driver_unregister(&aupp_dmae_driver);
+}
+module_exit(sh_audmapp_exit);
+
+MODULE_AUTHOR("Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>");
+MODULE_DESCRIPTION("Renesas SH DMA Engine driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" SH_DMAE_DRV_NAME);
diff --git a/drivers/dma/sh/audma-pp.h b/drivers/dma/sh/audma-pp.h
new file mode 100644
index 0000000..905523e
--- /dev/null
+++ b/drivers/dma/sh/audma-pp.h
@@ -0,0 +1,65 @@
+/*
+ * drivers/dma/sh/audma-pp.h
+ *     This file is header file for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.h
+ *
+ * Renesas SuperH DMA Engine support
+ *
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __DMA_AUDMAPP_H
+#define __DMA_AUDMAPP_H
+
+#include <linux/sh_audma-pp.h>
+#include <linux/shdmapp-base.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+
+#define SH_AUDMAPP_MAX_CHANNELS 29
+
+struct device;
+
+struct sh_audmapp_chan {
+	struct shdma_chan shdma_chan;
+	const struct sh_audmapp_slave_config *config;
+	u32 __iomem *base;
+	char dev_id[16];		/* unique name per DMAC of channel */
+};
+
+struct sh_audmapp_device {
+	struct shdma_dev shdma_dev;
+	struct sh_audmapp_chan *chan[SH_AUDMAPP_MAX_CHANNELS];
+	struct sh_audmapp_pdata *pdata;
+	struct list_head node;
+	u32 __iomem *chan_reg;
+};
+
+struct sh_audmapp_regs {
+	u32 sar;	/* SAR  / source address */
+	u32 dar;	/* DAR  / destination address */
+	u32 chcr;	/* CHCR / channel control */
+};
+
+struct sh_audmapp_desc {
+	struct sh_audmapp_regs hw;
+	struct shdma_desc shdma_desc;
+};
+
+#define to_sh_chan(chan) container_of(chan, struct sh_audmapp_chan, shdma_chan)
+#define to_sh_desc(lh) container_of(lh, struct sh_desc, node)
+#define tx_to_sh_desc(tx) container_of(tx, struct sh_desc, async_tx)
+#define to_sh_dev(chan) container_of(chan->shdma_chan.dma_chan.device,\
+				struct sh_audmapp_device, shdma_dev.dma_dev)
+
+#endif	/* __DMA_AUDMAPP_H */
diff --git a/drivers/dma/sh/shdmapp-base.c b/drivers/dma/sh/shdmapp-base.c
new file mode 100644
index 0000000..8be8b3e
--- /dev/null
+++ b/drivers/dma/sh/shdmapp-base.c
@@ -0,0 +1,245 @@
+/*
+ * drivers/dma/sh/shdmapp-base.c
+ *     This file is DMA Engine driver base library for DMAC that is
+ *     transferred between peripheral and peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the drivers/dma/sh/shdma.c
+ *
+ * Dmaengine driver base library for DMA controllers, found on SH-based SoCs
+ *
+ * extracted from shdma.c
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/shdma-base.h>
+#include <linux/dmaengine.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#include "../dmaengine.h"
+
+#define to_shdma_chan(c) container_of(c, struct shdma_chan, dma_chan)
+#define to_shdma_dev(d) container_of(d, struct shdma_dev, dma_dev)
+
+/*
+ * For slave DMA we assume, that there is a finite number of DMA slaves in the
+ * system, and that each such slave can only use a finite number of channels.
+ * We use slave channel IDs to make sure, that no such slave channel ID is
+ * allocated more than once.
+ */
+static unsigned int slave_num = 256;
+
+/* A bitmask with slave_num bits */
+static unsigned long *shdma_slave_used;
+
+static int shdmapp_setup_slave(struct shdma_chan *schan, int slave_id)
+{
+	struct shdma_dev *sdev = to_shdma_dev(schan->dma_chan.device);
+	const struct shdma_ops *ops = sdev->ops;
+	int ret;
+
+	if (slave_id < 0 || slave_id >= slave_num)
+		return -EINVAL;
+
+	if (test_and_set_bit(slave_id, shdma_slave_used))
+		return -EBUSY;
+
+	ret = ops->set_slave(schan, slave_id, false);
+	if (ret < 0) {
+		clear_bit(slave_id, shdma_slave_used);
+		return ret;
+	}
+
+	schan->slave_id = slave_id;
+
+	return 0;
+}
+
+static int shdmapp_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct shdma_chan *schan = to_shdma_chan(chan);
+	struct shdma_slave *slave = chan->private;
+	int ret;
+
+	/*
+	 * This relies on the guarantee from dmaengine that alloc_chan_resources
+	 * never runs concurrently with itself or free_chan_resources.
+	 */
+	if (slave) {
+		/* Legacy mode: .private is set in filter */
+		ret = shdmapp_setup_slave(schan, slave->slave_id);
+		if (ret < 0)
+			goto esetslave;
+	} else {
+		schan->slave_id = -EINVAL;
+	}
+
+	return 0;
+
+esetslave:
+	clear_bit(slave->slave_id, shdma_slave_used);
+	chan->private = NULL;
+	return ret;
+}
+
+static void shdmapp_free_chan_resources(struct dma_chan *chan)
+{
+	struct shdma_chan *schan = to_shdma_chan(chan);
+	struct shdma_dev *sdev = to_shdma_dev(chan->device);
+	const struct shdma_ops *ops = sdev->ops;
+	LIST_HEAD(list);
+
+	/* Protect against ISR */
+	spin_lock_irq(&schan->chan_lock);
+	ops->halt_channel(schan);
+	spin_unlock_irq(&schan->chan_lock);
+
+	if (schan->slave_id >= 0) {
+		/* The caller is holding dma_list_mutex */
+		clear_bit(schan->slave_id, shdma_slave_used);
+		chan->private = NULL;
+	}
+
+	spin_lock_irq(&schan->chan_lock);
+
+	list_splice_init(&schan->ld_free, &list);
+	schan->desc_num = 0;
+
+	spin_unlock_irq(&schan->chan_lock);
+
+	kfree(schan->desc);
+}
+
+static struct dma_async_tx_descriptor *shdmapp_prep_slave_sg(
+	struct dma_chan *chan, struct scatterlist *sgl, unsigned int sg_len,
+	enum dma_transfer_direction direction, unsigned long flags,
+	void *context)
+{
+	return NULL;
+}
+
+static int shdmapp_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			  unsigned long arg)
+{
+	return 0;
+}
+
+static void shdmapp_issue_pending(struct dma_chan *chan)
+{
+	return;
+}
+
+static enum dma_status shdmapp_tx_status(struct dma_chan *chan,
+			dma_cookie_t cookie, struct dma_tx_state *txstate)
+{
+	return DMA_IN_PROGRESS;
+}
+
+void shdmapp_chan_probe(struct shdma_dev *sdev,
+			   struct shdma_chan *schan, int id)
+{
+	schan->pm_state = SHDMA_PM_ESTABLISHED;
+
+	/* reference struct dma_device */
+	schan->dma_chan.device = &sdev->dma_dev;
+	dma_cookie_init(&schan->dma_chan);
+
+	schan->dev = sdev->dma_dev.dev;
+	schan->id = id;
+
+	if (!schan->max_xfer_len)
+		schan->max_xfer_len = PAGE_SIZE;
+
+	spin_lock_init(&schan->chan_lock);
+
+	/* Init descripter manage list */
+	INIT_LIST_HEAD(&schan->ld_queue);
+	INIT_LIST_HEAD(&schan->ld_free);
+
+	/* Add the channel to DMA device channel list */
+	list_add_tail(&schan->dma_chan.device_node,
+			&sdev->dma_dev.channels);
+	sdev->schan[sdev->dma_dev.chancnt++] = schan;
+}
+EXPORT_SYMBOL(shdmapp_chan_probe);
+
+void shdmapp_chan_remove(struct shdma_chan *schan)
+{
+	list_del(&schan->dma_chan.device_node);
+}
+EXPORT_SYMBOL(shdmapp_chan_remove);
+
+int shdmapp_init(struct device *dev, struct shdma_dev *sdev,
+		    int chan_num)
+{
+	struct dma_device *dma_dev = &sdev->dma_dev;
+
+	/*
+	 * Require all call-backs for now, they can trivially be made optional
+	 * later as required
+	 */
+	if (!sdev->ops || !sdev->ops->set_slave || !sdev->ops->halt_channel)
+		return -EINVAL;
+
+	sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL);
+	if (!sdev->schan)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&dma_dev->channels);
+
+	/* Common and MEMCPY operations */
+	dma_dev->device_alloc_chan_resources = shdmapp_alloc_chan_resources;
+	dma_dev->device_free_chan_resources = shdmapp_free_chan_resources;
+	dma_dev->device_tx_status = shdmapp_tx_status;
+	dma_dev->device_issue_pending = shdmapp_issue_pending;
+
+	/* Compulsory for DMA_SLAVE fields */
+	dma_dev->device_prep_slave_sg = shdmapp_prep_slave_sg;
+	dma_dev->device_control = shdmapp_control;
+
+	dma_dev->dev = dev;
+
+	return 0;
+}
+EXPORT_SYMBOL(shdmapp_init);
+
+void shdmapp_cleanup(struct shdma_dev *sdev)
+{
+	kfree(sdev->schan);
+}
+EXPORT_SYMBOL(shdmapp_cleanup);
+
+static int __init shdmapp_enter(void)
+{
+	shdma_slave_used = kzalloc(DIV_ROUND_UP(slave_num, BITS_PER_LONG) *
+				    sizeof(long), GFP_KERNEL);
+	if (!shdma_slave_used)
+		return -ENOMEM;
+	return 0;
+}
+module_init(shdmapp_enter);
+
+static void __exit shdmapp_exit(void)
+{
+	kfree(shdma_slave_used);
+}
+module_exit(shdmapp_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("SH-DMA driver base library");
+MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
diff --git a/include/linux/sh_audma-pp.h b/include/linux/sh_audma-pp.h
new file mode 100644
index 0000000..16dc7ba
--- /dev/null
+++ b/include/linux/sh_audma-pp.h
@@ -0,0 +1,58 @@
+/*
+ * include/linux/sh_audma-pp.h
+ *     This file is header file for Audio-DMAC-pp peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the include/linux/sh_dma.h
+ *
+ * Header for the new SH dmaengine driver
+ *
+ * Copyright (C) 2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef SH_AUDMAPP_H
+#define SH_AUDMAPP_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/shdma-base.h>
+#include <linux/types.h>
+
+struct device;
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct sh_audmapp_slave {
+	struct shdma_slave	shdma_slave;	/* Set by the platform */
+};
+
+struct sh_audmapp_slave_config {
+	int		slave_id;
+	dma_addr_t	sar;
+	dma_addr_t	dar;
+	u32		chcr;
+};
+
+struct sh_audmapp_channel {
+	unsigned int	offset;
+};
+
+struct sh_audmapp_pdata {
+	const struct sh_audmapp_slave_config *slave;
+	int slave_num;
+	const struct sh_audmapp_channel *channel;
+	int channel_num;
+};
+
+/* DMA register */
+#define PDMASAR		0x00
+#define PDMADAR		0x04
+#define PDMACHCR	0x0c
+
+/* PDMACHCR definitions */
+#define PDMACHCR_DE		(1<<0)
+
+#endif /* SH_AUDMAPP_H */
diff --git a/include/linux/shdmapp-base.h b/include/linux/shdmapp-base.h
new file mode 100644
index 0000000..ee2806e
--- /dev/null
+++ b/include/linux/shdmapp-base.h
@@ -0,0 +1,35 @@
+/*
+ * include/linux/shdmapp-base.h
+ *     This file is header file for DMA Engine driver base library of
+ *     DMAC that is transferred between peripheral and peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the include/linux/shdma-base.h
+ *
+ * Dmaengine driver base library for DMA controllers, found on SH-based SoCs
+ *
+ * extracted from shdma.c and headers
+ *
+ * Copyright (C) 2011-2012 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
+ * Copyright (C) 2009 Renesas Solutions, Inc. All rights reserved.
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SHDMAPP_BASE_H
+#define SHDMAPP_BASE_H
+
+#include <linux/shdma-base.h>
+
+void shdmapp_chan_probe(struct shdma_dev *sdev,
+			   struct shdma_chan *schan, int id);
+void shdmapp_chan_remove(struct shdma_chan *schan);
+int shdmapp_init(struct device *dev, struct shdma_dev *sdev, int chan_num);
+void shdmapp_cleanup(struct shdma_dev *sdev);
+
+#endif /* SHDMAPP_BASE_H */
-- 
1.8.3.2

