From b9bcabb3cc0d1e809bdd52d6768fd406b614f973 Mon Sep 17 00:00:00 2001
From: Yusuke Goda <yusuke.goda.sx@renesas.com>
Date: Tue, 2 Apr 2013 11:39:18 +0900
Subject: [PATCH 3/3] Local: ARM: shmobile: bockw: Add support USBH

Signed-off-by: Yusuke Goda <yusuke.goda.sx@renesas.com>
---
 arch/arm/mach-shmobile/Kconfig         |   2 +
 arch/arm/mach-shmobile/board-bockw.c   | 139 +++++++++++++++++++++++++++++++++
 arch/arm/mach-shmobile/clock-r8a7778.c |   8 +-
 3 files changed, 147 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 1f165bf..f7bd812 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -39,6 +39,8 @@ config ARCH_R8A7778
 	select CPU_V7
 	select SH_CLK_CPG
 	select ARM_GIC
+	select USB_ARCH_HAS_EHCI
+	select USB_ARCH_HAS_OHCI
 
 config ARCH_R8A7779
 	bool "R-Car H1 (R8A77790)"
diff --git a/arch/arm/mach-shmobile/board-bockw.c b/arch/arm/mach-shmobile/board-bockw.c
index 5422609..b761062 100644
--- a/arch/arm/mach-shmobile/board-bockw.c
+++ b/arch/arm/mach-shmobile/board-bockw.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
+#include <linux/delay.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -31,6 +32,8 @@
 #include <linux/mfd/tmio.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/usb/ehci_pdriver.h>
+#include <linux/usb/ohci_pdriver.h>
 #include <mach/irqs.h>
 #include <mach/common.h>
 #include <mach/r8a7778.h>
@@ -214,14 +217,148 @@ static struct platform_device sdhi0_device = {
 	.resource	= sdhi0_resources,
 };
 
+static struct usb_ehci_pdata ehcix_pdata = {
+};
+
+static struct resource ehci0_resources[] = {
+	[0] = {
+		.start	= 0xffe70000,
+		.end	= 0xffe70400 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_iid(0x4c),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ehci0_device = {
+	.name	= "ehci-platform",
+	.id	= 0,
+	.dev	= {
+		.dma_mask		= &ehci0_device.dev.coherent_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &ehcix_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(ehci0_resources),
+	.resource	= ehci0_resources,
+};
+
+static struct usb_ohci_pdata ohcix_pdata = {
+};
+
+static struct resource ohci0_resources[] = {
+	[0] = {
+		.start	= 0xffe70400,
+		.end	= 0xffe70800 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= gic_iid(0x4c),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device ohci0_device = {
+	.name	= "ohci-platform",
+	.id	= 0,
+	.dev	= {
+		.dma_mask		= &ohci0_device.dev.coherent_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &ohcix_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(ohci0_resources),
+	.resource	= ohci0_resources,
+};
+
+
 static struct platform_device *bockw_devices[] __initdata = {
 	&smsc911x_device,
 	&rcar_du_device,
 	&rcar_gp2d_device,
 	&nor_flash_device,
 	&sdhi0_device,
+	&ehci0_device,
+	&ohci0_device,
 };
 
+/* USBH common register */
+#define USBPCTRL0	0x0800
+#define USBPCTRL1	0x0804
+#define USBST		0x0808
+#define USBEH0		0x080C
+#define USBOH0		0x081C
+#define USBCTL0		0x0858
+#define EIIBC1		0x0094
+#define EIIBC2		0x009C
+
+/* USBPCTRL1 */
+#define PHY_RST		(1 << 2)
+#define PLL_ENB		(1 << 1)
+#define PHY_ENB		(1 << 0)
+
+/* USBST */
+#define ST_ACT		(1 << 31)
+#define ST_PLL		(1 << 30)
+static void rcar_usb_phy_init(void)
+{
+	void __iomem *reg0 = ioremap_nocache(0xffe70000, 0x900);
+	int i;
+	u32 val;
+
+	/*
+	 * USB phy start-up
+	 */
+
+	/* (1) USB-PHY standby release */
+	iowrite32(PHY_ENB, (reg0 + USBPCTRL1));
+
+	/* (2) start USB-PHY internal PLL */
+	iowrite32(PHY_ENB | PLL_ENB, (reg0 + USBPCTRL1));
+
+	/* (3) USB module status check */
+	for (i = 0; i < 1024; i++) {
+		udelay(10);
+		val = ioread32(reg0 + USBST);
+		if (val == (ST_ACT | ST_PLL))
+			break;
+	}
+
+	if (val != (ST_ACT | ST_PLL)) {
+		pr_err("USB phy not ready\n");
+		goto rcar_usb_phy_init_end;
+	}
+
+	/* (4) USB-PHY reset clear */
+	iowrite32(PHY_ENB | PLL_ENB | PHY_RST, (reg0 + USBPCTRL1));
+
+	/* set platform specific port settings */
+	iowrite32(0x00000000, (reg0 + USBPCTRL0));
+
+	/*
+	 * EHCI IP internal buffer setting
+	 * EHCI IP internal buffer enable
+	 *
+	 * These are recommended value of a datasheet
+	 * see [USB :: EHCI internal buffer setting]
+	 */
+	iowrite32(0x00ff0040, (reg0 + EIIBC1));
+	iowrite32(0x00000001, (reg0 + EIIBC2));
+
+	/*
+	 * Bus alignment settings
+	 */
+
+	/* (1) EHCI bus alignment (little endian) */
+	iowrite32(0x00000000, (reg0 + USBEH0));
+
+	/* (1) OHCI bus alignment (little endian) */
+	iowrite32(0x00000000, (reg0 + USBOH0));
+
+rcar_usb_phy_init_end:
+	iounmap(reg0);
+}
+
 #define IRQ0MR		FPGA(0x18200030)
 #define PUPR4		IOMEM(0xfffc0110)
 static void __init bockw_init(void)
@@ -285,6 +422,8 @@ static void __init bockw_init(void)
 	gpio_request(GPIO_FN_SD0_WP, NULL);
 	__raw_writel(__raw_readl(PUPR4) | (3 << 26), PUPR4);
 
+	rcar_usb_phy_init();
+
 	r8a7778_add_standard_devices();
 	platform_add_devices(bockw_devices, ARRAY_SIZE(bockw_devices));
 }
diff --git a/arch/arm/mach-shmobile/clock-r8a7778.c b/arch/arm/mach-shmobile/clock-r8a7778.c
index 34e2495..0ea27b1 100644
--- a/arch/arm/mach-shmobile/clock-r8a7778.c
+++ b/arch/arm/mach-shmobile/clock-r8a7778.c
@@ -104,14 +104,16 @@ static struct clk div4_clks[DIV4_NR] = {
 				      0x0300, CLK_ENABLE_ON_INIT),
 };
 
-enum { MSTP323, MSTP107, MSTP103, MSTP026, MSTP025, MSTP024, MSTP023, MSTP022,
-	MSTP021, MSTP016, MSTP015, MSTP014,
+enum { MSTP323, MSTP107, MSTP103, MSTP100,
+	MSTP026, MSTP025, MSTP024, MSTP023, MSTP022, MSTP021,
+	MSTP016, MSTP015, MSTP014,
 	MSTP_NR };
 
 static struct clk mstp_clks[MSTP_NR] = {
 	[MSTP323] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 23, 0), /* SDHI0 */
 	[MSTP107] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1,  7, 0), /* GP2D */
 	[MSTP103] = SH_CLK_MSTP32(&div4_clks[DIV4_S], MSTPCR1,  3, 0), /* DU */
+	[MSTP100] = SH_CLK_MSTP32(&div4_clks[DIV4_S], MSTPCR1,  0, CLK_ENABLE_ON_INIT), /* USB */
 	[MSTP026] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 26, 0), /* SCIF0 */
 	[MSTP025] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 25, 0), /* SCIF1 */
 	[MSTP024] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 24, 0), /* SCIF2 */
@@ -148,6 +150,8 @@ static struct clk_lookup lookups[] = {
 	CLKDEV_DEV_ID("sh-sci.3",	&mstp_clks[MSTP023]), /* SCIF3 */
 	CLKDEV_DEV_ID("sh-sci.4",	&mstp_clks[MSTP022]), /* SCIF4 */
 	CLKDEV_DEV_ID("sh-sci.5",	&mstp_clks[MSTP021]), /* SCIF6 */
+	CLKDEV_DEV_ID("ehci-platform.0", &mstp_clks[MSTP100]), /* USB EHCI port0 */
+	CLKDEV_DEV_ID("ohci-platform.0", &mstp_clks[MSTP100]), /* USB OHCI port0 */
 };
 
 void __init r8a7778_clock_init(void)
-- 
1.8.2

