From 2890d4d3e05bed67cb66a693d8ef52f848ffce62 Mon Sep 17 00:00:00 2001
From: Kazunori Kobayashi <kkobayas@igel.co.jp>
Date: Thu, 7 Mar 2013 15:53:06 +0900
Subject: [PATCH 575/675] drm: gp2d: DRM Support for Renesas R-Car GP2D

---
 drivers/gpu/drm/Kconfig              |    2 +
 drivers/gpu/drm/Makefile             |    1 +
 drivers/gpu/drm/gp2d/Kconfig         |    7 +
 drivers/gpu/drm/gp2d/Makefile        |    9 +
 drivers/gpu/drm/gp2d/gp2d_drm_buf.c  |  214 +++++++
 drivers/gpu/drm/gp2d/gp2d_drm_buf.h  |   47 ++
 drivers/gpu/drm/gp2d/gp2d_drm_core.c |   61 ++
 drivers/gpu/drm/gp2d/gp2d_drm_drv.c  |  409 ++++++++++++
 drivers/gpu/drm/gp2d/gp2d_drm_drv.h  |  104 ++++
 drivers/gpu/drm/gp2d/gp2d_drm_gem.c  | 1125 ++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/gp2d/gp2d_drm_gem.h  |  163 +++++
 drivers/gpu/drm/gp2d/regs-gp2d.h     |   91 +++
 include/drm/gp2d_drm.h               |  131 ++++
 13 files changed, 2364 insertions(+)
 create mode 100644 drivers/gpu/drm/gp2d/Kconfig
 create mode 100644 drivers/gpu/drm/gp2d/Makefile
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_buf.c
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_buf.h
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_core.c
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_drv.c
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_drv.h
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_gem.c
 create mode 100644 drivers/gpu/drm/gp2d/gp2d_drm_gem.h
 create mode 100644 drivers/gpu/drm/gp2d/regs-gp2d.h
 create mode 100644 include/drm/gp2d_drm.h

diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index 767edb3..bf5d935 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -196,6 +196,8 @@ config DRM_SAVAGE
 
 source "drivers/gpu/drm/exynos/Kconfig"
 
+source "drivers/gpu/drm/gp2d/Kconfig"
+
 source "drivers/gpu/drm/vmwgfx/Kconfig"
 
 source "drivers/gpu/drm/gma500/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index c1ca0bf..1c78753 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_DRM_VMWGFX)+= vmwgfx/
 obj-$(CONFIG_DRM_VIA)	+=via/
 obj-$(CONFIG_DRM_NOUVEAU) +=nouveau/
 obj-$(CONFIG_DRM_EXYNOS) +=exynos/
+obj-$(CONFIG_DRM_GP2D) +=gp2d/
 obj-$(CONFIG_DRM_GMA500) += gma500/
 obj-$(CONFIG_DRM_UDL) += udl/
 obj-y			+= i2c/
diff --git a/drivers/gpu/drm/gp2d/Kconfig b/drivers/gpu/drm/gp2d/Kconfig
new file mode 100644
index 0000000..758c3bb
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/Kconfig
@@ -0,0 +1,7 @@
+config DRM_GP2D
+	tristate "DRM Support for Renesas R-Car GP2D"
+	depends on DRM && MACH_BOCKW
+	help
+	  Choose this option if you have a Renesas R-Car GP2D core.
+	  If M is selected the module will be called gp2ddrm.
+
diff --git a/drivers/gpu/drm/gp2d/Makefile b/drivers/gpu/drm/gp2d/Makefile
new file mode 100644
index 0000000..1714b81
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the drm device driver.  This driver provides support for the
+# Direct Rendering Infrastructure (DRI) in XFree86 4.1.0 and higher.
+
+ccflags-y := -Iinclude/drm -Idrivers/gpu/drm/gp2d
+gp2ddrm-y := gp2d_drm_drv.o gp2d_drm_buf.o gp2d_drm_gem.o gp2d_drm_core.o
+
+obj-$(CONFIG_DRM_GP2D)		+= gp2ddrm.o
+
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_buf.c b/drivers/gpu/drm/gp2d/gp2d_drm_buf.c
new file mode 100644
index 0000000..36b6ef6
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_buf.c
@@ -0,0 +1,214 @@
+/* gp2d_drm_buf.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Author: Inki Dae <inki.dae@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <drm/drmP.h>
+
+#include "gp2d_drm.h"
+
+#include "gp2d_drm_drv.h"
+#include "gp2d_drm_gem.h"
+#include "gp2d_drm_buf.h"
+
+static int lowlevel_buffer_allocate(struct drm_device *dev,
+		unsigned int flags, struct gp2d_drm_gem_buf *buf)
+{
+	dma_addr_t start_addr;
+	unsigned int npages, page_size, i = 0;
+	struct scatterlist *sgl;
+	int ret = 0;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (IS_NONCONTIG_BUFFER(flags)) {
+		DRM_DEBUG_KMS("not support allocation type.\n");
+		return -EINVAL;
+	}
+
+	if (buf->dma_addr) {
+		DRM_DEBUG_KMS("already allocated.\n");
+		return 0;
+	}
+
+	if (buf->size >= SZ_1M) {
+		npages = buf->size >> SECTION_SHIFT;
+		page_size = SECTION_SIZE;
+	} else if (buf->size >= SZ_64K) {
+		npages = buf->size >> 16;
+		page_size = SZ_64K;
+	} else {
+		npages = buf->size >> PAGE_SHIFT;
+		page_size = PAGE_SIZE;
+	}
+
+	buf->sgt = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!buf->sgt) {
+		DRM_ERROR("failed to allocate sg table.\n");
+		return -ENOMEM;
+	}
+
+	ret = sg_alloc_table(buf->sgt, npages, GFP_KERNEL);
+	if (ret < 0) {
+		DRM_ERROR("failed to initialize sg table.\n");
+		kfree(buf->sgt);
+		buf->sgt = NULL;
+		return -ENOMEM;
+	}
+
+	dev->dev->coherent_dma_mask = ~0;
+	buf->kvaddr = dma_alloc_coherent(dev->dev, buf->size,
+			&buf->dma_addr, GFP_KERNEL);
+	if (!buf->kvaddr) {
+		DRM_ERROR("failed to allocate buffer.\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	buf->pages = kzalloc(sizeof(struct page) * npages, GFP_KERNEL);
+	if (!buf->pages) {
+		DRM_ERROR("failed to allocate pages.\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	sgl = buf->sgt->sgl;
+	start_addr = buf->dma_addr;
+
+	while (i < npages) {
+		buf->pages[i] = phys_to_page(start_addr);
+		sg_set_page(sgl, buf->pages[i], page_size, 0);
+		sg_dma_address(sgl) = start_addr;
+		start_addr += page_size;
+		sgl = sg_next(sgl);
+		i++;
+	}
+
+	DRM_DEBUG_KMS("vaddr(0x%lx), dma_addr(0x%lx), size(0x%lx)\n",
+			(unsigned long)buf->kvaddr,
+			(unsigned long)buf->dma_addr,
+			buf->size);
+
+	return ret;
+err2:
+	dma_free_writecombine(dev->dev, buf->size, buf->kvaddr,
+			(dma_addr_t)buf->dma_addr);
+	buf->dma_addr = (dma_addr_t)NULL;
+err1:
+	sg_free_table(buf->sgt);
+	kfree(buf->sgt);
+	buf->sgt = NULL;
+
+	return ret;
+}
+
+static void lowlevel_buffer_deallocate(struct drm_device *dev,
+		unsigned int flags, struct gp2d_drm_gem_buf *buf)
+{
+	DRM_DEBUG_KMS("%s.\n", __FILE__);
+
+	/*
+	 * release only physically continuous memory and
+	 * non-continuous memory would be released by gp2d
+	 * gem framework.
+	 */
+	if (IS_NONCONTIG_BUFFER(flags)) {
+		DRM_DEBUG_KMS("not support allocation type.\n");
+		return;
+	}
+
+	if (!buf->dma_addr) {
+		DRM_DEBUG_KMS("dma_addr is invalid.\n");
+		return;
+	}
+
+	DRM_DEBUG_KMS("vaddr(0x%lx), dma_addr(0x%lx), size(0x%lx)\n",
+			(unsigned long)buf->kvaddr,
+			(unsigned long)buf->dma_addr,
+			buf->size);
+
+	sg_free_table(buf->sgt);
+
+	kfree(buf->sgt);
+	buf->sgt = NULL;
+
+	kfree(buf->pages);
+	buf->pages = NULL;
+
+	dma_free_writecombine(dev->dev, buf->size, buf->kvaddr,
+				(dma_addr_t)buf->dma_addr);
+	buf->dma_addr = (dma_addr_t)NULL;
+}
+
+struct gp2d_drm_gem_buf *gp2d_drm_init_buf(struct drm_device *dev,
+						unsigned int size)
+{
+	struct gp2d_drm_gem_buf *buffer;
+
+	DRM_DEBUG_KMS("%s.\n", __FILE__);
+	DRM_DEBUG_KMS("desired size = 0x%x\n", size);
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer) {
+		DRM_ERROR("failed to allocate gp2d_drm_gem_buf.\n");
+		return NULL;
+	}
+
+	buffer->size = size;
+	return buffer;
+}
+
+void gp2d_drm_fini_buf(struct drm_device *dev,
+				struct gp2d_drm_gem_buf *buffer)
+{
+	DRM_DEBUG_KMS("%s.\n", __FILE__);
+
+	if (!buffer) {
+		DRM_DEBUG_KMS("buffer is null.\n");
+		return;
+	}
+
+	kfree(buffer);
+	buffer = NULL;
+}
+
+int gp2d_drm_alloc_buf(struct drm_device *dev,
+		struct gp2d_drm_gem_buf *buf, unsigned int flags)
+{
+
+	/*
+	 * allocate memory region and set the memory information
+	 * to vaddr and dma_addr of a buffer object.
+	 */
+	if (lowlevel_buffer_allocate(dev, flags, buf) < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void gp2d_drm_free_buf(struct drm_device *dev,
+		unsigned int flags, struct gp2d_drm_gem_buf *buffer)
+{
+
+	lowlevel_buffer_deallocate(dev, flags, buffer);
+}
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_buf.h b/drivers/gpu/drm/gp2d/gp2d_drm_buf.h
new file mode 100644
index 0000000..14e8bdd
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_buf.h
@@ -0,0 +1,47 @@
+/* gp2d_drm_buf.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Author: Inki Dae <inki.dae@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _GP2D_DRM_BUF_H_
+#define _GP2D_DRM_BUF_H_
+
+/* create and initialize buffer object. */
+struct gp2d_drm_gem_buf *gp2d_drm_init_buf(struct drm_device *dev,
+						unsigned int size);
+
+/* destroy buffer object. */
+void gp2d_drm_fini_buf(struct drm_device *dev,
+				struct gp2d_drm_gem_buf *buffer);
+
+/* allocate physical memory region and setup sgt and pages. */
+int gp2d_drm_alloc_buf(struct drm_device *dev,
+				struct gp2d_drm_gem_buf *buf,
+				unsigned int flags);
+
+/* release physical memory region, sgt and pages. */
+void gp2d_drm_free_buf(struct drm_device *dev,
+				unsigned int flags,
+				struct gp2d_drm_gem_buf *buffer);
+
+#endif
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_core.c b/drivers/gpu/drm/gp2d/gp2d_drm_core.c
new file mode 100644
index 0000000..84c5e83
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_core.c
@@ -0,0 +1,61 @@
+/* gp2d_drm_core.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Author:
+ *	Inki Dae <inki.dae@samsung.com>
+ *	Joonyoung Shim <jy0922.shim@samsung.com>
+ *	Seung-Woo Kim <sw0312.kim@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "drmP.h"
+#include "gp2d_drm_drv.h"
+
+static struct drm_device *drm_dev;
+
+
+int gp2d_drm_device_register(struct drm_device *dev)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	if (!dev)
+		return -EINVAL;
+
+	drm_dev = dev;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gp2d_drm_device_register);
+
+int gp2d_drm_device_unregister(struct drm_device *dev)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	if (!dev) {
+		WARN(1, "Unexpected drm device unregister!\n");
+		return -EINVAL;
+	}
+
+	drm_dev = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gp2d_drm_device_unregister);
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_drv.c b/drivers/gpu/drm/gp2d/gp2d_drm_drv.c
new file mode 100644
index 0000000..c763f6c
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_drv.c
@@ -0,0 +1,409 @@
+/*
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Authors:
+ *	Inki Dae <inki.dae@samsung.com>
+ *	Joonyoung Shim <jy0922.shim@samsung.com>
+ *	Seung-Woo Kim <sw0312.kim@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <drm/drmP.h>
+//#include "drm_crtc_helper.h"
+
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+
+#include <drm/gp2d_drm.h>
+
+#include "gp2d_drm_drv.h"
+#include "gp2d_drm_gem.h"
+
+#define DRIVER_NAME	"gp2d"
+#define DRIVER_DESC	"Renesas R-Car GP2D DRM"
+#define DRIVER_DATE	"20130112"
+#define DRIVER_MAJOR	0
+#define DRIVER_MINOR	1
+
+#define FRQMR   0xffc80014
+#define MSTPCR0 0xffc80030
+#define MSTPCR1 0xffc80034
+#define MSTPCR2 0xffc80038
+#define MSTPCR3 0xffc8003c
+#define MSTPSR1 0xffc80044
+#define MSTPSR4 0xffc80048
+#define MSTPSR6 0xffc8004c
+#define MSTPCR4 0xffc80050
+#define MSTPCR5 0xffc80054
+#define MSTPCR6 0xffc80058
+#define MSTPCR7 0xffc80040
+
+
+#ifdef GP2D_IRQ_POLLER
+
+static void test_reg(struct gp2d_drm_private *private,const char *name,unsigned long offset, int start, int stop)
+{
+	int i;
+
+	for (i=start; i<=stop; i++) {
+		if (readl(offset) & (1 << i))
+		    continue;
+
+		printk( "test %s - %d...\n", name, i );
+
+		schedule_timeout( 1 );
+
+		writel( readl( offset ) | 1 << i, offset );
+
+		schedule_timeout( 1 );
+
+		GP2D_SCLR = GP2D_SCLR_RESET;
+		udelay( 5 );
+		GP2D_SCLR = 0;
+
+		schedule_timeout( 1 );
+
+		printk( "STATUS 0x%08x\n", GP2D_STATUS );
+
+		schedule_timeout( 1 );
+	}
+}
+
+static int
+gp2d_irq_poller( void *arg )
+{
+	struct gp2d_drm_private *private = arg;
+
+	daemonize( "%s", __FUNCTION__ );
+
+     sigfillset( &current->blocked );
+
+//	schedule_timeout( 20 * HZ );
+//
+//	test_reg( private, "MSTPCR0", MSTPCR0, 0, 31 );
+//	test_reg( private, "MSTPCR1", MSTPCR1, 2, 31 );
+//	test_reg( private, "MSTPCR2", MSTPCR2, 0, 31 );
+//	test_reg( private, "MSTPCR3", MSTPCR3, 0, 31 );
+//	test_reg( private, "MSTPCR4", MSTPCR4, 0, 31 );
+//	test_reg( private, "MSTPCR5", MSTPCR5, 0, 31 );
+//	test_reg( private, "MSTPCR6", MSTPCR6, 0, 31 );
+//	test_reg( private, "MSTPCR7", MSTPCR7, 0, 31 );
+//	test_reg( private, "FRQMR",   FRQMR,   0, 31 );
+
+	while (!private->stop_poller) {
+          set_current_state( TASK_UNINTERRUPTIBLE );
+          schedule_timeout( 1 );
+
+          gp2d_irq_handler( private->irq, (void*) arg );
+     }
+
+     private->stop_poller = 0;
+
+     return 0;
+}
+#endif
+
+
+static void stop_irq(struct gp2d_drm_private *private)
+{
+#ifdef GP2D_IRQ_POLLER
+	private->stop_poller = 1;
+
+     while (private->stop_poller) {
+          set_current_state( TASK_UNINTERRUPTIBLE );
+          schedule_timeout( 1 );
+     }
+#else
+     free_irq( private->irq, private );
+#endif
+}
+
+
+static int gp2d_drm_load(struct drm_device *dev, unsigned long flags)
+{
+	struct gp2d_drm_private *private;
+	struct resource *res;
+	int ret;
+
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	private = kzalloc(sizeof(struct gp2d_drm_private), GFP_KERNEL);
+	if (!private) {
+		DRM_ERROR("failed to allocate private\n");
+		return -ENOMEM;
+	}
+
+	private->device = dev;
+
+	init_waitqueue_head(&private->wq);
+	INIT_LIST_HEAD(&private->executions);
+
+	dev->dev_private = (void *)private;
+
+	drm_mode_config_init(dev);
+
+	/* init kms poll for handling hpd */
+//	drm_kms_helper_poll_init(dev);
+
+	/*
+	 * probe sub drivers such as display controller and hdmi driver,
+	 * that were registered at probe() of platform driver
+	 * to the sub driver and create encoder and connector for them.
+	 */
+	ret = gp2d_drm_device_register(dev);
+	if (ret)
+		goto err_alloc;
+
+	res = platform_get_resource(dev->platformdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		DRM_ERROR("failed to find registers\n");
+		ret = -ENOENT;
+		goto err_drm_device;
+	}
+
+	private->regs = (unsigned long) devm_request_and_ioremap(dev->dev, res);
+	if (!private->regs) {
+		dev_err(dev->dev, "ioremap error.\n");
+		ret = -ENOMEM;
+		goto err_drm_device;
+	}
+
+	res = platform_get_resource(dev->platformdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		DRM_ERROR("failed to find irq number\n");
+		ret = -ENOENT;
+		goto err_drm_device;
+	}
+
+	private->irq = res->start;
+
+#ifdef GP2D_IRQ_POLLER
+     kernel_thread( gp2d_irq_poller, private, CLONE_KERNEL );
+#else
+	ret = request_irq(private->irq, gp2d_irq_handler, 0, "gp2d", private);
+	if (ret) {
+		DRM_ERROR("request interrupt failed.\n");
+		goto err_drm_device;
+	}
+#endif
+
+
+	/* enable clock */
+	pm_runtime_enable(dev->dev);
+	pm_runtime_get_sync(dev->dev);
+
+#if 0
+	volatile u32 *resetregs = ioremap( 0xffcc0000, 4096 );
+
+	resetregs[0x2c/4] = resetregs[0x2c/4] | 0x80;
+	//writel( readl(0xffcc002c) | 0x80, 0xffcc002c );
+	udelay( 5 );
+	resetregs[0x2c/4] = resetregs[0x2c/4] & ~0x80;
+	//writel( readl(0xffcc002c) & ~0x80, 0xffcc002c );
+#endif
+
+//	QPRINT( "Resetting hardware..." );
+
+	GP2D_SCLR = GP2D_SCLR_RESET;
+	udelay( 5 );
+	GP2D_SCLR = 0;
+
+//	QPRINT( "Clearing interrupts..." );
+
+	GP2D_STATUS_CLEAR = GP2D_INT_ANY;
+
+	GP2D_INT_ENABLE   = GP2D_INT_ANY;
+
+//	QDUMP( "Ready" );
+
+	printk( "GP2D STATUS 0x%08x\n", GP2D_STATUS );
+
+	return 0;
+
+
+err_irq:
+	stop_irq(private);
+err_drm_device:
+	gp2d_drm_device_unregister(dev);
+err_alloc:
+	kfree(private);
+
+	return ret;
+}
+
+static int gp2d_drm_unload(struct drm_device *dev)
+{
+	struct gp2d_drm_private *private = dev->dev_private;
+
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	stop_irq(private);
+
+	gp2d_drm_device_unregister(dev);
+//	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+	kfree(dev->dev_private);
+
+	dev->dev_private = NULL;
+
+	return 0;
+}
+
+static void gp2d_drm_preclose(struct drm_device *dev,
+					struct drm_file *file)
+{
+	struct gp2d_drm_private *private = dev->dev_private;
+	struct gp2d_execution *e, *t;
+	unsigned long flags;
+
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	wait_event_interruptible_timeout( private->wq, !private->busy, 10 * HZ );
+
+	/* release events of current file */
+	spin_lock_irqsave(&dev->event_lock, flags);
+	list_for_each_entry_safe(e, t, &private->executions, link) {
+		if (e->event.base.file_priv == file) {
+			list_del(&e->event.base.link);
+			e->event.base.destroy(&e->event.base);
+		}
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+}
+
+static void gp2d_drm_postclose(struct drm_device *dev, struct drm_file *file)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	if (!file->driver_priv)
+		return;
+
+	kfree(file->driver_priv);
+	file->driver_priv = NULL;
+}
+
+static struct vm_operations_struct gp2d_drm_gem_vm_ops = {
+	.fault = gp2d_drm_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static struct drm_ioctl_desc gp2d_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(GP2D_GEM_CREATE, gp2d_drm_gem_create_ioctl,
+			DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(GP2D_GEM_MAP_OFFSET,
+			gp2d_drm_gem_map_offset_ioctl, DRM_UNLOCKED |
+			DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(GP2D_GEM_MMAP,
+			gp2d_drm_gem_mmap_ioctl, DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(GP2D_GEM_EXECUTE,
+			gp2d_drm_gem_execute_ioctl, DRM_UNLOCKED | DRM_AUTH),
+	DRM_IOCTL_DEF_DRV(GP2D_WAITIDLE,
+			gp2d_drm_waitidle_ioctl, DRM_UNLOCKED | DRM_AUTH),
+};
+
+static const struct file_operations gp2d_drm_driver_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.mmap		= gp2d_drm_gem_mmap,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.unlocked_ioctl	= drm_ioctl,
+	.release	= drm_release,
+};
+
+static struct drm_driver gp2d_drm_driver = {
+	.driver_features	= DRIVER_HAVE_IRQ | DRIVER_BUS_PLATFORM |
+				  DRIVER_MODESET | DRIVER_GEM,
+	.load			= gp2d_drm_load,
+	.unload			= gp2d_drm_unload,
+	.preclose		= gp2d_drm_preclose,
+	.postclose		= gp2d_drm_postclose,
+	.gem_init_object	= gp2d_drm_gem_init_object,
+	.gem_free_object	= gp2d_drm_gem_free_object,
+	.gem_vm_ops		= &gp2d_drm_gem_vm_ops,
+	.dumb_create		= gp2d_drm_gem_dumb_create,
+	.dumb_map_offset	= gp2d_drm_gem_dumb_map_offset,
+	.dumb_destroy		= gp2d_drm_gem_dumb_destroy,
+	.ioctls			= gp2d_ioctls,
+	.fops			= &gp2d_drm_driver_fops,
+	.name	= DRIVER_NAME,
+	.desc	= DRIVER_DESC,
+	.date	= DRIVER_DATE,
+	.major	= DRIVER_MAJOR,
+	.minor	= DRIVER_MINOR,
+};
+
+static int gp2d_drm_platform_probe(struct platform_device *pdev)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	gp2d_drm_driver.num_ioctls = DRM_ARRAY_SIZE(gp2d_ioctls);
+
+	return drm_platform_init(&gp2d_drm_driver, pdev);
+}
+
+static int gp2d_drm_platform_remove(struct platform_device *pdev)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	drm_platform_exit(&gp2d_drm_driver, pdev);
+
+	return 0;
+}
+
+static struct platform_driver gp2d_drm_platform_driver = {
+	.probe		= gp2d_drm_platform_probe,
+	.remove		= gp2d_drm_platform_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "gp2d",
+	},
+};
+
+static int __init gp2d_drm_init(void)
+{
+	int ret;
+
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	ret = platform_driver_register(&gp2d_drm_platform_driver);
+	if (ret < 0)
+		goto out;
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static void __exit gp2d_drm_exit(void)
+{
+	DRM_DEBUG_DRIVER("%s\n", __FILE__);
+
+	platform_driver_unregister(&gp2d_drm_platform_driver);
+}
+
+module_init(gp2d_drm_init);
+module_exit(gp2d_drm_exit);
+
+MODULE_AUTHOR("Denis Oliver Kropp <dok@directfb.org>");
+MODULE_DESCRIPTION("Renesas R-Car GP2D DRM Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_drv.h b/drivers/gpu/drm/gp2d/gp2d_drm_drv.h
new file mode 100644
index 0000000..8f14248
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_drv.h
@@ -0,0 +1,104 @@
+/* gp2d_drm_drv.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Authors:
+ *	Inki Dae <inki.dae@samsung.com>
+ *	Joonyoung Shim <jy0922.shim@samsung.com>
+ *	Seung-Woo Kim <sw0312.kim@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _GP2D_DRM_DRV_H_
+#define _GP2D_DRM_DRV_H_
+
+#include <linux/module.h>
+#include <drm/drmP.h>
+
+#include <drm/gp2d_drm.h>
+
+
+//#define GP2D_IRQ_POLLER
+
+
+struct drm_device;
+
+
+#define GP2D_REG(x)      (*(volatile u32*)((x)+(long)private->regs))
+
+#define	GP2D_SCLR             GP2D_REG(0x000)
+#define	GP2D_DLSAR            GP2D_REG(0x048)
+#define	GP2D_ADREXTR          GP2D_REG(0x06c)
+
+
+#define GP2D_STATUS           GP2D_REG(0x004)
+#define GP2D_STATUS_CLEAR     GP2D_REG(0x008)
+#define GP2D_INT_ENABLE       GP2D_REG(0x00c)
+
+#define GP2D_SCLR_START       0x00000001
+#define GP2D_SCLR_RESET       0x80000000
+
+#define GP2D_INT_TRAP         0x0001
+#define GP2D_INT_INTERRUPT    0x0002
+#define GP2D_INT_ERROR        0x0004
+#define GP2D_INT_BREAK        0x0008
+#define GP2D_INT_ANY          0x000F
+
+
+/*
+ * GP2D drm private structure.
+ */
+struct gp2d_drm_private {
+     struct drm_device *device;
+
+     unsigned long regs;
+     int irq;
+     int busy;
+     wait_queue_head_t wq;
+     int stop_poller;
+
+	struct list_head executions;
+};
+
+struct gp2d_executed_pending_event {
+	struct drm_pending_event 	 base;
+	struct drm_gp2d_event_executed event;
+};
+
+struct gp2d_execution {
+	struct gp2d_executed_pending_event event;
+	struct list_head				link;
+	struct gp2d_drm_gem_buf 		    *buffer;
+	struct drm_gem_object		    *obj;
+};
+
+/*
+ * this function calls a probe callback registered to sub driver list and
+ * create its own encoder and connector and then set drm_device object
+ * to global one.
+ */
+int gp2d_drm_device_register(struct drm_device *dev);
+/*
+ * this function calls a remove callback registered to sub driver list and
+ * destroy its own encoder and connetor.
+ */
+int gp2d_drm_device_unregister(struct drm_device *dev);
+
+#endif
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_gem.c b/drivers/gpu/drm/gp2d/gp2d_drm_gem.c
new file mode 100644
index 0000000..f1a7a48
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_gem.c
@@ -0,0 +1,1125 @@
+/* gp2d_drm_gem.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Author: Inki Dae <inki.dae@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <drm/drmP.h>
+
+#include <linux/dma-buf.h>
+#include <linux/shmem_fs.h>
+#include <drm/gp2d_drm.h>
+
+#include "gp2d_drm_drv.h"
+#include "gp2d_drm_gem.h"
+#include "gp2d_drm_buf.h"
+
+static unsigned int convert_to_vm_err_msg(int msg)
+{
+	unsigned int out_msg;
+
+	switch (msg) {
+	case 0:
+	case -ERESTARTSYS:
+	case -EINTR:
+		out_msg = VM_FAULT_NOPAGE;
+		break;
+
+	case -ENOMEM:
+		out_msg = VM_FAULT_OOM;
+		break;
+
+	default:
+		out_msg = VM_FAULT_SIGBUS;
+		break;
+	}
+
+	return out_msg;
+}
+
+static int check_gem_flags(unsigned int flags)
+{
+	if (flags & ~(GP2D_BO_MASK)) {
+		DRM_ERROR("invalid flags.\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned long roundup_gem_size(unsigned long size, unsigned int flags)
+{
+	if (!IS_NONCONTIG_BUFFER(flags)) {
+		if (size >= SZ_1M)
+			return roundup(size, SECTION_SIZE);
+		else if (size >= SZ_64K)
+			return roundup(size, SZ_64K);
+		else
+			goto out;
+	}
+out:
+	return roundup(size, PAGE_SIZE);
+}
+
+static struct page **gp2d_gem_get_pages(struct drm_gem_object *obj,
+						gfp_t gfpmask)
+{
+	struct inode *inode;
+	struct address_space *mapping;
+	struct page *p, **pages;
+	int i, npages;
+
+	/* This is the shared memory object that backs the GEM resource */
+	inode = obj->filp->f_path.dentry->d_inode;
+	mapping = inode->i_mapping;
+
+	npages = obj->size >> PAGE_SHIFT;
+
+	pages = drm_malloc_ab(npages, sizeof(struct page *));
+	if (pages == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	gfpmask |= mapping_gfp_mask(mapping);
+
+	for (i = 0; i < npages; i++) {
+		p = shmem_read_mapping_page_gfp(mapping, i, gfpmask);
+		if (IS_ERR(p))
+			goto fail;
+		pages[i] = p;
+	}
+
+	return pages;
+
+fail:
+	while (i--)
+		page_cache_release(pages[i]);
+
+	drm_free_large(pages);
+	return ERR_PTR(PTR_ERR(p));
+}
+
+static void gp2d_gem_put_pages(struct drm_gem_object *obj,
+					struct page **pages,
+					bool dirty, bool accessed)
+{
+	int i, npages;
+
+	npages = obj->size >> PAGE_SHIFT;
+
+	for (i = 0; i < npages; i++) {
+		if (dirty)
+			set_page_dirty(pages[i]);
+
+		if (accessed)
+			mark_page_accessed(pages[i]);
+
+		/* Undo the reference we took when populating the table */
+		page_cache_release(pages[i]);
+	}
+
+	drm_free_large(pages);
+}
+
+static int gp2d_drm_gem_map_pages(struct drm_gem_object *obj,
+					struct vm_area_struct *vma,
+					unsigned long f_vaddr,
+					pgoff_t page_offset)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj = to_gp2d_gem_obj(obj);
+	struct gp2d_drm_gem_buf *buf = gp2d_gem_obj->buffer;
+	unsigned long pfn;
+
+	if (gp2d_gem_obj->flags & GP2D_BO_NONCONTIG) {
+		if (!buf->pages)
+			return -EINTR;
+
+		pfn = page_to_pfn(buf->pages[page_offset++]);
+	} else
+		pfn = (buf->dma_addr >> PAGE_SHIFT) + page_offset;
+
+	return vm_insert_mixed(vma, f_vaddr, pfn);
+}
+
+static int gp2d_drm_gem_get_pages(struct drm_gem_object *obj)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj = to_gp2d_gem_obj(obj);
+	struct gp2d_drm_gem_buf *buf = gp2d_gem_obj->buffer;
+	struct scatterlist *sgl;
+	struct page **pages;
+	unsigned int npages, i = 0;
+	int ret;
+
+	if (buf->pages) {
+		DRM_DEBUG_KMS("already allocated.\n");
+		return -EINVAL;
+	}
+
+	pages = gp2d_gem_get_pages(obj, GFP_KERNEL);
+	if (IS_ERR(pages)) {
+		DRM_ERROR("failed to get pages.\n");
+		return PTR_ERR(pages);
+	}
+
+	npages = obj->size >> PAGE_SHIFT;
+
+	buf->sgt = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!buf->sgt) {
+		DRM_ERROR("failed to allocate sg table.\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = sg_alloc_table(buf->sgt, npages, GFP_KERNEL);
+	if (ret < 0) {
+		DRM_ERROR("failed to initialize sg table.\n");
+		ret = -EFAULT;
+		goto err1;
+	}
+
+	sgl = buf->sgt->sgl;
+
+	/* set all pages to sg list. */
+	while (i < npages) {
+		sg_set_page(sgl, pages[i], PAGE_SIZE, 0);
+		sg_dma_address(sgl) = page_to_phys(pages[i]);
+		i++;
+		sgl = sg_next(sgl);
+	}
+
+	/* add some codes for UNCACHED type here. TODO */
+
+	buf->pages = pages;
+	return ret;
+err1:
+	kfree(buf->sgt);
+	buf->sgt = NULL;
+err:
+	gp2d_gem_put_pages(obj, pages, true, false);
+	return ret;
+
+}
+
+static void gp2d_drm_gem_put_pages(struct drm_gem_object *obj)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj = to_gp2d_gem_obj(obj);
+	struct gp2d_drm_gem_buf *buf = gp2d_gem_obj->buffer;
+
+	/*
+	 * if buffer typs is GP2D_BO_NONCONTIG then release all pages
+	 * allocated at gem fault handler.
+	 */
+	sg_free_table(buf->sgt);
+	kfree(buf->sgt);
+	buf->sgt = NULL;
+
+	gp2d_gem_put_pages(obj, buf->pages, true, false);
+	buf->pages = NULL;
+
+	/* add some codes for UNCACHED type here. TODO */
+}
+
+static int gp2d_drm_gem_handle_create(struct drm_gem_object *obj,
+					struct drm_file *file_priv,
+					unsigned int *handle)
+{
+	int ret;
+
+	/*
+	 * allocate a id of idr table where the obj is registered
+	 * and handle has the id what user can see.
+	 */
+	ret = drm_gem_handle_create(file_priv, obj, handle);
+	if (ret)
+		return ret;
+
+	DRM_DEBUG_KMS("gem handle = 0x%x\n", *handle);
+
+	/* drop reference from allocate - handle holds it now. */
+	drm_gem_object_unreference_unlocked(obj);
+
+	return 0;
+}
+
+void gp2d_drm_gem_destroy(struct gp2d_drm_gem_obj *gp2d_gem_obj)
+{
+	struct drm_gem_object *obj;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (!gp2d_gem_obj)
+		return;
+
+	obj = &gp2d_gem_obj->base;
+
+	DRM_DEBUG_KMS("handle count = %d\n", atomic_read(&obj->handle_count));
+
+	if ((gp2d_gem_obj->flags & GP2D_BO_NONCONTIG) &&
+			gp2d_gem_obj->buffer->pages)
+		gp2d_drm_gem_put_pages(obj);
+	else
+		gp2d_drm_free_buf(obj->dev, gp2d_gem_obj->flags,
+					gp2d_gem_obj->buffer);
+
+	gp2d_drm_fini_buf(obj->dev, gp2d_gem_obj->buffer);
+	gp2d_gem_obj->buffer = NULL;
+
+	if (obj->map_list.map)
+		drm_gem_free_mmap_offset(obj);
+
+	/* release file pointer to gem object. */
+	drm_gem_object_release(obj);
+
+	kfree(gp2d_gem_obj);
+	gp2d_gem_obj = NULL;
+}
+
+static struct gp2d_drm_gem_obj *gp2d_drm_gem_init(struct drm_device *dev,
+						      unsigned long size)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct drm_gem_object *obj;
+	int ret;
+
+	gp2d_gem_obj = kzalloc(sizeof(*gp2d_gem_obj), GFP_KERNEL);
+	if (!gp2d_gem_obj) {
+		DRM_ERROR("failed to allocate gp2d gem object\n");
+		return NULL;
+	}
+
+	gp2d_gem_obj->size = size;
+	obj = &gp2d_gem_obj->base;
+
+	ret = drm_gem_object_init(dev, obj, size);
+	if (ret < 0) {
+		DRM_ERROR("failed to initialize gem object\n");
+		kfree(gp2d_gem_obj);
+		return NULL;
+	}
+
+	DRM_DEBUG_KMS("created file object = 0x%x\n", (unsigned int)obj->filp);
+
+	return gp2d_gem_obj;
+}
+
+struct gp2d_drm_gem_obj *gp2d_drm_gem_create(struct drm_device *dev,
+						unsigned int flags,
+						unsigned long size)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct gp2d_drm_gem_buf *buf;
+	int ret;
+
+	if (!size) {
+		DRM_ERROR("invalid size.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	size = roundup_gem_size(size, flags);
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	ret = check_gem_flags(flags);
+	if (ret)
+		return ERR_PTR(ret);
+
+	buf = gp2d_drm_init_buf(dev, size);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	gp2d_gem_obj = gp2d_drm_gem_init(dev, size);
+	if (!gp2d_gem_obj) {
+		ret = -ENOMEM;
+		goto err_fini_buf;
+	}
+
+	gp2d_gem_obj->buffer = buf;
+
+	/* set memory type and cache attribute from user side. */
+	gp2d_gem_obj->flags = flags;
+
+	/*
+	 * allocate all pages as desired size if user wants to allocate
+	 * physically non-continuous memory.
+	 */
+	if (flags & GP2D_BO_NONCONTIG) {
+		ret = gp2d_drm_gem_get_pages(&gp2d_gem_obj->base);
+		if (ret < 0) {
+			drm_gem_object_release(&gp2d_gem_obj->base);
+			goto err_fini_buf;
+		}
+	} else {
+		ret = gp2d_drm_alloc_buf(dev, buf, flags);
+		if (ret < 0) {
+			drm_gem_object_release(&gp2d_gem_obj->base);
+			goto err_fini_buf;
+		}
+	}
+
+	return gp2d_gem_obj;
+
+err_fini_buf:
+	gp2d_drm_fini_buf(dev, buf);
+	return ERR_PTR(ret);
+}
+
+int gp2d_drm_gem_create_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv)
+{
+	struct drm_gp2d_gem_create *args = data;
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	int ret;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	gp2d_gem_obj = gp2d_drm_gem_create(dev, args->flags, args->size);
+	if (IS_ERR(gp2d_gem_obj))
+		return PTR_ERR(gp2d_gem_obj);
+
+	ret = gp2d_drm_gem_handle_create(&gp2d_gem_obj->base, file_priv,
+			&args->handle);
+	if (ret) {
+		gp2d_drm_gem_destroy(gp2d_gem_obj);
+		return ret;
+	}
+
+	return 0;
+}
+
+void *gp2d_drm_gem_get_dma_addr(struct drm_device *dev,
+					unsigned int gem_handle,
+					struct drm_file *file_priv)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct drm_gem_object *obj;
+
+	obj = drm_gem_object_lookup(dev, file_priv, gem_handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	gp2d_gem_obj = to_gp2d_gem_obj(obj);
+
+	if (gp2d_gem_obj->flags & GP2D_BO_NONCONTIG) {
+		DRM_DEBUG_KMS("not support NONCONTIG type.\n");
+		drm_gem_object_unreference_unlocked(obj);
+
+		/* TODO */
+		return ERR_PTR(-EINVAL);
+	}
+
+	return &gp2d_gem_obj->buffer->dma_addr;
+}
+
+void gp2d_drm_gem_put_dma_addr(struct drm_device *dev,
+					unsigned int gem_handle,
+					struct drm_file *file_priv)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct drm_gem_object *obj;
+
+	obj = drm_gem_object_lookup(dev, file_priv, gem_handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		return;
+	}
+
+	gp2d_gem_obj = to_gp2d_gem_obj(obj);
+
+	if (gp2d_gem_obj->flags & GP2D_BO_NONCONTIG) {
+		DRM_DEBUG_KMS("not support NONCONTIG type.\n");
+		drm_gem_object_unreference_unlocked(obj);
+
+		/* TODO */
+		return;
+	}
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	/*
+	 * decrease obj->refcount one more time because we has already
+	 * increased it at gp2d_drm_gem_get_dma_addr().
+	 */
+	drm_gem_object_unreference_unlocked(obj);
+}
+
+int gp2d_drm_gem_map_offset_ioctl(struct drm_device *dev, void *data,
+				    struct drm_file *file_priv)
+{
+	struct drm_gp2d_gem_map_off *args = data;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	DRM_DEBUG_KMS("handle = 0x%x, offset = 0x%lx\n",
+			args->handle, (unsigned long)args->offset);
+
+	if (!(dev->driver->driver_features & DRIVER_GEM)) {
+		DRM_ERROR("does not support GEM.\n");
+		return -ENODEV;
+	}
+
+	return gp2d_drm_gem_dumb_map_offset(file_priv, dev, args->handle,
+			&args->offset);
+}
+
+static int gp2d_drm_gem_mmap_buffer(struct file *filp,
+				      struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj = filp->private_data;
+	struct gp2d_drm_gem_obj *gp2d_gem_obj = to_gp2d_gem_obj(obj);
+	struct gp2d_drm_gem_buf *buffer;
+	unsigned long pfn, vm_size, usize, uaddr = vma->vm_start;
+	int ret;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	vma->vm_flags |= VM_IO;//(VM_IO | VM_RESERVED);
+
+	/* in case of direct mapping, always having non-cachable attribute */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	vm_size = usize = vma->vm_end - vma->vm_start;
+
+	/*
+	 * a buffer contains information to physically continuous memory
+	 * allocated by user request or at framebuffer creation.
+	 */
+	buffer = gp2d_gem_obj->buffer;
+
+	/* check if user-requested size is valid. */
+	if (vm_size > buffer->size)
+		return -EINVAL;
+
+	if (gp2d_gem_obj->flags & GP2D_BO_NONCONTIG) {
+		int i = 0;
+
+		if (!buffer->pages)
+			return -EINVAL;
+
+		vma->vm_flags |= VM_MIXEDMAP;
+
+		do {
+			ret = vm_insert_page(vma, uaddr, buffer->pages[i++]);
+			if (ret) {
+				DRM_ERROR("failed to remap user space.\n");
+				return ret;
+			}
+
+			uaddr += PAGE_SIZE;
+			usize -= PAGE_SIZE;
+		} while (usize > 0);
+	} else {
+		/*
+		 * get page frame number to physical memory to be mapped
+		 * to user space.
+		 */
+		pfn = ((unsigned long)gp2d_gem_obj->buffer->dma_addr) >>
+								PAGE_SHIFT;
+
+		DRM_DEBUG_KMS("pfn = 0x%lx\n", pfn);
+
+		if (remap_pfn_range(vma, vma->vm_start, pfn, vm_size,
+					vma->vm_page_prot)) {
+			DRM_ERROR("failed to remap pfn range.\n");
+			return -EAGAIN;
+		}
+	}
+
+	return 0;
+}
+
+static const struct file_operations gp2d_drm_gem_fops = {
+	.mmap = gp2d_drm_gem_mmap_buffer,
+};
+
+int gp2d_drm_gem_mmap_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	struct drm_gp2d_gem_mmap *args = data;
+	struct drm_gem_object *obj;
+	unsigned int addr;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (!(dev->driver->driver_features & DRIVER_GEM)) {
+		DRM_ERROR("does not support GEM.\n");
+		return -ENODEV;
+	}
+
+	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		return -EINVAL;
+	}
+
+	obj->filp->f_op = &gp2d_drm_gem_fops;
+	obj->filp->private_data = obj;
+
+	addr = vm_mmap(obj->filp, 0, args->size,
+			PROT_READ | PROT_WRITE, MAP_SHARED, 0);
+
+	drm_gem_object_unreference_unlocked(obj);
+
+	if (IS_ERR((void *)addr))
+		return PTR_ERR((void *)addr);
+
+	args->mapped = addr;
+
+	DRM_DEBUG_KMS("mapped = 0x%lx\n", (unsigned long)args->mapped);
+
+	return 0;
+}
+
+#define M2DG_OPCODE_TRAP        0x00000000
+#define M2DG_OPCODE_WPR         0x18000000
+#define M2DG_OPCODE_SYNC        0x12000000
+#define M2DG_OPCODE_LCOFS       0x40000000
+#define M2DG_OPCODE_MOVE        0x48000000
+#define M2DG_OPCODE_POLYGON_4A  0x82000000
+#define M2DG_OPCODE_POLYGON_4C  0x80000000
+#define M2DG_OPCODE_LINE_C      0xB0000000
+#define M2DG_OPCODE_BITBLTA     0xA2000100
+#define M2DG_OPCODE_BITBLTC     0xA0000000
+
+
+static int
+gp2d_get_dma_buf_phys( struct gp2d_drm_private *private,
+				   int				   fd,
+				   unsigned long 		  *ret_phys )
+{
+	int			 		  ret		= -EIO;
+	struct dma_buf 		 *buf		= NULL;
+	struct dma_buf_attachment *attachment	= NULL;
+	struct sg_table		 *table		= NULL;
+
+	buf = dma_buf_get( fd );
+	if (!buf) {
+		printk( "gp2d_get_dma_buf_phys: dma_buf_get(%d) failed!\n", fd );
+		return -ENOENT;
+	}
+
+	attachment = dma_buf_attach( buf, private->device->dev );
+	if (!attachment) {
+		printk( "gp2d_get_dma_buf_phys: dma_buf_attach(%d) failed!\n", fd );
+		goto error;
+	}
+
+	table = dma_buf_map_attachment( attachment, DMA_TO_DEVICE );
+	if (!table) {
+		printk( "gp2d_get_dma_buf_phys: dma_buf_map_attachment(%d) failed!\n", fd );
+		goto error;
+	}
+
+	BUG_ON( table->nents != 1 );
+
+	*ret_phys = table->sgl->dma_address;
+
+	ret = 0;
+
+error:
+	if (table)
+		dma_buf_unmap_attachment( attachment, table, DMA_TO_DEVICE );
+
+	if (attachment)
+		dma_buf_detach( buf, attachment );
+
+	dma_buf_put( buf );
+
+	return ret;
+}
+
+static int
+gp2d_parse_buffer( struct gp2d_drm_private *private,
+			    struct gp2d_drm_gem_buf *buffer )
+{
+	u32 *code = buffer->kvaddr;
+	u32  n    = 0;
+	u32  i    = 0;
+	int  ret;
+
+#define REQUIRE_WORDS(x)												\
+	do {															\
+		u32 left = buffer->size/4 - n;								\
+																\
+		if (left < (x)) {											\
+			printk( KERN_ERR "gp2d: command exceeds command buffer\n" );	\
+			return -EPROTO;										\
+		}														\
+	} while (0)
+
+	while (n < buffer->size/4) {
+		switch (code[n] & 0xff000000) {
+		case M2DG_OPCODE_TRAP:
+			return 0;
+
+		case M2DG_OPCODE_SYNC:
+			n += 1;
+			break;
+
+		case M2DG_OPCODE_MOVE:
+		case M2DG_OPCODE_LCOFS:
+			REQUIRE_WORDS( 2 );
+			n += 2;
+			break;
+
+		case (M2DG_OPCODE_BITBLTA & 0xff000000):
+		case M2DG_OPCODE_BITBLTC:
+		case M2DG_OPCODE_POLYGON_4C:
+			REQUIRE_WORDS( 6 );
+			n += 6;
+			break;
+
+		case M2DG_OPCODE_POLYGON_4A:
+			if (!(code[n] & 0x100)) {
+				printk( KERN_ERR "gp2d: invalid draw mode 0x%04x\n", code[n] & 0xffff );
+				return -EPERM;
+			}
+			REQUIRE_WORDS( 8 );
+			n += 8;
+			break;
+
+		case M2DG_OPCODE_WPR:
+			if (code[n] & 0x600) {
+				printk( KERN_ERR "gp2d: invalid draw mode 0x%04x\n", code[n] & 0xffff );
+				return -EPERM;
+			}
+			REQUIRE_WORDS( 2 );
+			if (code[n+1] & 0xff000000) {
+				printk( KERN_ERR "gp2d: invalid register count %u\n", code[n] >> 16 );
+				return -EPROTO;
+			}
+			REQUIRE_WORDS( 3 + (code[n+1] >> 16) );
+
+			// TODO: check for which registers get set?
+			for (i=0; i<=(code[n+1] >> 16); i++) {
+				switch ((code[n+1] & 0xfff) + i*4) {
+				case 0x50:	// RSAR
+					//printk("RSAR 0x%x (%d)\n",code[n+2+i],code[n+2+i]);
+					ret = gp2d_get_dma_buf_phys( private, code[n+2+i], (unsigned long*) &code[n+2+i] );
+					if (ret)
+						return ret;
+					break;
+
+				case 0x5c:	// DSTRR
+//					printk("DSTRR %u\n",code[n+2+i]);
+					break;
+
+				case 0x4c:	// SSAR
+					//printk("SSAR 0x%x (%d)\n",code[n+2+i],code[n+2+i]);
+					ret = gp2d_get_dma_buf_phys( private, code[n+2+i], (unsigned long*) &code[n+2+i] );
+					if (ret)
+						return ret;
+					break;
+
+				case 0x58:	// SSTRR
+//					printk("SSTRR %u\n",code[n+2+i]);
+					break;
+
+				case 0x80:	//
+				case 0x88:	//
+				case 0xd4:	//
+				case 0xd8:	//
+				case 0xc0:	//
+				case 0xd0:	//
+				case 0x1fc:	//
+//					printk("REG 0x%x = 0x%x\n",(code[n+1] & 0xff) + i*4,code[n+2+i]);
+					break;
+
+				default:
+					printk( KERN_ERR "gp2d: invalid register 0x%02x being set (to 0x%08x)\n", (code[n+1] & 0xff) + i*4, code[n+2+i] );
+				}
+			}
+
+			n += 3 + (code[n+1] >> 16);
+			break;
+
+		case M2DG_OPCODE_LINE_C:
+			if (code[n] & 0x600) {
+				printk( KERN_ERR "gp2d: invalid draw mode 0x%04x\n", code[n] & 0xffff );
+				return -EPERM;
+			}
+			REQUIRE_WORDS( 2 );
+			if ((code[n+1] & 0xffff) < 2) {
+				printk( KERN_ERR "gp2d: invalid line point count %u\n", code[n+1] & 0xffff );
+				return -EPROTO;
+			}
+			REQUIRE_WORDS( 3 + (code[n+1] & 0xffff) );
+			n += 3 + (code[n+1] & 0xffff);
+			break;
+
+		default:
+			printk( KERN_ERR "gp2d: invalid opcode 0x%02x\n", code[n] >> 24 );
+			return -EPERM;
+		}
+	}
+
+#undef REQUIRE_WORDS
+
+	printk( KERN_ERR "gp2d: missing TRAP before end of buffer\n" );
+
+	return -EPROTO;
+}
+
+int gp2d_drm_gem_execute_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	struct gp2d_drm_private *private = dev->dev_private;
+	struct drm_gp2d_gem_execute *args = data;
+	struct drm_gem_object *obj;
+	struct gp2d_execution *exec;
+
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct gp2d_drm_gem_buf *buffer;
+	int 		    ret = 0;
+	unsigned long irq_flags;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+
+	if (!(dev->driver->driver_features & DRIVER_GEM)) {
+		DRM_ERROR("does not support GEM.\n");
+		return -ENODEV;
+	}
+
+	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		return -EINVAL;
+	}
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+	gp2d_gem_obj = to_gp2d_gem_obj(obj);
+
+	buffer = gp2d_gem_obj->buffer;
+
+	ret = gp2d_parse_buffer( private, buffer );
+	if (ret)
+		goto error;
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+	exec = kzalloc( sizeof(struct gp2d_execution), GFP_KERNEL );
+	if (unlikely(exec == NULL)) {
+		DRM_ERROR("Failed to allocate an execution.\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+	exec->event.base.event     = &exec->event.event.base;
+	exec->event.base.file_priv = file_priv;
+	exec->event.base.destroy   = (void (*) (struct drm_pending_event *)) kfree;
+
+	exec->event.event.base.type   = DRM_GP2D_EVENT_EXECUTED;
+	exec->event.event.base.length = sizeof(exec->event.event);
+	exec->event.event.handle      = args->handle;
+	exec->event.event.user_data   = args->user_data;
+
+	exec->buffer = buffer;
+	exec->obj    = obj;
+
+	spin_lock_irqsave(&dev->event_lock, irq_flags);
+	list_add_tail(&exec->link, &private->executions);
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+	if (!private->busy) {
+		//printk("%d %lu\n",__LINE__,jiffies);
+		private->busy = 1;
+
+		//		printk("command 0x%08x (phys 0x%08lx)\n",*(u32*)buffer->kvaddr,buffer->dma_addr);
+		//printk("command 0x%08x (phys 0x%08lx)\n",ioread32(buffer->dma_addr),buffer->dma_addr);
+
+//		*(u32*)buffer->kvaddr = 0;
+
+		GP2D_DLSAR   = (unsigned long) buffer->dma_addr;
+		GP2D_ADREXTR = (unsigned long) buffer->dma_addr;
+		GP2D_SCLR    = GP2D_SCLR_START;
+	}
+
+	//printk("%d %lu\n",__LINE__,jiffies);
+	spin_unlock_irqrestore(&dev->event_lock, irq_flags);
+	//printk("%d %lu\n",__LINE__,jiffies);
+
+	return 0;
+
+
+error:
+	drm_gem_object_unreference_unlocked(obj);
+
+	return ret;
+}
+
+int gp2d_drm_waitidle_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv)
+{
+	int ret;
+	struct gp2d_drm_private *private = dev->dev_private;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	if (!(dev->driver->driver_features & DRIVER_GEM)) {
+		DRM_ERROR("does not support GEM.\n");
+		return -ENODEV;
+	}
+
+	ret = wait_event_interruptible_timeout( private->wq, !private->busy, 10 * HZ );
+	if (ret < 0)
+		return ret;
+
+	if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+
+irqreturn_t
+gp2d_irq_handler( int irq, void *ctx )
+{
+	struct gp2d_drm_private *private = ctx;
+
+	u32 status = GP2D_STATUS;
+
+//	printk( KERN_DEBUG "%s: IRQ - STATUS 0x%08x\n", __FUNCTION__, status );
+
+	if (! (status & GP2D_INT_ANY)) {
+#ifndef GP2D_IRQ_POLLER
+//          printk( KERN_WARNING "%s: bogus interrupt, STATUS 0x%08x!\n", __FUNCTION__, status );
+#endif
+          return IRQ_NONE;
+     }
+
+     if (status & GP2D_INT_ERROR) {
+          printk( KERN_ERR "%s: error! STATUS 0x%08x!\n", __FUNCTION__, status );
+	//	QPRINT( "Resetting hardware..." );
+
+		GP2D_SCLR = GP2D_SCLR_RESET;
+		udelay( 5 );
+		GP2D_SCLR = 0;
+
+	//	QPRINT( "Clearing interrupts..." );
+
+		GP2D_STATUS_CLEAR = GP2D_INT_ANY;
+
+		GP2D_INT_ENABLE   = GP2D_INT_ANY;
+
+	//	QDUMP( "Ready" );
+
+		printk( "GP2D STATUS 0x%08x\n", GP2D_STATUS );
+	}
+	else
+		/* Clear the interrupt. */
+		GP2D_STATUS_CLEAR = status & GP2D_INT_ANY;
+
+     if (status & (GP2D_INT_TRAP | GP2D_INT_ERROR)) {
+		struct drm_device *dev = private->device;
+		unsigned long 	    irq_flags;
+
+		spin_lock_irqsave(&dev->event_lock, irq_flags);
+
+		if (!list_empty( &private->executions )) {
+			struct drm_file   	  *file_priv;
+			struct gp2d_execution *exec = list_first_entry( &private->executions, struct gp2d_execution, link );
+
+			file_priv = exec->event.base.file_priv;
+
+			list_del(&exec->link);
+
+			drm_gem_object_unreference_unlocked( exec->obj );
+
+			list_add_tail(&exec->event.base.link, &file_priv->event_list);
+			wake_up_all(&file_priv->event_wait);
+		}
+
+		if (list_empty( &private->executions )) {
+//			GP2D_SCLR = 0;
+
+			private->busy = 0;
+			wake_up_all( &private->wq );
+		}
+		else {
+			struct gp2d_execution *exec = list_first_entry( &private->executions, struct gp2d_execution, link );
+
+			GP2D_DLSAR = (unsigned long)exec->buffer->dma_addr;
+			GP2D_SCLR  = GP2D_SCLR_START;
+		}
+
+		spin_unlock_irqrestore(&dev->event_lock, irq_flags);
+     }
+
+	return IRQ_HANDLED;
+}
+
+
+
+
+int gp2d_drm_gem_init_object(struct drm_gem_object *obj)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	return 0;
+}
+
+void gp2d_drm_gem_free_object(struct drm_gem_object *obj)
+{
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	gp2d_drm_gem_destroy(to_gp2d_gem_obj(obj));
+}
+
+int gp2d_drm_gem_dumb_create(struct drm_file *file_priv,
+			       struct drm_device *dev,
+			       struct drm_mode_create_dumb *args)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	int ret;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/*
+	 * alocate memory to be used for framebuffer.
+	 * - this callback would be called by user application
+	 *	with DRM_IOCTL_MODE_CREATE_DUMB command.
+	 */
+
+	args->pitch = args->width * args->bpp >> 3;
+	args->size = PAGE_ALIGN(args->pitch * args->height);
+
+	gp2d_gem_obj = gp2d_drm_gem_create(dev, args->flags, args->size);
+	if (IS_ERR(gp2d_gem_obj))
+		return PTR_ERR(gp2d_gem_obj);
+
+	ret = gp2d_drm_gem_handle_create(&gp2d_gem_obj->base, file_priv,
+			&args->handle);
+	if (ret) {
+		gp2d_drm_gem_destroy(gp2d_gem_obj);
+		return ret;
+	}
+
+	return 0;
+}
+
+int gp2d_drm_gem_dumb_map_offset(struct drm_file *file_priv,
+				   struct drm_device *dev, uint32_t handle,
+				   uint64_t *offset)
+{
+	struct gp2d_drm_gem_obj *gp2d_gem_obj;
+	struct drm_gem_object *obj;
+	int ret = 0;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	mutex_lock(&dev->struct_mutex);
+
+	/*
+	 * get offset of memory allocated for drm framebuffer.
+	 * - this callback would be called by user application
+	 *	with DRM_IOCTL_MODE_MAP_DUMB command.
+	 */
+
+	obj = drm_gem_object_lookup(dev, file_priv, handle);
+	if (!obj) {
+		DRM_ERROR("failed to lookup gem object.\n");
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	gp2d_gem_obj = to_gp2d_gem_obj(obj);
+
+	if (!gp2d_gem_obj->base.map_list.map) {
+		ret = drm_gem_create_mmap_offset(&gp2d_gem_obj->base);
+		if (ret)
+			goto out;
+	}
+
+	*offset = (u64)gp2d_gem_obj->base.map_list.hash.key << PAGE_SHIFT;
+	DRM_DEBUG_KMS("offset = 0x%lx\n", (unsigned long)*offset);
+
+out:
+	drm_gem_object_unreference(obj);
+unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+int gp2d_drm_gem_dumb_destroy(struct drm_file *file_priv,
+				struct drm_device *dev,
+				unsigned int handle)
+{
+	int ret;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/*
+	 * obj->refcount and obj->handle_count are decreased and
+	 * if both them are 0 then gp2d_drm_gem_free_object()
+	 * would be called by callback to release resources.
+	 */
+	ret = drm_gem_handle_delete(file_priv, handle);
+	if (ret < 0) {
+		DRM_ERROR("failed to delete drm_gem_handle.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int gp2d_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct drm_device *dev = obj->dev;
+	unsigned long f_vaddr;
+	pgoff_t page_offset;
+	int ret;
+
+	page_offset = ((unsigned long)vmf->virtual_address -
+			vma->vm_start) >> PAGE_SHIFT;
+	f_vaddr = (unsigned long)vmf->virtual_address;
+
+	mutex_lock(&dev->struct_mutex);
+
+	ret = gp2d_drm_gem_map_pages(obj, vma, f_vaddr, page_offset);
+	if (ret < 0)
+		DRM_ERROR("failed to map pages.\n");
+
+	mutex_unlock(&dev->struct_mutex);
+
+	return convert_to_vm_err_msg(ret);
+}
+
+int gp2d_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+
+	DRM_DEBUG_KMS("%s\n", __FILE__);
+
+	/* set vm_area_struct. */
+	ret = drm_gem_mmap(filp, vma);
+	if (ret < 0) {
+		DRM_ERROR("failed to mmap.\n");
+		return ret;
+	}
+
+	vma->vm_flags &= ~VM_PFNMAP;
+	vma->vm_flags |= VM_MIXEDMAP;
+
+	return ret;
+}
diff --git a/drivers/gpu/drm/gp2d/gp2d_drm_gem.h b/drivers/gpu/drm/gp2d/gp2d_drm_gem.h
new file mode 100644
index 0000000..c9ec98c
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/gp2d_drm_gem.h
@@ -0,0 +1,163 @@
+/* gp2d_drm_gem.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Authoer: Inki Dae <inki.dae@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _GP2D_DRM_GEM_H_
+#define _GP2D_DRM_GEM_H_
+
+#define to_gp2d_gem_obj(x)	container_of(x,\
+			struct gp2d_drm_gem_obj, base)
+
+#define IS_NONCONTIG_BUFFER(f)		(f & GP2D_BO_NONCONTIG)
+
+/*
+ * gp2d drm gem buffer structure.
+ *
+ * @kvaddr: kernel virtual address to allocated memory region.
+ * @dma_addr: bus address(accessed by dma) to allocated memory region.
+ *	- this address could be physical address without IOMMU and
+ *	device address with IOMMU.
+ * @sgt: sg table to transfer page data.
+ * @pages: contain all pages to allocated memory region.
+ * @size: size of allocated memory region.
+ */
+struct gp2d_drm_gem_buf {
+	void __iomem		*kvaddr;
+	dma_addr_t		dma_addr;
+	struct sg_table		*sgt;
+	struct page		**pages;
+	unsigned long		size;
+};
+
+/*
+ * gp2d drm buffer structure.
+ *
+ * @base: a gem object.
+ *	- a new handle to this gem object would be created
+ *	by drm_gem_handle_create().
+ * @buffer: a pointer to gp2d_drm_gem_buffer object.
+ *	- contain the information to memory region allocated
+ *	by user request or at framebuffer creation.
+ *	continuous memory region allocated by user request
+ *	or at framebuffer creation.
+ * @size: total memory size to physically non-continuous memory region.
+ * @flags: indicate memory type to allocated buffer and cache attruibute.
+ *
+ * P.S. this object would be transfered to user as kms_bo.handle so
+ *	user can access the buffer through kms_bo.handle.
+ */
+struct gp2d_drm_gem_obj {
+	struct drm_gem_object		base;
+	struct gp2d_drm_gem_buf	*buffer;
+	unsigned long			size;
+	unsigned int			flags;
+};
+
+/* destroy a buffer with gem object */
+void gp2d_drm_gem_destroy(struct gp2d_drm_gem_obj *gp2d_gem_obj);
+
+/* create a new buffer with gem object */
+struct gp2d_drm_gem_obj *gp2d_drm_gem_create(struct drm_device *dev,
+						unsigned int flags,
+						unsigned long size);
+
+/*
+ * request gem object creation and buffer allocation as the size
+ * that it is calculated with framebuffer information such as width,
+ * height and bpp.
+ */
+int gp2d_drm_gem_create_ioctl(struct drm_device *dev, void *data,
+				struct drm_file *file_priv);
+
+/*
+ * get dma address from gem handle and this function could be used for
+ * other drivers such as 2d/3d acceleration drivers.
+ * with this function call, gem object reference count would be increased.
+ */
+void *gp2d_drm_gem_get_dma_addr(struct drm_device *dev,
+					unsigned int gem_handle,
+					struct drm_file *file_priv);
+
+/*
+ * put dma address from gem handle and this function could be used for
+ * other drivers such as 2d/3d acceleration drivers.
+ * with this function call, gem object reference count would be decreased.
+ */
+void gp2d_drm_gem_put_dma_addr(struct drm_device *dev,
+					unsigned int gem_handle,
+					struct drm_file *file_priv);
+
+/* get buffer offset to map to user space. */
+int gp2d_drm_gem_map_offset_ioctl(struct drm_device *dev, void *data,
+				    struct drm_file *file_priv);
+
+/*
+ * mmap the physically continuous memory that a gem object contains
+ * to user space.
+ */
+int gp2d_drm_gem_mmap_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+
+int gp2d_drm_gem_execute_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+
+int gp2d_drm_waitidle_ioctl(struct drm_device *dev, void *data,
+			      struct drm_file *file_priv);
+
+/* initialize gem object. */
+int gp2d_drm_gem_init_object(struct drm_gem_object *obj);
+
+/* free gem object. */
+void gp2d_drm_gem_free_object(struct drm_gem_object *gem_obj);
+
+/* create memory region for drm framebuffer. */
+int gp2d_drm_gem_dumb_create(struct drm_file *file_priv,
+			       struct drm_device *dev,
+			       struct drm_mode_create_dumb *args);
+
+/* map memory region for drm framebuffer to user space. */
+int gp2d_drm_gem_dumb_map_offset(struct drm_file *file_priv,
+				   struct drm_device *dev, uint32_t handle,
+				   uint64_t *offset);
+
+/*
+ * destroy memory region allocated.
+ *	- a gem handle and physical memory region pointed by a gem object
+ *	would be released by drm_gem_handle_delete().
+ */
+int gp2d_drm_gem_dumb_destroy(struct drm_file *file_priv,
+				struct drm_device *dev,
+				unsigned int handle);
+
+/* page fault handler and mmap fault address(virtual) to physical memory. */
+int gp2d_drm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+
+/* set vm_flags and we can change the vm attribute to other one at here. */
+int gp2d_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+
+
+irqreturn_t
+gp2d_irq_handler( int irq, void *ctx );
+
+#endif
diff --git a/drivers/gpu/drm/gp2d/regs-gp2d.h b/drivers/gpu/drm/gp2d/regs-gp2d.h
new file mode 100644
index 0000000..10b737a
--- /dev/null
+++ b/drivers/gpu/drm/gp2d/regs-gp2d.h
@@ -0,0 +1,91 @@
+/*
+ *
+ *  Cloned from drivers/media/video/s5p-tv/regs-vp.h
+ *
+ * Copyright (c) 2010-2011 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com/
+ *
+ * Video processor register header file for Samsung Mixer driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SAMSUNG_REGS_VP_H
+#define SAMSUNG_REGS_VP_H
+
+/*
+ * Register part
+ */
+
+#define VP_ENABLE			0x0000
+#define VP_SRESET			0x0004
+#define VP_SHADOW_UPDATE		0x0008
+#define VP_FIELD_ID			0x000C
+#define VP_MODE				0x0010
+#define VP_IMG_SIZE_Y			0x0014
+#define VP_IMG_SIZE_C			0x0018
+#define VP_PER_RATE_CTRL		0x001C
+#define VP_TOP_Y_PTR			0x0028
+#define VP_BOT_Y_PTR			0x002C
+#define VP_TOP_C_PTR			0x0030
+#define VP_BOT_C_PTR			0x0034
+#define VP_ENDIAN_MODE			0x03CC
+#define VP_SRC_H_POSITION		0x0044
+#define VP_SRC_V_POSITION		0x0048
+#define VP_SRC_WIDTH			0x004C
+#define VP_SRC_HEIGHT			0x0050
+#define VP_DST_H_POSITION		0x0054
+#define VP_DST_V_POSITION		0x0058
+#define VP_DST_WIDTH			0x005C
+#define VP_DST_HEIGHT			0x0060
+#define VP_H_RATIO			0x0064
+#define VP_V_RATIO			0x0068
+#define VP_POLY8_Y0_LL			0x006C
+#define VP_POLY4_Y0_LL			0x00EC
+#define VP_POLY4_C0_LL			0x012C
+
+/*
+ * Bit definition part
+ */
+
+/* generates mask for range of bits */
+
+#define VP_MASK(high_bit, low_bit) \
+	(((2 << ((high_bit) - (low_bit))) - 1) << (low_bit))
+
+#define VP_MASK_VAL(val, high_bit, low_bit) \
+	(((val) << (low_bit)) & VP_MASK(high_bit, low_bit))
+
+ /* VP_ENABLE */
+#define VP_ENABLE_ON			(1 << 0)
+
+/* VP_SRESET */
+#define VP_SRESET_PROCESSING		(1 << 0)
+
+/* VP_SHADOW_UPDATE */
+#define VP_SHADOW_UPDATE_ENABLE		(1 << 0)
+
+/* VP_MODE */
+#define VP_MODE_NV12			(0 << 6)
+#define VP_MODE_NV21			(1 << 6)
+#define VP_MODE_LINE_SKIP		(1 << 5)
+#define VP_MODE_MEM_LINEAR		(0 << 4)
+#define VP_MODE_MEM_TILED		(1 << 4)
+#define VP_MODE_FMT_MASK		(5 << 4)
+#define VP_MODE_FIELD_ID_AUTO_TOGGLING	(1 << 2)
+#define VP_MODE_2D_IPC			(1 << 1)
+
+/* VP_IMG_SIZE_Y */
+/* VP_IMG_SIZE_C */
+#define VP_IMG_HSIZE(x)			VP_MASK_VAL(x, 29, 16)
+#define VP_IMG_VSIZE(x)			VP_MASK_VAL(x, 13, 0)
+
+/* VP_SRC_H_POSITION */
+#define VP_SRC_H_POSITION_VAL(x)	VP_MASK_VAL(x, 14, 4)
+
+/* VP_ENDIAN_MODE */
+#define VP_ENDIAN_MODE_LITTLE		(1 << 0)
+
+#endif /* SAMSUNG_REGS_VP_H */
diff --git a/include/drm/gp2d_drm.h b/include/drm/gp2d_drm.h
new file mode 100644
index 0000000..e79edaf
--- /dev/null
+++ b/include/drm/gp2d_drm.h
@@ -0,0 +1,131 @@
+/* gp2d_drm.h
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ * Authors:
+ *	Inki Dae <inki.dae@samsung.com>
+ *	Joonyoung Shim <jy0922.shim@samsung.com>
+ *	Seung-Woo Kim <sw0312.kim@samsung.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _GP2D_DRM_H_
+#define _GP2D_DRM_H_
+
+/**
+ * User-desired buffer creation information structure.
+ *
+ * @size: user-desired memory allocation size.
+ *	- this size value would be page-aligned internally.
+ * @flags: user request for setting memory type or cache attributes.
+ * @handle: returned a handle to created gem object.
+ *	- this handle will be set by gem module of kernel side.
+ */
+struct drm_gp2d_gem_create {
+	uint64_t size;
+	unsigned int flags;
+	unsigned int handle;
+     // TODO: integrate mapping into this ioctl to avoid another context switch
+};
+
+/**
+ * A structure for getting buffer offset.
+ *
+ * @handle: a pointer to gem object created.
+ * @pad: just padding to be 64-bit aligned.
+ * @offset: relatived offset value of the memory region allocated.
+ *	- this value should be set by user.
+ */
+struct drm_gp2d_gem_map_off {
+	unsigned int handle;
+	unsigned int pad;
+	uint64_t offset;
+};
+
+/**
+ * A structure for mapping buffer.
+ *
+ * @handle: a handle to gem object created.
+ * @size: memory size to be mapped.
+ * @mapped: having user virtual address mmaped.
+ *	- this variable would be filled by gp2d gem module
+ *	of kernel side with user virtual address which is allocated
+ *	by do_mmap().
+ */
+struct drm_gp2d_gem_mmap {
+	unsigned int handle;
+	unsigned int size;
+	uint64_t mapped;
+};
+
+/**
+ * A structure for executing buffer.
+ *
+ * @handle: a handle to gem object created.
+ * @size: length of buffer to execute.
+ */
+struct drm_gp2d_gem_execute {
+	unsigned int  handle;
+	unsigned int  size;
+     void         *user_data;
+};
+
+/*
+ * event structure for execution finished
+ */
+struct drm_gp2d_event_executed {
+     struct drm_event  base;
+	unsigned int      handle;
+     void             *user_data;
+};
+
+/* memory type definitions. */
+enum e_drm_gp2d_gem_mem_type {
+	/* Physically Non-Continuous memory. */
+	GP2D_BO_NONCONTIG	= 1 << 0,
+	GP2D_BO_MASK		= GP2D_BO_NONCONTIG
+};
+
+#define DRM_GP2D_GEM_CREATE		0x00
+#define DRM_GP2D_GEM_MAP_OFFSET	0x01
+#define DRM_GP2D_GEM_MMAP		0x02
+#define DRM_GP2D_GEM_EXECUTE		0x03
+#define DRM_GP2D_WAITIDLE		0x04
+
+#define DRM_IOCTL_GP2D_GEM_CREATE		DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_GP2D_GEM_CREATE, struct drm_gp2d_gem_create)
+
+#define DRM_IOCTL_GP2D_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_GP2D_GEM_MAP_OFFSET, struct drm_gp2d_gem_map_off)
+
+#define DRM_IOCTL_GP2D_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_GP2D_GEM_MMAP, struct drm_gp2d_gem_mmap)
+
+#define DRM_IOCTL_GP2D_GEM_EXECUTE	DRM_IOWR(DRM_COMMAND_BASE + \
+		DRM_GP2D_GEM_EXECUTE, struct drm_gp2d_gem_execute)
+
+#define DRM_IOCTL_GP2D_WAITIDLE		DRM_IO(DRM_COMMAND_BASE + \
+		DRM_GP2D_WAITIDLE)
+
+
+
+#define DRM_GP2D_EVENT_EXECUTED    0x2DE
+
+#endif	/* _GP2D_DRM_H_ */
-- 
1.8.2

